<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>California Grid Utilization Explorer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f1117;
            color: #e0e0e0;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, #1a1d2e 0%, #0f1117 100%);
            border-bottom: 1px solid #2a2d3e;
            padding: 20px 30px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header h1 {
            font-size: 22px;
            font-weight: 600;
            color: #fff;
        }

        .header .subtitle {
            font-size: 13px;
            color: #888;
            margin-top: 2px;
        }

        .date-display {
            text-align: right;
        }

        .date-display .current-date {
            font-size: 28px;
            font-weight: 700;
            color: #60a5fa;
            font-variant-numeric: tabular-nums;
        }

        .date-display .date-info {
            font-size: 12px;
            color: #888;
            margin-top: 2px;
        }

        .loading-overlay {
            position: fixed;
            inset: 0;
            background: #0f1117;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.3s;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-overlay .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #2a2d3e;
            border-top-color: #60a5fa;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .loading-overlay p {
            margin-top: 16px;
            color: #888;
            font-size: 14px;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .main {
            padding: 20px 30px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .stats-row {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #1a1d2e;
            border: 1px solid #2a2d3e;
            border-radius: 8px;
            padding: 14px 16px;
        }

        .stat-card .label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #888;
            margin-bottom: 4px;
        }

        .stat-card .value {
            font-size: 22px;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }

        .stat-card .unit {
            font-size: 12px;
            font-weight: 400;
            color: #888;
            margin-left: 2px;
        }

        .stat-card .sub {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
        }

        .chart-container {
            background: #1a1d2e;
            border: 1px solid #2a2d3e;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 16px;
            position: relative;
        }

        .chart-container h3 {
            font-size: 14px;
            font-weight: 600;
            color: #ccc;
            margin-bottom: 6px;
        }

        .chart-note {
            font-size: 11px;
            color: #666;
            margin-bottom: 10px;
            line-height: 1.4;
        }

        .chart-wrapper {
            position: relative;
            height: 320px;
        }

        .chart-wrapper.short {
            height: 200px;
        }

        .chart-wrapper.medium {
            height: 260px;
        }

        .chart-wrapper.tall {
            height: 400px;
        }

        .analysis-row {
            display: grid;
            grid-template-columns: 500px 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }

        .statistical-charts-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }

        .slider-section {
            background: #1a1d2e;
            border: 1px solid #2a2d3e;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .slider-row label {
            font-size: 13px;
            color: #888;
            white-space: nowrap;
        }

        .slider-row input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #2a2d3e;
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #60a5fa;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(96, 165, 250, 0.4);
        }

        .slider-row input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #60a5fa;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(96, 165, 250, 0.4);
        }

        .playback-controls {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            align-items: center;
        }

        .playback-controls button {
            background: #2a2d3e;
            border: 1px solid #3a3d4e;
            color: #e0e0e0;
            padding: 6px 14px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .playback-controls button:hover {
            background: #3a3d4e;
        }

        .playback-controls button.active {
            background: #60a5fa;
            border-color: #60a5fa;
            color: #000;
        }

        .playback-controls .speed-label {
            font-size: 12px;
            color: #888;
            margin-left: 12px;
        }

        .year-ticks {
            display: flex;
            justify-content: space-between;
            padding: 4px 0 0;
            font-size: 11px;
            color: #666;
        }

        .hydro-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .hydro-wet { background: #164e63; color: #67e8f9; }
        .hydro-above { background: #1e3a5f; color: #93c5fd; }
        .hydro-below { background: #422006; color: #fbbf24; }
        .hydro-dry { background: #451a03; color: #fb923c; }
        .hydro-critical { background: #450a0a; color: #fca5a5; }

        .no-data-msg {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #666;
        }

        @media (max-width: 900px) {
            .stats-row { grid-template-columns: repeat(3, 1fr); }
            .header { flex-direction: column; align-items: flex-start; gap: 10px; }
            .date-display { text-align: left; }
            .main { padding: 12px; }
            .analysis-row { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <p>Loading demand & capacity data...</p>
    </div>

    <div class="header">
        <div>
            <h1>California Grid Utilization Explorer</h1>
            <div class="subtitle">CAISO actual demand vs available generation capacity, 2020 &ndash; 2025</div>
        </div>
        <div class="date-display">
            <div class="current-date" id="currentDate">2020-01-01</div>
            <div class="date-info" id="dateInfo">Wednesday &middot; January 2020</div>
        </div>
    </div>

    <div class="main">
        <!-- Stats -->
        <div class="stats-row">
            <div class="stat-card">
                <div class="label">Peak Demand</div>
                <div class="value" id="statPeakDemand">--<span class="unit">MW</span></div>
                <div class="sub" id="statPeakDemandHour">--</div>
            </div>
            <div class="stat-card">
                <div class="label">Peak Available</div>
                <div class="value" id="statPeakAvail">--<span class="unit">MW</span></div>
                <div class="sub" id="statPeakAvailHour">--</div>
            </div>
            <div class="stat-card">
                <div class="label">Min Effective Margin</div>
                <div class="value" id="statMinHeadroom">--<span class="unit">MW</span></div>
                <div class="sub" id="statMinHeadroomHour">--</div>
            </div>
            <div class="stat-card">
                <div class="label">Avg Utilization</div>
                <div class="value" id="statUtilization">--<span class="unit">%</span></div>
                <div class="sub">demand / available</div>
            </div>
            <div class="stat-card">
                <div class="label">Hydro Year</div>
                <div class="value" id="statHydroYear">--</div>
                <div class="sub" id="statHydroSub">--</div>
            </div>
        </div>

        <!-- Capacity & Demand Chart -->
        <div class="chart-container">
            <h3>Hourly Available Capacity & Demand</h3>
            <div class="chart-wrapper">
                <canvas id="capacityChart"></canvas>
                <div class="no-data-msg" id="noDataMsg" style="display:none;">No demand data for this date</div>
            </div>
        </div>

        <!-- Headroom Chart -->
        <div class="chart-container">
            <h3>Headroom Analysis: Required Reserves & Effective Margin</h3>
            <div class="chart-note">Reserves based on CAISO methodology: Peak hours (4-9 PM) require 8.4% of demand, shoulder hours 7.7%, off-peak 7.0%, minimum 3,500 MW</div>
            <div class="chart-wrapper short">
                <canvas id="headroomChart"></canvas>
            </div>
        </div>

        <!-- Price Chart -->
        <div class="chart-container">
            <h3>Hourly CAISO-Averaged LMP Breakdown</h3>
            <div class="chart-note">Components: Marginal Energy Cost (MEC), Congestion (MCC), Losses (MCL), GHG Adder (Average of NP15, SP15, ZP26)</div>
            <div class="chart-wrapper short">
                <canvas id="priceChart"></canvas>
                <div class="no-data-msg" id="noPriceDataMsg" style="display:none;">No price data for this date</div>
            </div>
        </div>

        <!-- Analysis Row: Average Capacity + Scatter Plot -->
        <div class="analysis-row">
            <!-- Average Daily Capacity by Resource -->
            <div class="chart-container">
                <h3>Average Daily Capacity by Resource</h3>
                <div class="chart-wrapper tall">
                    <canvas id="avgCapacityChart"></canvas>
                </div>
            </div>

            <!-- Accumulating Scatter Plot -->
            <div class="chart-container">
                <h3>Grid Stress Analysis: Minimum Effective Margin vs Available Capacity (Accumulating)</h3>
                <div class="chart-wrapper tall">
                    <canvas id="scatterChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Slider -->
        <div class="slider-section">
            <div class="slider-row">
                <label>Date:</label>
                <input type="range" id="dateSlider" min="0" max="2191" value="0" step="1">
            </div>
            <div class="year-ticks">
                <span>2020</span><span>2021</span><span>2022</span><span>2023</span><span>2024</span><span>2025</span>
            </div>
            <div class="playback-controls">
                <button id="btnPrev" title="Previous day">&larr; Prev</button>
                <button id="btnPlay" title="Play/Pause">&#9654; Play</button>
                <button id="btnNext" title="Next day">Next &rarr;</button>
                <button id="btnReset" title="Reset scatter plot">Reset Scatter</button>
                <label for="datePicker" style="margin-left: 16px; font-size: 12px; color: #888;">Jump to:</label>
                <input type="date" id="datePicker" min="2020-01-01" max="2025-12-31" value="2020-01-01"
                       style="background: #2a2d3e; border: 1px solid #3a3d4e; color: #e0e0e0; padding: 6px 10px; border-radius: 6px; font-size: 13px; cursor: pointer;">
                <span class="speed-label">Speed:</span>
                <button class="speed-btn" data-speed="500">1x</button>
                <button class="speed-btn active" data-speed="200">2x</button>
                <button class="speed-btn" data-speed="80">5x</button>
                <button class="speed-btn" data-speed="30">10x</button>
            </div>
        </div>

        <!-- Statistical Analysis Charts (All Days) -->
        <div class="statistical-charts-row">
            <!-- Confidence Interval Chart -->
            <div class="chart-container">
                <h3>Effective Headroom Profile (All Days: 2020-2025)</h3>
                <div class="chart-note">Percentiles of effective headroom across all 2,192 days showing confidence intervals</div>
                <div class="chart-wrapper">
                    <canvas id="confidenceChart"></canvas>
                </div>
            </div>

            <!-- Histogram Chart -->
            <div class="chart-container">
                <h3>Minimum Effective Headroom Distribution</h3>
                <div class="chart-note">Frequency distribution of daily minimum effective headroom values (GW)</div>
                <div class="chart-wrapper">
                    <canvas id="histogramChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
    (async function() {
        // ─── Data Loading ────────────────────────────────────────────────
        const [demandData, capacityData, priceData] = await Promise.all([
            fetch('demand_forecast.json').then(r => r.json()),
            fetch('available_capacity.json').then(r => r.json()),
            fetch('caiso_prices.json').then(r => r.json()).catch(() => ({}))
        ]);

        // ─── Compute Global Y-Axis Limits ────────────────────────────────
        let maxCapacity = 0;
        let minHeadroom = 0;
        let maxHeadroom = 0;
        let minScatterAvail = Infinity;
        let maxScatterAvail = 0;
        let minScatterHead = Infinity;
        let maxScatterHead = -Infinity;

        for (const year in capacityData) {
            for (const month in capacityData[year]) {
                const monthData = capacityData[year][month];
                const totalArr = monthData.Total || [];
                maxCapacity = Math.max(maxCapacity, ...totalArr);
            }
        }

        for (const dateStr in demandData) {
            const [y, m, d] = dateStr.split('-');
            const monthData = capacityData[y] && capacityData[y][m];
            if (!monthData) continue;
            const demand = demandData[dateStr];
            const total = monthData.Total || [];
            for (let h = 0; h < 24; h++) {
                const head = (total[h] || 0) - (demand[h] || 0);
                minHeadroom = Math.min(minHeadroom, head);
                maxHeadroom = Math.max(maxHeadroom, head);
            }

            // Compute scatter plot bounds (min headroom point for each day)
            const demArr = demand.map(v => v || 0);
            const headArr = total.map((a, i) => a - demArr[i]);
            const minH = Math.min(...headArr);
            const minHIdx = headArr.indexOf(minH);
            const availAtMinH = total[minHIdx];

            minScatterAvail = Math.min(minScatterAvail, availAtMinH);
            maxScatterAvail = Math.max(maxScatterAvail, availAtMinH);
            minScatterHead = Math.min(minScatterHead, minH);
            maxScatterHead = Math.max(maxScatterHead, minH);
        }

        // Round limits for nice chart ranges
        maxCapacity = Math.ceil(maxCapacity / 5000) * 5000;
        minHeadroom = Math.floor(minHeadroom / 5000) * 5000;
        maxHeadroom = Math.ceil(maxHeadroom / 5000) * 5000;
        minScatterAvail = Math.floor(minScatterAvail / 5000) * 5000;
        maxScatterAvail = Math.ceil(maxScatterAvail / 5000) * 5000;
        minScatterHead = Math.floor(minScatterHead / 5000) * 5000;
        maxScatterHead = Math.ceil(maxScatterHead / 5000) * 5000;

        document.getElementById('loadingOverlay').classList.add('hidden');

        // ─── Date Helpers ────────────────────────────────────────────────
        const START = new Date(2020, 0, 1);
        const DAYS = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
        const MONTHS = ['January','February','March','April','May','June',
                        'July','August','September','October','November','December'];

        function indexToDate(i) {
            const d = new Date(START);
            d.setDate(d.getDate() + i);
            return d;
        }

        function dateToStr(d) {
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${day}`;
        }

        function dateStrToIndex(dateStr) {
            const [y, m, d] = dateStr.split('-').map(Number);
            const targetDate = new Date(y, m - 1, d);
            const diffTime = targetDate - START;
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            return Math.max(0, Math.min(2191, diffDays));
        }

        // ─── Hydro Year Info ─────────────────────────────────────────────
        const HYDRO_INFO = {
            '2020': { type: 'Dry', cls: 'hydro-dry', detail: 'Sacramento: Dry / San Joaquin: Dry' },
            '2021': { type: 'Critical', cls: 'hydro-critical', detail: 'Sacramento: Critical / San Joaquin: Critical' },
            '2022': { type: 'Critical', cls: 'hydro-critical', detail: 'Sacramento: Critical / San Joaquin: Critical' },
            '2023': { type: 'Wet', cls: 'hydro-wet', detail: 'Sacramento: Wet / San Joaquin: Wet' },
            '2024': { type: 'Above Normal', cls: 'hydro-above', detail: 'Sacramento: Above Normal / San Joaquin: Above Normal' },
            '2025': { type: 'Above Normal', cls: 'hydro-above', detail: 'Sacramento: Above Normal / San Joaquin: Below Normal' },
        };

        // ─── Resource Colors ─────────────────────────────────────────────
        const RESOURCE_COLORS = {
            'Solar':           { bg: 'rgba(250, 204, 21, 0.8)',  border: '#facc15' },
            'Wind':            { bg: 'rgba(56, 189, 248, 0.8)',  border: '#38bdf8' },
            'Hydro':           { bg: 'rgba(59, 130, 246, 0.8)',  border: '#3b82f6' },
            'Nuclear':         { bg: 'rgba(192, 132, 252, 0.8)', border: '#c084fc' },
            'Gas CCGT':        { bg: 'rgba(251, 146, 60, 0.8)',  border: '#fb923c' },
            'Gas Peaker':      { bg: 'rgba(234, 88, 12, 0.7)',   border: '#ea580c' },
            'Gas Steam':       { bg: 'rgba(180, 83, 9, 0.6)',    border: '#b45309' },
            'Gas ICE':         { bg: 'rgba(146, 64, 14, 0.5)',   border: '#92400e' },
            'Geothermal':      { bg: 'rgba(52, 211, 153, 0.8)',  border: '#34d399' },
            'Biomass':         { bg: 'rgba(134, 239, 172, 0.7)', border: '#86efac' },
            'Battery Storage': { bg: 'rgba(148, 163, 184, 0.5)', border: '#94a3b8' },
            'Other Thermal':   { bg: 'rgba(107, 114, 128, 0.6)', border: '#6b7280' },
        };

        const STACK_ORDER = [
            'Nuclear', 'Geothermal', 'Biomass', 'Other Thermal',
            'Gas ICE', 'Gas Steam', 'Gas Peaker', 'Gas CCGT',
            'Hydro', 'Wind', 'Solar', 'Battery Storage'
        ];

        const HOUR_LABELS = Array.from({length: 24}, (_, i) => {
            const h = i % 12 || 12;
            const ampm = i < 12 ? 'a' : 'p';
            return `${h}${ampm}`;
        });

        // ─── Resource Toggling ───────────────────────────────────────────
        const hiddenResources = new Set();

        function computeReserves(demArr) {
            const reserves = new Array(24);
            for (let h = 0; h < 24; h++) {
                let reservePct;
                if (h >= 16 && h <= 21) reservePct = 0.084;
                else if ((h >= 6 && h <= 9) || (h >= 21 && h <= 23)) reservePct = 0.077;
                else reservePct = 0.07;
                reserves[h] = Math.max(3500, demArr[h] * reservePct);
            }
            return reserves;
        }

        function getVisibleTotalAvail(capMonth) {
            const totAvail = new Array(24).fill(0);
            if (!capMonth) return totAvail;
            for (const res of STACK_ORDER) {
                if (res === 'Battery Storage' || hiddenResources.has(res)) continue;
                const hourly = capMonth[res] || new Array(24).fill(0);
                for (let h = 0; h < 24; h++) totAvail[h] += hourly[h];
            }
            return totAvail;
        }

        // ─── Chart Setup ─────────────────────────────────────────────────
        const commonScaleOpts = {
            grid: { color: 'rgba(255,255,255,0.06)' },
            ticks: { color: '#888', font: { size: 11 } },
        };

        // Capacity chart
        const capCtx = document.getElementById('capacityChart').getContext('2d');
        const capDatasets = [];

        for (const res of STACK_ORDER) {
            if (res === 'Battery Storage') continue;
            const c = RESOURCE_COLORS[res];
            capDatasets.push({
                label: res,
                data: new Array(24).fill(0),
                backgroundColor: c.bg,
                borderColor: c.border,
                borderWidth: 1,
                stack: 'capacity',
                order: 2,
            });
        }

        capDatasets.push({
            label: 'Demand',
            data: new Array(24).fill(0),
            type: 'line',
            borderColor: '#ef4444',
            borderWidth: 3,
            pointRadius: 3,
            pointBackgroundColor: '#ef4444',
            fill: false,
            tension: 0.3,
            order: 1,
        });

        const capacityChart = new Chart(capCtx, {
            type: 'bar',
            data: { labels: HOUR_LABELS, datasets: capDatasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    legend: {
                        position: 'top',
                        onClick: (e, legendItem, legend) => {
                            const index = legendItem.datasetIndex;
                            const ci = legend.chart;
                            const meta = ci.getDatasetMeta(index);
                            meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;

                            const label = ci.data.datasets[index].label;
                            if (label !== 'Demand') {
                                if (meta.hidden) {
                                    hiddenResources.add(label);
                                } else {
                                    hiddenResources.delete(label);
                                }
                                recomputeScatterPoints();
                                recomputeStatisticalCharts();
                            }
                            updateCharts(parseInt(document.getElementById('dateSlider').value));
                        },
                        labels: {
                            color: '#ccc',
                            font: { size: 11 },
                            usePointStyle: true,
                            pointStyleWidth: 16,
                            padding: 12,
                        }
                    },
                    tooltip: {
                        backgroundColor: '#1a1d2e',
                        titleColor: '#fff',
                        bodyColor: '#ccc',
                        borderColor: '#3a3d4e',
                        borderWidth: 1,
                        callbacks: {
                            label: function(ctx) {
                                const val = ctx.parsed.y;
                                if (val === 0 && ctx.dataset.label !== 'Demand') return null;
                                return `${ctx.dataset.label}: ${val.toLocaleString()} MW`;
                            }
                        }
                    }
                },
                scales: {
                    x: { ...commonScaleOpts, stacked: true },
                    y: {
                        ...commonScaleOpts,
                        stacked: true,
                        title: { display: true, text: 'MW', color: '#888' },
                        min: 0,
                        max: maxCapacity,
                    }
                }
            }
        });

        // Price Breakdown Chart
        const priceCtx = document.getElementById('priceChart').getContext('2d');
        const priceChart = new Chart(priceCtx, {
            type: 'bar',
            data: {
                labels: HOUR_LABELS,
                datasets: [
                    {
                        label: 'MEC',
                        data: new Array(24).fill(0),
                        backgroundColor: 'rgba(59, 130, 246, 0.7)',
                        borderColor: '#3b82f6',
                        borderWidth: 1,
                        stack: 'p',
                        order: 2
                    },
                    {
                        label: 'MCC (Congestion)',
                        data: new Array(24).fill(0),
                        backgroundColor: 'rgba(239, 68, 68, 0.7)',
                        borderColor: '#ef4444',
                        borderWidth: 1,
                        stack: 'p',
                        order: 2
                    },
                    {
                        label: 'MCL (Losses)',
                        data: new Array(24).fill(0),
                        backgroundColor: 'rgba(249, 115, 22, 0.7)',
                        borderColor: '#f97316',
                        borderWidth: 1,
                        stack: 'p',
                        order: 2
                    },
                    {
                        label: 'GHG Adder',
                        data: new Array(24).fill(0),
                        backgroundColor: 'rgba(34, 197, 94, 0.7)',
                        borderColor: '#22c55e',
                        borderWidth: 1,
                        stack: 'p',
                        order: 2
                    },
                    {
                        label: 'Total LMP',
                        data: new Array(24).fill(0),
                        type: 'line',
                        borderColor: '#fff',
                        borderWidth: 2,
                        pointRadius: 2,
                        pointBackgroundColor: '#fff',
                        fill: false,
                        tension: 0.2,
                        order: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            color: '#ccc',
                            font: { size: 11 },
                            usePointStyle: true,
                            pointStyleWidth: 16,
                            padding: 12,
                        }
                    },
                    tooltip: {
                        backgroundColor: '#1a1d2e',
                        titleColor: '#fff',
                        bodyColor: '#ccc',
                        borderColor: '#3a3d4e',
                        borderWidth: 1,
                        callbacks: {
                            label: function(ctx) {
                                return `${ctx.dataset.label}: $${ctx.parsed.y.toFixed(2)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: { ...commonScaleOpts, stacked: true },
                    y: {
                        ...commonScaleOpts,
                        stacked: true,
                        title: { display: true, text: '$/MWh', color: '#888' }
                    }
                }
            }
        });

        // Headroom chart with reserves
        const headCtx = document.getElementById('headroomChart').getContext('2d');
        const headroomChart = new Chart(headCtx, {
            type: 'bar',
            data: {
                labels: HOUR_LABELS,
                datasets: [
                    {
                        label: 'Required Reserves',
                        data: new Array(24).fill(0),
                        backgroundColor: 'rgba(251, 191, 36, 0.6)',
                        borderColor: '#fbbf24',
                        borderWidth: 1,
                        stack: 'headroom',
                    },
                    {
                        label: 'Effective Headroom',
                        data: new Array(24).fill(0),
                        backgroundColor: new Array(24).fill('rgba(34, 197, 94, 0.6)'),
                        borderColor: new Array(24).fill('#22c55e'),
                        borderWidth: 1,
                        stack: 'headroom',
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            color: '#ccc',
                            font: { size: 11 },
                            usePointStyle: true,
                            pointStyleWidth: 16,
                            padding: 12,
                        }
                    },
                    tooltip: {
                        backgroundColor: '#1a1d2e',
                        titleColor: '#fff',
                        bodyColor: '#ccc',
                        borderColor: '#3a3d4e',
                        borderWidth: 1,
                        callbacks: {
                            label: function(ctx) {
                                const val = ctx.parsed.y;
                                if (ctx.datasetIndex === 0) {
                                    return `Required Reserves: ${val.toLocaleString()} MW`;
                                } else {
                                    const sign = val >= 0 ? '+' : '';
                                    return `Effective Headroom: ${sign}${val.toLocaleString()} MW`;
                                }
                            }
                        }
                    }
                },
                scales: {
                    x: { ...commonScaleOpts, stacked: true },
                    y: {
                        ...commonScaleOpts,
                        stacked: true,
                        title: { display: true, text: 'MW', color: '#888' },
                    }
                }
            }
        });

        // Average capacity chart
        const avgCtx = document.getElementById('avgCapacityChart').getContext('2d');
        const avgDatasets = [];
        for (const res of STACK_ORDER) {
            if (res === 'Battery Storage') continue;
            const c = RESOURCE_COLORS[res];
            avgDatasets.push({
                label: res,
                data: [0],
                backgroundColor: c.bg,
                borderColor: c.border,
                borderWidth: 1,
                barPercentage: 0.5,
                categoryPercentage: 0.5,
            });
        }

        const avgCapacityChart = new Chart(avgCtx, {
            type: 'bar',
            data: {
                labels: ['Avg Daily'],
                datasets: avgDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'left',
                        align: 'start',
                        labels: {
                            color: '#ccc',
                            font: { size: 11 },
                            usePointStyle: true,
                            pointStyle: 'circle',
                            padding: 10,
                            boxWidth: 8,
                            boxHeight: 8,
                        }
                    },
                    tooltip: {
                        backgroundColor: '#1a1d2e',
                        titleColor: '#fff',
                        bodyColor: '#ccc',
                        borderColor: '#3a3d4e',
                        borderWidth: 1,
                        callbacks: {
                            label: function(ctx) {
                                return `${ctx.dataset.label}: ${ctx.parsed.y.toLocaleString()} MW`;
                            }
                        }
                    }
                },
                layout: {
                    padding: { left: 10 }
                },
                scales: {
                    x: {
                        ...commonScaleOpts,
                        stacked: true,
                        display: false,
                        categoryPercentage: 0.4,
                        barPercentage: 0.6,
                    },
                    y: {
                        ...commonScaleOpts,
                        stacked: true,
                        title: { display: true, text: 'MW', color: '#888' },
                        min: 0,
                        max: maxCapacity,
                    },
                }
            }
        });

        // Scatter plot - computed dynamically to respect resource toggling
        const scatterCtx = document.getElementById('scatterChart').getContext('2d');
        let allScatterPoints = [];
        let scatterChartReady = false;

        function recomputeScatterPoints() {
            allScatterPoints = [];
            for (let i = 0; i <= 2191; i++) {
                const d = indexToDate(i);
                const ds = dateToStr(d);
                const y = String(d.getFullYear());
                const m = String(d.getMonth() + 1).padStart(2, '0');

                const capM = capacityData[y] && capacityData[y][m];
                const dem = demandData[ds];
                const hasDem = dem && dem.some(v => v !== null);

                if (!hasDem || !capM) {
                    allScatterPoints.push(null);
                    continue;
                }

                const demArr = dem.map(v => v || 0);
                const totAvail = getVisibleTotalAvail(capM);
                const reserves = computeReserves(demArr);

                const hr = totAvail.map((a, idx) => Math.round(a - demArr[idx]));
                const effHr = hr.map((h, idx) => Math.round(h - reserves[idx]));
                const minH = Math.min(...effHr);
                const minHHr = effHr.indexOf(minH);
                const availAtMin = totAvail[minHHr];

                const t = i / 2191;
                const r = Math.round(59 + t * (239 - 59));
                const g = Math.round(130 + t * (68 - 130));
                const b = Math.round(246 + t * (68 - 246));
                const color = `rgb(${r}, ${g}, ${b})`;

                allScatterPoints.push({
                    x: Math.round(availAtMin),
                    y: minH,
                    date: ds,
                    color: color
                });
            }

            // Update scatter axis bounds
            let sMinAvail = Infinity, sMaxAvail = 0, sMinHead = Infinity, sMaxHead = -Infinity;
            for (const pt of allScatterPoints) {
                if (!pt) continue;
                sMinAvail = Math.min(sMinAvail, pt.x);
                sMaxAvail = Math.max(sMaxAvail, pt.x);
                sMinHead = Math.min(sMinHead, pt.y);
                sMaxHead = Math.max(sMaxHead, pt.y);
            }
            if (scatterChartReady) {
                scatterChart.options.scales.x.min = Math.floor(sMinAvail / 5000) * 5000;
                scatterChart.options.scales.x.max = Math.ceil(sMaxAvail / 5000) * 5000;
                scatterChart.options.scales.y.min = Math.floor(sMinHead / 5000) * 5000;
                scatterChart.options.scales.y.max = Math.ceil(sMaxHead / 5000) * 5000;
            }
        }

        const scatterChart = new Chart(scatterCtx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Days',
                    data: [],
                    backgroundColor: [],
                    borderColor: [],
                    borderWidth: 0.5,
                    pointRadius: 2.5,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                onClick: (event, elements) => {
                    if (elements.length > 0) {
                        const index = elements[0].index;
                        const clickedPoint = scatterChart.data.datasets[0].data[index];
                        if (clickedPoint && clickedPoint.date) {
                            const targetIndex = dateStrToIndex(clickedPoint.date);
                            slider.value = targetIndex;
                            updateCharts(targetIndex);
                        }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: '#1a1d2e',
                        titleColor: '#fff',
                        bodyColor: '#ccc',
                        borderColor: '#3a3d4e',
                        borderWidth: 1,
                        callbacks: {
                            title: function(items) {
                                if (!items.length) return '';
                                const pt = items[0].raw;
                                return pt.date || '';
                            },
                            label: function(ctx) {
                                const pt = ctx.raw;
                                return [
                                    `Effective Margin: ${pt.y >= 0 ? '+' : ''}${pt.y.toLocaleString()} MW`,
                                    `Available: ${pt.x.toLocaleString()} MW`
                                ];
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        ...commonScaleOpts,
                        title: { display: true, text: 'Available Capacity at Min Effective Margin Hour (MW)', color: '#888', font: { size: 11 } },
                        min: minScatterAvail,
                        max: maxScatterAvail,
                    },
                    y: {
                        ...commonScaleOpts,
                        title: { display: true, text: 'Minimum Effective Margin (MW)', color: '#888', font: { size: 11 } },
                        min: minScatterHead,
                        max: maxScatterHead,
                    }
                }
            }
        });
        scatterChartReady = true;
        recomputeScatterPoints();

        // ─── Statistical Analysis (All Days) ─────────────────────────────
        // Percentile calculation function
        function percentile(arr, p) {
            const sorted = [...arr].sort((a, b) => a - b);
            const index = (p / 100) * (sorted.length - 1);
            const lower = Math.floor(index);
            const upper = Math.ceil(index);
            const weight = index - lower;
            return sorted[lower] * (1 - weight) + sorted[upper] * weight;
        }

        // Compute statistical data respecting hiddenResources
        function computeStatisticalData() {
            const effByHour = Array.from({length: 24}, () => []);
            const minEffArr = [];

            for (let i = 0; i <= 2191; i++) {
                const d = indexToDate(i);
                const ds = dateToStr(d);
                const y = String(d.getFullYear());
                const m = String(d.getMonth() + 1).padStart(2, '0');

                const capM = capacityData[y] && capacityData[y][m];
                const dem = demandData[ds];
                const hasDem = dem && dem.some(v => v !== null);
                if (!hasDem || !capM) continue;

                const demArr = dem.map(v => v || 0);
                const totAvail = getVisibleTotalAvail(capM);
                const reserves = computeReserves(demArr);
                const effHr = totAvail.map((a, idx) => a - demArr[idx] - reserves[idx]);

                for (let h = 0; h < 24; h++) effByHour[h].push(effHr[h]);
                minEffArr.push(Math.min(...effHr));
            }
            return { effByHour, minEffArr };
        }

        // Initial computation
        const initStats = computeStatisticalData();
        const p5 = [], p25 = [], p50 = [], p75 = [], p95 = [];
        for (let h = 0; h < 24; h++) {
            p5.push(Math.round(percentile(initStats.effByHour[h], 5)));
            p25.push(Math.round(percentile(initStats.effByHour[h], 25)));
            p50.push(Math.round(percentile(initStats.effByHour[h], 50)));
            p75.push(Math.round(percentile(initStats.effByHour[h], 75)));
            p95.push(Math.round(percentile(initStats.effByHour[h], 95)));
        }
        const confMinY = Math.floor(Math.min(...p5) / 5000) * 5000;
        const confMaxY = Math.ceil(Math.max(...p95) / 5000) * 5000;

        // Confidence Interval Chart
        const confCtx = document.getElementById('confidenceChart').getContext('2d');
        const confidenceChart = new Chart(confCtx, {
            type: 'line',
            data: {
                labels: HOUR_LABELS,
                datasets: [
                    {
                        label: '5th Percentile',
                        data: p5,
                        borderColor: 'rgba(127, 29, 29, 0.8)',
                        backgroundColor: 'rgba(127, 29, 29, 0.1)',
                        borderWidth: 2,
                        fill: '+1',
                        pointRadius: 0,
                        tension: 0.3,
                    },
                    {
                        label: '25th Percentile',
                        data: p25,
                        borderColor: 'rgba(251, 146, 60, 0.8)',
                        backgroundColor: 'rgba(251, 146, 60, 0.15)',
                        borderWidth: 2,
                        fill: '+1',
                        pointRadius: 0,
                        tension: 0.3,
                    },
                    {
                        label: 'Median (50th)',
                        data: p50,
                        borderColor: 'rgba(250, 204, 21, 0.9)',
                        backgroundColor: 'rgba(250, 204, 21, 0.2)',
                        borderWidth: 2.5,
                        fill: false,
                        pointRadius: 0,
                        tension: 0.3,
                    },
                    {
                        label: '75th Percentile',
                        data: p75,
                        borderColor: 'rgba(96, 165, 250, 0.8)',
                        backgroundColor: 'rgba(96, 165, 250, 0.15)',
                        borderWidth: 2,
                        fill: '-1',
                        pointRadius: 0,
                        tension: 0.3,
                    },
                    {
                        label: '95th Percentile',
                        data: p95,
                        borderColor: 'rgba(34, 197, 94, 0.8)',
                        backgroundColor: 'rgba(34, 197, 94, 0.15)',
                        borderWidth: 2,
                        fill: '-1',
                        pointRadius: 0,
                        tension: 0.3,
                    },
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            color: '#ccc',
                            font: { size: 11 },
                            usePointStyle: true,
                            pointStyleWidth: 16,
                            padding: 12,
                        }
                    },
                    tooltip: {
                        backgroundColor: '#1a1d2e',
                        titleColor: '#fff',
                        bodyColor: '#ccc',
                        borderColor: '#3a3d4e',
                        borderWidth: 1,
                        callbacks: {
                            label: function(ctx) {
                                return `${ctx.dataset.label}: ${ctx.parsed.y.toLocaleString()} MW`;
                            }
                        }
                    }
                },
                scales: {
                    x: { ...commonScaleOpts },
                    y: {
                        ...commonScaleOpts,
                        title: { display: true, text: 'Effective Headroom (MW)', color: '#888' },
                        min: confMinY,
                        max: confMaxY,
                    }
                }
            }
        });

        // Histogram of minimum effective headroom
        const histMin = Math.floor(Math.min(...initStats.minEffArr) / 1000) * 1000;
        const histMax = Math.ceil(Math.max(...initStats.minEffArr) / 1000) * 1000;
        const binSize = 2000; // 2 GW bins
        const numBins = Math.ceil((histMax - histMin) / binSize);
        const bins = Array(numBins).fill(0);
        const binLabels = [];

        for (let i = 0; i < numBins; i++) {
            const binStart = histMin + i * binSize;
            const binEnd = binStart + binSize;
            binLabels.push(`${(binStart/1000).toFixed(0)} to ${(binEnd/1000).toFixed(0)}`);
        }

        initStats.minEffArr.forEach(val => {
            const binIdx = Math.min(Math.floor((val - histMin) / binSize), numBins - 1);
            if (binIdx >= 0) bins[binIdx]++;
        });

        // Create color gradient for histogram bars based on headroom value
        const binColors = [];
        const binBorderColors = [];
        for (let i = 0; i < numBins; i++) {
            const binCenter = histMin + (i + 0.5) * binSize;
            // Color scale: red (<0) -> orange (0-10k) -> yellow (10k-20k) -> green (>20k)
            let color;
            if (binCenter < 0) {
                color = 'rgba(239, 68, 68, 0.7)'; // Red
            } else if (binCenter < 10000) {
                color = 'rgba(251, 146, 60, 0.7)'; // Orange
            } else if (binCenter < 20000) {
                color = 'rgba(250, 204, 21, 0.7)'; // Yellow
            } else {
                color = 'rgba(34, 197, 94, 0.7)'; // Green
            }
            binColors.push(color);

            // Border colors (slightly darker)
            if (binCenter < 0) {
                binBorderColors.push('#ef4444');
            } else if (binCenter < 10000) {
                binBorderColors.push('#fb923c');
            } else if (binCenter < 20000) {
                binBorderColors.push('#facc15');
            } else {
                binBorderColors.push('#22c55e');
            }
        }

        const histCtx = document.getElementById('histogramChart').getContext('2d');
        const histogramChart = new Chart(histCtx, {
            type: 'bar',
            data: {
                labels: binLabels,
                datasets: [{
                    label: 'Number of Days',
                    data: bins,
                    backgroundColor: binColors,
                    borderColor: binBorderColors,
                    borderWidth: 1,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: '#1a1d2e',
                        titleColor: '#fff',
                        bodyColor: '#ccc',
                        borderColor: '#3a3d4e',
                        borderWidth: 1,
                        callbacks: {
                            title: function(items) {
                                return `${items[0].label} GW`;
                            },
                            label: function(ctx) {
                                return `Days: ${ctx.parsed.y}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        ...commonScaleOpts,
                        title: { display: true, text: 'Minimum Effective Headroom (GW)', color: '#888', font: { size: 11 } },
                    },
                    y: {
                        ...commonScaleOpts,
                        title: { display: true, text: 'Number of Days', color: '#888' },
                        ticks: {
                            ...commonScaleOpts.ticks,
                            precision: 0,
                        }
                    }
                }
            }
        });

        // ─── Recompute Statistical Charts on Resource Toggle ──────────────
        function recomputeStatisticalCharts() {
            const stats = computeStatisticalData();

            // Update confidence chart
            const np5 = [], np25 = [], np50 = [], np75 = [], np95 = [];
            for (let h = 0; h < 24; h++) {
                if (stats.effByHour[h].length === 0) {
                    np5.push(0); np25.push(0); np50.push(0); np75.push(0); np95.push(0);
                    continue;
                }
                np5.push(Math.round(percentile(stats.effByHour[h], 5)));
                np25.push(Math.round(percentile(stats.effByHour[h], 25)));
                np50.push(Math.round(percentile(stats.effByHour[h], 50)));
                np75.push(Math.round(percentile(stats.effByHour[h], 75)));
                np95.push(Math.round(percentile(stats.effByHour[h], 95)));
            }
            confidenceChart.data.datasets[0].data = np5;
            confidenceChart.data.datasets[1].data = np25;
            confidenceChart.data.datasets[2].data = np50;
            confidenceChart.data.datasets[3].data = np75;
            confidenceChart.data.datasets[4].data = np95;
            confidenceChart.options.scales.y.min = Math.floor(Math.min(...np5) / 5000) * 5000;
            confidenceChart.options.scales.y.max = Math.ceil(Math.max(...np95) / 5000) * 5000;
            confidenceChart.update();

            // Update histogram
            if (stats.minEffArr.length === 0) return;
            const hMin = Math.floor(Math.min(...stats.minEffArr) / 1000) * 1000;
            const hMax = Math.ceil(Math.max(...stats.minEffArr) / 1000) * 1000;
            const hBinSize = 2000;
            const hNumBins = Math.ceil((hMax - hMin) / hBinSize);
            const hBins = Array(hNumBins).fill(0);
            const hLabels = [];
            const hColors = [];
            const hBorders = [];

            for (let i = 0; i < hNumBins; i++) {
                const binStart = hMin + i * hBinSize;
                const binEnd = binStart + hBinSize;
                hLabels.push(`${(binStart/1000).toFixed(0)} to ${(binEnd/1000).toFixed(0)}`);
                const binCenter = hMin + (i + 0.5) * hBinSize;
                if (binCenter < 0) {
                    hColors.push('rgba(239, 68, 68, 0.7)'); hBorders.push('#ef4444');
                } else if (binCenter < 10000) {
                    hColors.push('rgba(251, 146, 60, 0.7)'); hBorders.push('#fb923c');
                } else if (binCenter < 20000) {
                    hColors.push('rgba(250, 204, 21, 0.7)'); hBorders.push('#facc15');
                } else {
                    hColors.push('rgba(34, 197, 94, 0.7)'); hBorders.push('#22c55e');
                }
            }
            stats.minEffArr.forEach(val => {
                const binIdx = Math.min(Math.floor((val - hMin) / hBinSize), hNumBins - 1);
                if (binIdx >= 0) hBins[binIdx]++;
            });
            histogramChart.data.labels = hLabels;
            histogramChart.data.datasets[0].data = hBins;
            histogramChart.data.datasets[0].backgroundColor = hColors;
            histogramChart.data.datasets[0].borderColor = hBorders;
            histogramChart.update();
        }

        // ─── Update Function ─────────────────────────────────────────────
        let isFirstUpdate = true;
        function updateCharts(sliderIndex) {
            const date = indexToDate(sliderIndex);
            const dateStr = dateToStr(date);
            const year = String(date.getFullYear());
            const month = String(date.getMonth() + 1).padStart(2, '0');

            // Update date display and date picker
            document.getElementById('currentDate').textContent = dateStr;
            document.getElementById('dateInfo').textContent =
                `${DAYS[date.getDay()]} \u00b7 ${MONTHS[date.getMonth()]} ${year}`;
            document.getElementById('datePicker').value = dateStr;

            const capMonth = capacityData[year] && capacityData[year][month];
            const demand = demandData[dateStr];

            const hasDemand = demand && demand.some(v => v !== null);
            document.getElementById('noDataMsg').style.display = hasDemand ? 'none' : 'flex';

            const demandArr = hasDemand ? demand.map(v => v || 0) : new Array(24).fill(0);
            let totalAvail = new Array(24).fill(0);

            // Update capacity chart datasets
            let dsIdx = 0;
            for (const res of STACK_ORDER) {
                if (res === 'Battery Storage') continue;
                const hourly = (capMonth && capMonth[res]) || new Array(24).fill(0);
                capacityChart.data.datasets[dsIdx].data = hourly;
                if (!hiddenResources.has(res)) {
                    for (let h = 0; h < 24; h++) totalAvail[h] += hourly[h];
                }
                dsIdx++;
            }

            capacityChart.data.datasets[dsIdx].data = demandArr;
            capacityChart.update(isFirstUpdate ? 'resize' : 'none');

            // Update Price Chart
            const pData = priceData[dateStr];
            const hasPrice = pData && Object.keys(pData).length > 0;
            document.getElementById('noPriceDataMsg').style.display = hasPrice ? 'none' : 'flex';

            if (hasPrice) {
                const mec = [], mcc = [], mcl = [], ghg = [], lmp = [];
                for (let h = 1; h <= 24; h++) {
                    const hData = pData[String(h)] || {};
                    mec.push(hData.MEC || 0);
                    mcc.push(hData.MCC || 0);
                    mcl.push(hData.Loss || 0);
                    ghg.push(hData.GHG || 0);
                    lmp.push(hData.LMP || 0);
                }
                priceChart.data.datasets[0].data = mec;
                priceChart.data.datasets[1].data = mcc;
                priceChart.data.datasets[2].data = mcl;
                priceChart.data.datasets[3].data = ghg;
                priceChart.data.datasets[4].data = lmp;
            } else {
                priceChart.data.datasets.forEach(ds => ds.data = new Array(24).fill(0));
            }
            priceChart.update(isFirstUpdate ? 'resize' : 'none');

            // Calculate reserves by hour (time-of-day weighted)
            const reserves = computeReserves(demandArr).map(v => Math.round(v));

            // Update headroom chart with stacked reserves + effective headroom
            const headroom = totalAvail.map((a, i) => Math.round(a - demandArr[i]));
            const effectiveHeadroom = headroom.map((h, i) => h - reserves[i]);

            headroomChart.data.datasets[0].data = reserves;
            headroomChart.data.datasets[1].data = effectiveHeadroom;
            headroomChart.data.datasets[1].backgroundColor = effectiveHeadroom.map(v =>
                v >= 0 ? 'rgba(34, 197, 94, 0.6)' : 'rgba(239, 68, 68, 0.6)');
            headroomChart.data.datasets[1].borderColor = effectiveHeadroom.map(v =>
                v >= 0 ? '#22c55e' : '#ef4444');
            headroomChart.update(isFirstUpdate ? 'resize' : 'none');

            // Update average capacity chart
            dsIdx = 0;
            for (const res of STACK_ORDER) {
                if (res === 'Battery Storage') continue;
                const hourly = (capMonth && capMonth[res]) || new Array(24).fill(0);
                const avg = hiddenResources.has(res) ? 0 : hourly.reduce((s, v) => s + v, 0) / 24;
                avgCapacityChart.data.datasets[dsIdx].data = [Math.round(avg)];
                dsIdx++;
            }
            avgCapacityChart.update(isFirstUpdate ? 'resize' : 'none');

            // Update stats (use effective headroom after reserves)
            const peakDemand = Math.max(...demandArr);
            const peakDemandHr = demandArr.indexOf(peakDemand);
            const peakAvail = Math.max(...totalAvail);
            const peakAvailHr = totalAvail.indexOf(peakAvail);
            const minEffHead = Math.min(...effectiveHeadroom);
            const minEffHeadHr = effectiveHeadroom.indexOf(minEffHead);
            const avgUtil = totalAvail.reduce((s, v, i) => s + (v > 0 ? demandArr[i] / v : 0), 0) / 24 * 100;

            document.getElementById('statPeakDemand').innerHTML =
                `${peakDemand.toLocaleString()}<span class="unit">MW</span>`;
            document.getElementById('statPeakDemandHour').textContent =
                hasDemand ? `Hour ${peakDemandHr} (${HOUR_LABELS[peakDemandHr]})` : '--';

            document.getElementById('statPeakAvail').innerHTML =
                `${Math.round(peakAvail).toLocaleString()}<span class="unit">MW</span>`;
            document.getElementById('statPeakAvailHour').textContent =
                `Hour ${peakAvailHr} (${HOUR_LABELS[peakAvailHr]})`;

            document.getElementById('statMinHeadroom').innerHTML =
                `${minEffHead >= 0 ? '+' : ''}${minEffHead.toLocaleString()}<span class="unit">MW</span>`;
            document.getElementById('statMinHeadroomHour').textContent =
                hasDemand ? `Hour ${minEffHeadHr} (${HOUR_LABELS[minEffHeadHr]})` : '--';
            document.getElementById('statMinHeadroom').style.color =
                minEffHead >= 0 ? '#22c55e' : '#ef4444';

            document.getElementById('statUtilization').innerHTML =
                hasDemand ? `${avgUtil.toFixed(1)}<span class="unit">%</span>` : `--<span class="unit">%</span>`;

            const hydro = HYDRO_INFO[year] || { type: '--', cls: '', detail: '' };
            document.getElementById('statHydroYear').innerHTML =
                `<span class="hydro-badge ${hydro.cls}">${hydro.type}</span>`;
            document.getElementById('statHydroSub').textContent = hydro.detail;

            // Update scatter plot (bidirectional) - show points from 0 to sliderIndex
            const visiblePoints = allScatterPoints.slice(0, sliderIndex + 1).filter(p => p !== null);
            scatterChart.data.datasets[0].data = visiblePoints;
            scatterChart.data.datasets[0].backgroundColor = visiblePoints.map(p => p.color);
            scatterChart.data.datasets[0].borderColor = visiblePoints.map(p => p.color);
            scatterChart.update(isFirstUpdate ? 'resize' : 'none');

            // After first update, use 'none' mode for better performance
            if (isFirstUpdate) isFirstUpdate = false;
        }

        // ─── Slider & Controls ───────────────────────────────────────────
        const slider = document.getElementById('dateSlider');
        slider.addEventListener('input', () => updateCharts(parseInt(slider.value)));

        document.getElementById('datePicker').addEventListener('change', (e) => {
            const index = dateStrToIndex(e.target.value);
            slider.value = index;
            updateCharts(index);
        });

        document.getElementById('btnPrev').addEventListener('click', () => {
            slider.value = Math.max(0, parseInt(slider.value) - 1);
            updateCharts(parseInt(slider.value));
        });

        document.getElementById('btnNext').addEventListener('click', () => {
            slider.value = Math.min(2191, parseInt(slider.value) + 1);
            updateCharts(parseInt(slider.value));
        });

        document.getElementById('btnReset').addEventListener('click', () => {
            slider.value = 0;
            updateCharts(0);
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                slider.value = Math.max(0, parseInt(slider.value) - 1);
                updateCharts(parseInt(slider.value));
            } else if (e.key === 'ArrowRight') {
                slider.value = Math.min(2191, parseInt(slider.value) + 1);
                updateCharts(parseInt(slider.value));
            } else if (e.key === ' ') {
                e.preventDefault();
                togglePlay();
            }
        });

        // Playback
        let playInterval = null;
        let playSpeed = 200;

        function togglePlay() {
            const btn = document.getElementById('btnPlay');
            if (playInterval) {
                clearInterval(playInterval);
                playInterval = null;
                btn.innerHTML = '&#9654; Play';
                btn.classList.remove('active');
            } else {
                btn.innerHTML = '&#9646;&#9646; Pause';
                btn.classList.add('active');
                playInterval = setInterval(() => {
                    let val = parseInt(slider.value) + 1;
                    if (val > 2191) val = 0;
                    slider.value = val;
                    updateCharts(val);
                }, playSpeed);
            }
        }

        document.getElementById('btnPlay').addEventListener('click', togglePlay);

        document.querySelectorAll('.speed-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                playSpeed = parseInt(btn.dataset.speed);
                if (playInterval) {
                    clearInterval(playInterval);
                    playInterval = setInterval(() => {
                        let val = parseInt(slider.value) + 1;
                        if (val > 2191) val = 0;
                        slider.value = val;
                        updateCharts(val);
                    }, playSpeed);
                }
            });
        });

        // Initial render - use setTimeout to ensure charts are fully initialized
        setTimeout(() => updateCharts(0), 100);
    })();
    </script>
</body>
</html>
