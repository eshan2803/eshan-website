<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>California Grid Utilization Explorer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f1117;
            color: #e0e0e0;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, #1a1d2e 0%, #0f1117 100%);
            border-bottom: 1px solid #2a2d3e;
            padding: 20px 30px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header h1 {
            font-size: 22px;
            font-weight: 600;
            color: #fff;
        }

        .header .subtitle {
            font-size: 13px;
            color: #888;
            margin-top: 2px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .header-links a {
            color: #60a5fa;
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
            padding: 6px 14px;
            border: 1px solid #2a2d3e;
            border-radius: 6px;
            transition: background 0.15s, border-color 0.15s;
        }

        .header-links a:hover {
            background: #1a1d2e;
            border-color: #60a5fa;
        }

        .date-display {
            text-align: right;
        }

        .date-display .current-date {
            font-size: 28px;
            font-weight: 700;
            color: #60a5fa;
            font-variant-numeric: tabular-nums;
        }

        .date-display .date-info {
            font-size: 12px;
            color: #888;
            margin-top: 2px;
        }

        .loading-overlay {
            position: fixed;
            inset: 0;
            background: #0f1117;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.3s;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-overlay .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #2a2d3e;
            border-top-color: #60a5fa;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .loading-overlay p {
            margin-top: 16px;
            color: #888;
            font-size: 14px;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .main {
            padding: 20px 30px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .stats-row {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #1a1d2e;
            border: 1px solid #2a2d3e;
            border-radius: 8px;
            padding: 14px 16px;
        }

        .stat-card .label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #888;
            margin-bottom: 4px;
        }

        .stat-card .value {
            font-size: 22px;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }

        .stat-card .unit {
            font-size: 12px;
            font-weight: 400;
            color: #888;
            margin-left: 2px;
        }

        .stat-card .sub {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
        }

        /* ─── Article Sections ─── */
        .article-section {
            margin: 48px 0;
            padding: 0;
        }

        .section-title {
            font-size: 24px;
            font-weight: 700;
            color: #e8e8e8;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #2a2d3e;
        }

        .article-text {
            font-size: 14px;
            line-height: 1.8;
            color: #b8b8b8;
            margin-bottom: 20px;
        }

        .article-text p {
            margin-bottom: 16px;
        }

        .article-text strong {
            color: #e0e0e0;
            font-weight: 600;
        }

        .article-text em {
            color: #60a5fa;
            font-style: normal;
        }

        .article-abstract {
            background: linear-gradient(135deg, rgba(96, 165, 250, 0.08) 0%, rgba(96, 165, 250, 0.02) 100%);
            border-left: 3px solid #60a5fa;
            padding: 20px 24px;
            margin: 24px 0 40px;
            border-radius: 6px;
        }

        .article-abstract p {
            font-size: 15px;
            line-height: 1.7;
            color: #d0d0d0;
            margin: 0;
        }

        .article-insight {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.08) 0%, rgba(34, 197, 94, 0.02) 100%);
            border-left: 3px solid #22c55e;
            padding: 16px 20px;
            margin: 20px 0;
            border-radius: 6px;
        }

        .article-insight p {
            font-size: 13px;
            line-height: 1.6;
            color: #c0c0c0;
            margin: 0;
        }

        .article-insight strong {
            color: #22c55e;
        }

        .chart-container {
            background: #1a1d2e;
            border: 1px solid #2a2d3e;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 16px;
            position: relative;
        }

        .chart-container h3 {
            font-size: 14px;
            font-weight: 600;
            color: #ccc;
            margin-bottom: 6px;
        }

        .chart-note {
            font-size: 11px;
            color: #666;
            margin-bottom: 10px;
            line-height: 1.4;
        }

        .chart-wrapper {
            position: relative;
            height: 320px;
        }

        .chart-wrapper.short {
            height: 200px;
        }

        .chart-wrapper.medium {
            height: 260px;
        }

        .chart-wrapper.tall {
            height: 400px;
        }

        .chart-wrapper.square {
            height: 700px;
        }

        .analysis-row {
            display: grid;
            grid-template-columns: 500px 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }

        .statistical-charts-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }

        .slider-section {
            background: #1a1d2e;
            border: 1px solid #2a2d3e;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .slider-row label {
            font-size: 13px;
            color: #888;
            white-space: nowrap;
        }

        .slider-row input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #2a2d3e;
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #60a5fa;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(96, 165, 250, 0.4);
        }

        .slider-row input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #60a5fa;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(96, 165, 250, 0.4);
        }

        .playback-controls {
            display: flex;
            gap: 6px;
            margin-top: 14px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .playback-controls button {
            background: linear-gradient(135deg, #2a2d3e 0%, #323650 100%);
            border: 1px solid #3f4460;
            color: #c8cad8;
            padding: 7px 16px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            letter-spacing: 0.02em;
        }

        .playback-controls button:hover {
            background: linear-gradient(135deg, #363a52 0%, #434868 100%);
            border-color: #60a5fa;
            color: #fff;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(96, 165, 250, 0.15);
        }

        .playback-controls button:active {
            transform: translateY(0);
            box-shadow: none;
        }

        .playback-controls button.active {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border-color: #60a5fa;
            color: #fff;
            box-shadow: 0 2px 10px rgba(59, 130, 246, 0.3);
        }

        .playback-controls .btn-icon {
            font-size: 11px;
        }

        .playback-controls .controls-divider {
            width: 1px;
            height: 24px;
            background: #3a3d4e;
            margin: 0 6px;
        }

        .playback-controls .speed-label {
            font-size: 11px;
            color: #888;
            margin-left: 4px;
        }

        .playback-controls .speed-btn {
            padding: 5px 10px;
            font-size: 11px;
            min-width: 36px;
        }

        .playback-controls .date-picker-inline {
            background: linear-gradient(135deg, #2a2d3e 0%, #323650 100%);
            border: 1px solid #3f4460;
            color: #c8cad8;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .playback-controls .date-picker-inline:hover {
            border-color: #60a5fa;
        }

        .year-ticks {
            display: flex;
            justify-content: space-between;
            padding: 4px 0 0;
            font-size: 11px;
            color: #666;
        }

        .hydro-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .hydro-wet { background: #164e63; color: #67e8f9; }
        .hydro-above { background: #1e3a5f; color: #93c5fd; }
        .hydro-below { background: #422006; color: #fbbf24; }
        .hydro-dry { background: #451a03; color: #fb923c; }
        .hydro-critical { background: #450a0a; color: #fca5a5; }

        .no-data-msg {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #666;
        }

        .hour-colorbar {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            margin: 6px 0 2px;
            padding: 0 4px;
        }

        .hour-colorbar-label {
            font-size: 11px;
            color: #888;
            white-space: nowrap;
            margin-top: 1px;
        }

        .hour-colorbar-inner {
            display: flex;
            flex-direction: column;
            max-width: 600px;
            min-width: 300px;
            flex: 1;
        }

        .hour-colorbar-bar {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: linear-gradient(to right, #3b82f6, #22d3ee 25%, #facc15 50%, #ef4444 75%, #3b82f6 100%);
        }

        .hour-colorbar-ticks {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #666;
            margin-top: 2px;
        }

        .lmp-scatter-legends {
            display: flex;
            align-items: flex-start;
            gap: 24px;
            flex-wrap: wrap;
        }

        .gas-size-legend {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-top: 1px;
        }

        .gas-size-label {
            font-size: 11px;
            color: #888;
            white-space: nowrap;
            margin-right: 4px;
        }

        .gas-dot {
            display: inline-block;
            border-radius: 50%;
            background: #94a3b8;
            vertical-align: middle;
        }

        .gas-val {
            font-size: 10px;
            color: #666;
            margin-right: 6px;
        }

        /* ─── Data Center Analysis Section ─── */
        .dc-section-header {
            margin: 40px 0 20px;
            padding: 20px 24px;
            background: linear-gradient(135deg, #1a1d2e 0%, #1e2740 100%);
            border: 1px solid #2d3555;
            border-radius: 12px;
        }

        .dc-section-header h2 {
            color: #e0e0e0;
            font-size: 20px;
            font-weight: 600;
            margin: 0 0 6px;
        }

        .dc-section-header p {
            color: #888;
            font-size: 13px;
            margin: 0;
            line-height: 1.5;
        }

        .dc-controls {
            display: flex;
            align-items: center;
            gap: 24px;
            flex-wrap: wrap;
            padding: 16px 20px;
            background: #1a1d2e;
            border: 1px solid #2a2d3e;
            border-radius: 10px;
            margin-bottom: 16px;
            transition: all 0.3s ease;
        }

        .dc-controls.sticky {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            z-index: 95;
            width: calc(100% - 60px);
            max-width: 1340px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            animation: slideDown 0.3s ease;
        }

        .custom-editor-container.sticky {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            z-index: 95;
            width: calc(100% - 60px);
            max-width: 1340px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            margin-bottom: 0;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .dc-slider-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 200px;
            flex: 1;
            max-width: 320px;
        }

        .dc-slider-label {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            font-size: 12px;
            color: #999;
        }

        .dc-slider-label .dc-val {
            font-weight: 600;
            color: #60a5fa;
            font-size: 13px;
        }

        .dc-slider-group input[type="range"] {
            width: 100%;
            accent-color: #60a5fa;
        }

        .dc-presets {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .dc-presets span {
            font-size: 11px;
            color: #888;
            margin-right: 4px;
        }

        .dc-preset-btn {
            background: linear-gradient(135deg, #2a2d3e 0%, #323650 100%);
            border: 1px solid #3f4460;
            color: #c8cad8;
            padding: 6px 14px;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .dc-preset-btn:hover {
            border-color: #60a5fa;
            color: #fff;
        }

        .dc-preset-btn.active {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border-color: #60a5fa;
            color: #fff;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.25);
        }

        .dc-scorecard-row {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            margin-bottom: 16px;
        }

        .dc-score-card {
            background: #1a1d2e;
            border: 1px solid #2a2d3e;
            border-radius: 10px;
            padding: 14px 16px;
            text-align: center;
        }

        .dc-score-card.baseline {
            border-color: #3a3d4e;
        }

        .dc-score-card.flat {
            border-color: #60a5fa;
        }

        .dc-score-card.camel {
            border-color: #22c55e;
        }

        .dc-score-card.night {
            border-color: #ef4444;
        }

        .dc-score-card.optimized {
            border-color: #a855f7;
        }

        .dc-score-card .card-title {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 10px;
        }

        .dc-score-card .card-metric {
            margin-bottom: 8px;
        }

        .dc-score-card .card-metric .metric-val {
            font-size: 20px;
            font-weight: 700;
            color: #e0e0e0;
        }

        .dc-score-card .card-metric .metric-label {
            font-size: 10px;
            color: #666;
            display: block;
            margin-top: 2px;
        }

        .dc-score-card .card-metric .metric-delta {
            font-size: 12px;
            font-weight: 600;
            margin-left: 6px;
        }

        .dc-score-card .metric-delta.positive { color: #22c55e; }
        .dc-score-card .metric-delta.negative { color: #ef4444; }

        .dc-cost-summary {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 12px;
        }

        .dc-cost-card {
            background: #1a1d2e;
            border: 1px solid #2a2d3e;
            border-radius: 10px;
            padding: 14px 16px;
            text-align: center;
        }

        .dc-cost-card .cost-title {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 8px;
        }

        .dc-cost-card .cost-main {
            font-size: 22px;
            font-weight: 700;
            color: #e0e0e0;
        }

        .dc-cost-card .cost-sub {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }

        .dc-cost-card .cost-savings {
            font-size: 14px;
            font-weight: 600;
            color: #22c55e;
            margin-top: 6px;
        }

        /* ─── Phase 3: Custom Profile Editor ─── */
        .custom-editor-container {
            background: #141620;
            border: 1px solid #2a2d3e;
            border-radius: 10px;
            padding: 14px 16px;
            margin-bottom: 16px;
        }

        .custom-editor-toolbar {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .custom-editor-toolbar .custom-stats {
            font-size: 12px;
            color: #888;
            font-variant-numeric: tabular-nums;
        }

        .custom-editor-canvas {
            display: block;
            cursor: crosshair;
        }

        .dc-score-card.custom {
            border-color: #a855f7;
        }

        /* ─── Phase 3: Emissions ─── */
        .emissions-stats-row {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            margin-top: 12px;
        }

        .emissions-card {
            background: #141620;
            border: 1px solid #2a2d3e;
            border-radius: 10px;
            padding: 12px 16px;
            text-align: center;
        }

        .emissions-card.highlight {
            border-color: #22c55e;
            background: linear-gradient(135deg, #141620 0%, #0f2018 100%);
        }

        .emissions-card .em-title {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 6px;
        }

        .emissions-card .em-value {
            font-size: 18px;
            font-weight: 700;
            color: #e0e0e0;
        }

        .emissions-card .em-sub {
            font-size: 11px;
            color: #666;
            margin-top: 3px;
        }

        /* ─── Optimized Profile ─── */
        .optimized-trigger-container {
            text-align: center;
            padding: 40px 20px;
        }

        .optimized-trigger-btn {
            background: linear-gradient(135deg, #a855f7 0%, #8b5cf6 100%);
            border: none;
            color: #fff;
            padding: 16px 32px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 14px rgba(168, 85, 247, 0.4);
        }

        .optimized-trigger-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.6);
        }

        .optimized-trigger-btn .opt-icon {
            font-size: 20px;
        }

        .optimized-trigger-btn .opt-arrow {
            font-size: 18px;
            transition: transform 0.3s ease;
        }

        .optimized-trigger-btn:hover .opt-arrow {
            transform: translateX(4px);
        }

        .optimized-form-container {
            padding: 20px 0;
        }

        .optimized-form-container h3 {
            margin-bottom: 8px;
        }

        .optimized-form {
            background: #141620;
            border: 1px solid #2a2d3e;
            border-radius: 12px;
            padding: 24px;
            margin: 20px auto;
            max-width: 500px;
        }

        .optimized-form-group {
            margin-bottom: 20px;
        }

        .optimized-form-group label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #c0c0c0;
            margin-bottom: 8px;
        }

        .optimized-form-group input[type="number"] {
            width: 100%;
            background: #0e1019;
            border: 1px solid #2a2d3e;
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 16px;
            color: #e0e0e0;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .optimized-form-group input[type="number"]:focus {
            outline: none;
            border-color: #a855f7;
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.1);
        }

        .form-helper {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }

        .optimized-calculate-btn {
            width: 100%;
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            border: none;
            color: #fff;
            padding: 14px 24px;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .optimized-calculate-btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
        }

        .optimized-calculate-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .optimized-loading-msg {
            text-align: center;
            padding: 60px 20px;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid #2a2d3e;
            border-top-color: #a855f7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 14px;
            color: #888;
        }

        .optimized-results-container {
            margin-top: 20px;
        }

        .optimized-stats-container {
            margin-top: 16px;
        }

        /* ─── Phase 2: Stress Day Heatmap ─── */
        .stress-heatmap-wrapper {
            position: relative;
            overflow-x: auto;
        }

        .stress-heatmap-canvas {
            display: block;
            margin: 0 auto;
        }

        .stress-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
        }

        .stress-tab {
            background: linear-gradient(135deg, #2a2d3e 0%, #323650 100%);
            border: 1px solid #3f4460;
            color: #c8cad8;
            padding: 6px 14px;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .stress-tab:hover {
            border-color: #60a5fa;
            color: #fff;
        }

        .stress-tab.active {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border-color: #60a5fa;
            color: #fff;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.25);
        }

        .stress-summary-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 12px;
        }

        .stress-summary-card {
            background: #141620;
            border: 1px solid #2a2d3e;
            border-radius: 10px;
            padding: 12px 16px;
            text-align: center;
        }

        .stress-summary-card .ss-title {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 6px;
        }

        .stress-summary-card .ss-value {
            font-size: 20px;
            font-weight: 700;
            color: #e0e0e0;
        }

        .stress-summary-card .ss-sub {
            font-size: 11px;
            color: #666;
            margin-top: 3px;
        }

        /* ─── Phase 2: Curtailment Absorption ─── */
        .curtail-stats-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-top: 12px;
        }

        .curtail-card {
            background: #141620;
            border: 1px solid #2a2d3e;
            border-radius: 10px;
            padding: 14px 16px;
            text-align: center;
        }

        .curtail-card.highlight {
            border-color: #22c55e;
            background: linear-gradient(135deg, #141620 0%, #0f2018 100%);
        }

        .curtail-card .ct-title {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 6px;
        }

        .curtail-card .ct-value {
            font-size: 20px;
            font-weight: 700;
            color: #e0e0e0;
        }

        .curtail-card .ct-sub {
            font-size: 11px;
            color: #666;
            margin-top: 3px;
        }

        @media (max-width: 900px) {
            .stats-row { grid-template-columns: repeat(3, 1fr); }
            .header { flex-direction: column; align-items: flex-start; gap: 10px; }
            .date-display { text-align: left; }
            .main { padding: 12px; }
            .analysis-row { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <p>Loading demand & capacity data...</p>
    </div>

    <div class="header">
        <div>
            <h1>California Grid Utilization Explorer</h1>
            <div class="subtitle">CAISO actual demand vs available generation capacity, 2020 &ndash; 2025</div>
        </div>
        <div class="header-right">
            <div class="header-links">
                <a href="gridutilization_documentation.html">Documentation</a>
            </div>
            <div class="date-display">
                <div class="current-date" id="currentDate">2020-01-01</div>
                <div class="date-info" id="dateInfo">Wednesday &middot; January 2020</div>
            </div>
        </div>
    </div>

    <div class="main">
        <!-- Article Title & Abstract -->
        <div class="article-section" style="margin-top: 20px;">
            <h1 style="font-size: 32px; font-weight: 800; color: #ffffff; margin-bottom: 12px; line-height: 1.3;">
                Grid Headroom and Data Center Load Flexibility:<br>A California Case Study (2020–2025)
            </h1>
            <div class="article-abstract">
                <p><strong>Abstract:</strong> California's electricity grid faces increasing stress from high renewable penetration, creating periods of both surplus (solar hours) and scarcity (evening peaks). This study analyzes 2,192 days of CAISO grid data to quantify <em>effective headroom</em> — the margin between available generation capacity and demand after accounting for required operating reserves. We demonstrate that flexible data center load profiles that follow solar generation patterns ("camel profiles") improve grid utilization by 3-5%, reduce electricity costs by 15-35%, absorb renewable surplus that would otherwise be curtailed, and lower marginal CO₂ emissions by concentrating consumption during low-carbon hours. Using an empirical LMP-headroom model derived from six years of market data, we show that optimized load allocation can achieve near-theoretical cost minimums while maintaining grid reliability. These findings improve upon the proposed policy frameworks, such as Virginia's grid utilization factor, that incentivize flexible loads to improve system efficiency before building new infrastructure. A data center as an asset to the grid might be little farfetched (there is a reason they're called Large "Load"). The best we can aim for is for these large loads to not stress the grid. </p>
            </div>
        </div>

        <!-- Section 1: Introduction -->
        <div class="article-section">
            <h2 class="section-title">1. Introduction: The Grid Reliability Challenge</h2>
            <div class="article-text">
                <p>The State of Virginia enacted a first‑in‑the‑nation requirement for its major utilities — Dominion Energy (Phase II) and Appalachian Power (Phase I) — to measure, report, and improve electric grid utilization. While the requirement is a step forward, I believe we can do better, especially in States rich in variable renewable resources. The requirement defines utilization as the ratio of Effective Load and Rated Capacity. In an ideal scenario, new large loads will improve this ratio, resulting in a flat load across the day. In my opinion, what we need to base our grid utilization factor on isnt the rated capacity, but Hourly Available Capacity. For states like California seeing >20 GW utility solar generation frequently, the denominator changes hourly, and so should the grid-utilization. A flexible load trying to maximize the grid-utilization factor for Virginia may make things worse for the California. My solution to this problem was to come up with the Available Capacity (rather than Rated Capacity). We can glean into historical data from 2020 to 2025 to understand how large loads need to manage their operations to maximize grid utilization, while minimizing the grid-stress. </p>

                <p>This analysis examines <strong>effective headroom</strong>, defined as available generation capacity minus demand minus required reserves, as the fundamental metric of grid stress. Unlike simple supply-demand comparisons, effective headroom accounts for the operational margins that CAISO must maintain to handle equipment failures, forecast errors, and sudden demand spikes. When effective headroom falls below 3,500 MW—CAISO's minimum spinning reserve requirement—the grid enters a stressed state requiring emergency protocols.</p>

                <p><strong>Data Sources:</strong> Our analysis integrates three primary datasets spanning January 1, 2020 through December 31, 2025 (2,192 days): (1) <em>CAISO day-ahead demand forecasts</em> providing hourly load projections with 24-hour granularity; (2) <em>Available generation capacity by resource type</em> derived from CAISO resource adequacy filings, representing theoretical maximum output from nuclear, thermal, hydro, wind, solar, and battery resources; (3) <em>Locational Marginal Prices (LMP)</em> from CAISO's real-time market, load-weighted across three utility zones (PG&E 43.5%, SCE 43.5%, SDG&E 13%) to create a system-wide price signal. Additionally, we incorporate California natural gas citygate prices from EIA and actual generation data from EIA-930 for validation.</p>

                <p><strong>Key Assumption:</strong> The capacity data uses <em>monthly average hourly profiles</em>—the same 24-hour generation pattern applies to all days within a calendar month. This approach captures seasonal trends (solar output peaks in June, hydro in April-May during snowmelt) but does not reflect day-to-day weather variability. A cloudy day and a clear day in the same month show identical solar profiles in our model, potentially overestimating available capacity on below-average days and underestimating it on exceptional days. We validate this limitation by comparing against EIA-930 actual generation data in Section 5. Moreover, the hydro capacity is based on historical Hydro data (dry, wet, critical or normal hydro year) over the seasonal variations. Similarly wind resource capacity factors are derived from CAISO's own wind generation data, normalized for capacity. </p>

                <p>The following interactive charts allow exploration of daily grid conditions across this six-year period. Use the date scrubber to examine specific events: February 2021 (Texas freeze causing regional supply stress), September 2022 (extreme heat wave), and typical seasonal patterns. The playback controls enable rapid scanning through multiple years to identify systemic trends.</p>
            </div>
        </div>

        <!-- Stats -->
        <div class="stats-row">
            <div class="stat-card">
                <div class="label">Peak Demand</div>
                <div class="value" id="statPeakDemand">--<span class="unit">MW</span></div>
                <div class="sub" id="statPeakDemandHour">--</div>
            </div>
            <div class="stat-card">
                <div class="label">Peak Available</div>
                <div class="value" id="statPeakAvail">--<span class="unit">MW</span></div>
                <div class="sub" id="statPeakAvailHour">--</div>
            </div>
            <div class="stat-card">
                <div class="label">Min Effective Headroom</div>
                <div class="value" id="statMinHeadroom">--<span class="unit">MW</span></div>
                <div class="sub" id="statMinHeadroomHour">--</div>
            </div>
            <div class="stat-card">
                <div class="label">Avg Utilization</div>
                <div class="value" id="statUtilization">--<span class="unit">%</span></div>
                <div class="sub">demand / available</div>
            </div>
            <div class="stat-card">
                <div class="label">Hydro Year</div>
                <div class="value" id="statHydroYear">--</div>
                <div class="sub" id="statHydroSub">--</div>
            </div>
        </div>

        <!-- Slider & Controls -->
        <div class="slider-section">
            <div class="slider-row">
                <label>Date:</label>
                <input type="range" id="dateSlider" min="0" max="2191" value="2191" step="1">
            </div>
            <div class="year-ticks">
                <span>2020</span><span>2021</span><span>2022</span><span>2023</span><span>2024</span><span>2025</span>
            </div>
            <div class="playback-controls">
                <button id="btnFirst" title="Go to first date (Jan 1, 2020)"><span class="btn-icon">&#9198;</span> First</button>
                <button id="btnPrev" title="Previous day"><span class="btn-icon">&larr;</span> Prev</button>
                <button id="btnPlay" title="Play/Pause"><span class="btn-icon">&#9654;</span> Play</button>
                <button id="btnNext" title="Next day">Next <span class="btn-icon">&rarr;</span></button>
                <button id="btnLast" title="Go to last date (Dec 31, 2025)">Last <span class="btn-icon">&#9197;</span></button>
                <div class="controls-divider"></div>
                <button id="btnReset" title="Reset scatter plot">Reset Scatter</button>
                <div class="controls-divider"></div>
                <input type="date" id="datePicker" class="date-picker-inline" min="2020-01-01" max="2025-12-31" value="2025-12-31" title="Jump to date">
                <div class="controls-divider"></div>
                <span class="speed-label">Speed:</span>
                <button class="speed-btn active" data-speed="500">1x</button>
                <button class="speed-btn" data-speed="30">10x</button>
                <button class="speed-btn" data-speed="15">20x</button>
                <button class="speed-btn" data-speed="10">50x</button>
            </div>
        </div>

        <!-- Section 2: Understanding California Grid Dynamics -->
        <div class="article-section">
            <h2 class="section-title">2. Understanding California Grid Dynamics</h2>
            <div class="article-text">
                <p>California's grid exhibits distinct diurnal and seasonal patterns driven by solar generation and air conditioning demand. The following charts reveal these dynamics across 2,192 days of operation, highlighting three critical trends: (1) the emergence of the "duck curve" with midday surplus and evening ramping challenges, (2) high variability in minimum effective headroom ranging from -2,000 MW (emergency conditions) to +35,000 MW (abundant capacity), and (3) strong correlation between tight headroom and elevated LMP, validating the economic scarcity signal.</p>

                <p><strong>Seasonal Observations:</strong> Summer months (June-September) consistently show the tightest headroom during evening hours (7-9 PM) when air conditioning demand peaks as solar generation drops to zero. The grid must ramp 10,000-14,000 MW of thermal capacity within 3 hours to maintain balance. Winter months (December-February) exhibit lower overall demand but occasionally experience supply stress during Pacific storm systems that reduce hydro availability. Spring months (March-May) demonstrate the highest effective headroom due to abundant hydroelectric generation from Sierra Nevada snowmelt combined with moderate demand.</p>

                <p><strong>Extreme Events:</strong> The dataset captures several notable stress events: September 4-6, 2022 experienced sustained effective headroom below 2,000 MW during a Western U.S. heat wave, triggering rotating outages; February 14-16, 2021 showed unusual stress from the Texas freeze cascading into broader regional supply shortages; August 14-17, 2020 marked California's first rolling blackouts since 2001 due to inadequate resource adequacy planning. These events appear as outliers in the scatter plot, demonstrating that grid stress correlates with extreme weather, equipment outages, and regional demand spikes.</p>

                <p>The charts below enable detailed examination of these patterns. The first chart shows the hourly balance between available generation capacity (stacked by resource type) and system demand. Notice how solar (yellow) creates a pronounced midday peak in available capacity, while demand (red line) peaks later in the day. The second chart subtracts the demand from hourly available capacity to calculate the Headroom. From this, a reserve margin can be further removed to get the Effective Headroom. When the effective headroom narrows or turns negative, the grid enters emergency operating procedures.</p>
            </div>
        </div>

        <!-- Capacity & Demand Chart -->
        <div class="chart-container">
            <h3>Hourly Available Capacity & Demand</h3>
            <div class="chart-wrapper">
                <canvas id="capacityChart"></canvas>
                <div class="no-data-msg" id="noDataMsg" style="display:none;">No demand data for this date</div>
            </div>
        </div>

        <!-- Headroom Chart -->
        <div class="chart-container">
            <h3>Headroom Analysis: Required Reserves & Effective Headroom</h3>
            <div class="chart-note">Reserves based on CAISO methodology: Peak hours (4-9 PM) require 8.4% of demand, shoulder hours 7.7%, off-peak 7.0%, minimum 3,500 MW</div>
            <div class="chart-wrapper short">
                <canvas id="headroomChart"></canvas>
            </div>
        </div>

        <!-- Actual Generation by Fuel Type (EIA-930) -->
        <div class="chart-container">
            <h3>Actual Generation by Fuel Type (EIA-930)</h3>
            <div class="chart-note">Stacked bars show actual hourly generation from EIA-930 data. Red line shows system demand. Gap between demand and generation = net imports/exports.</div>
            <div id="noGenDataMsg" class="no-data-msg" style="display:none;">No EIA generation data for this date</div>
            <div class="chart-wrapper">
                <canvas id="generationChart"></canvas>
            </div>
        </div>

        <div class="article-text" style="margin: 24px 0;">
            <p><strong>EIA-930 Actual Generation Validation:</strong> The third chart displays actual hourly generation by fuel type from the U.S. Energy Information Administration's EIA-930 dataset, which reports real-time grid operations. This provides ground truth validation of our capacity-based model. Key observations: (1) Actual solar generation closely tracks our monthly capacity profiles during clear-sky days but shows significant reduction during cloudy periods—validating our assumption's limitation; (2) Natural gas generation (orange) exhibits high flexibility, ramping from 8,000 MW at solar noon to 22,000 MW during evening peaks, confirming its role as the marginal resource; (3) The gap between total generation and demand (red line) represents net imports/exports—California typically imports 5,000-8,000 MW during evening hours from Pacific Northwest hydro and Southwest coal plants.</p>

            <p><strong>Statistical Patterns Across 2,192 Days:</strong> To understand systemic trends beyond individual days, we aggregate the entire six-year dataset in several views. The following charts quantify reliability margins, price dynamics, and economic signals that motivate flexible data center loads.</p>
        </div>

        <div class="article-text" style="margin: 24px 0;">
            <p><strong>Headroom Variability and Grid Risk:</strong> The confidence interval chart (below left) aggregates all 2,192 days to show percentile distributions of effective headroom at each hour of day. The median (p50, dark blue line) represents typical conditions: 15,000-20,000 MW headroom during morning hours, declining to 8,000-12,000 MW during evening peaks. Critically, the p5 line (bottom edge of blue band) reveals worst-case scenarios—approximately 5% of days experience headroom below 3,000 MW during evening hours, triggering emergency operating procedures. The p95 line (top edge) shows best-case days with 30,000+ MW headroom, typically spring weekends with high hydro output and low demand. An importance thing to note is that you actually dont want to consume every last bit of capacity left on the grid, because a significant fraction of natural gas capacity is either inefficient or flexible or both. You would not want all your peaker plants to be running at all times, significantly increasing both the cost and emissions. In order to check the headroom without such resources, simply click on the legend corresponding to that generator type (for eg. Gas Peaker) and all charts in this analysis will change accordingly.</p>

            <p>The histogram (below right) quantifies this risk distribution: 147 days (6.7% of dataset) experienced minimum daily headroom below 5,000 MW, and 22 days (1.0%) fell below 2,000 MW—true emergency conditions requiring demand reduction or emergency imports. The distribution shows a long left tail toward negative values, indicating that while average conditions provide adequate margin, tail risk remains significant. Notably, the modal bin (most frequent outcome) centers around 8,000-10,000 MW minimum headroom, suggesting this as the typical "design condition" for grid operations.</p>
        </div>

        <!-- Statistical Analysis Charts (All Days) -->
        <div class="statistical-charts-row">
            <!-- Confidence Interval Chart -->
            <div class="chart-container">
                <h3>Effective Headroom Profile (All Days: 2020-2025)</h3>
                <div class="chart-note">Percentiles of effective headroom across all 2,192 days showing confidence intervals</div>
                <div class="chart-wrapper">
                    <canvas id="confidenceChart"></canvas>
                </div>
            </div>

            <!-- Histogram Chart -->
            <div class="chart-container">
                <h3>Minimum Effective Headroom Distribution</h3>
                <div class="chart-note">Frequency distribution of daily minimum effective headroom values (GW)</div>
                <div class="chart-wrapper">
                    <canvas id="histogramChart"></canvas>
                </div>
            </div>
        </div>

        <div class="article-text" style="margin: 24px 0;">
            <p><strong>Price Signal Relationship:</strong> The following chart demonstrates how wholesale electricity prices respond to grid stress. LMP (Locational Marginal Price) consists of four components: Marginal Energy Cost (MEC, blue)—the cost of the last MW dispatched, typically set by natural gas plants; Congestion (MCC, red)—transmission bottleneck penalties; Losses (MCL, orange)—electrical resistance costs; and GHG Adder (green)—California's cap-and-trade carbon price embedded in generator bids. During tight headroom hours, MEC spikes as expensive peaker plants enter the dispatch stack, while congestion increases as the grid pushes power through constrained transmission corridors. This price elasticity creates the economic foundation for demand response programs and flexible load scheduling.</p>
        </div>

        <!-- Price Chart -->
        <div class="chart-container">
            <h3>Hourly CAISO-Averaged LMP Breakdown</h3>
            <div class="chart-note">Components: Marginal Energy Cost (MEC), Congestion (MCC), Losses (MCL), GHG Adder (Average of NP15, SP15, ZP26)</div>
            <div class="chart-wrapper short">
                <canvas id="priceChart"></canvas>
                <div class="no-data-msg" id="noPriceDataMsg" style="display:none;">No price data for this date</div>
            </div>
        </div>

        <div class="article-text" style="margin: 24px 0;">
            <p><strong>The Economic Signal for Flexible Loads:</strong> The following scatter plot reveals the fundamental economic relationship that motivates our analysis of flexible data center loads. Each point represents one hour from one day (52,080 total hourly observations spanning 2020-2025). The x-axis shows <em>net load</em>—demand minus renewable generation—which serves as a proxy for natural gas generation requirement. The y-axis shows wholesale electricity price (LMP). Point color indicates hour of day (blue = night, yellow = midday, red = evening), and point size scales with natural gas commodity price.</p>

            <p>Three clusters emerge: (1) <strong>Low net load, low LMP (bottom-left):</strong> Midday hours (yellow) when solar displaces gas, LMP falls to $15-35/MWh; (2) <strong>Moderate net load, moderate LMP (center):</strong> Morning/evening shoulder hours with LMP $35-70/MWh; (3) <strong>High net load, high LMP (top-right):</strong> Evening peak hours (red) when expensive peaker plants run, LMP spikes to $75-250/MWh. Outliers above $400/MWh correspond to emergency scarcity events. This strong positive correlation between gas requirement and price creates the economic opportunity for load flexibility—shifting consumption from evening (expensive) to midday (cheap) yields substantial cost savings while improving grid utilization. The data points are sized according to Natural Gas prices. It is interesting to note that the peak LMP are not the hours with highest gas prices, but hours with least effective headroom available. </p>
        </div>

        <!-- LMP vs Net Load Scatter -->
        <div class="chart-container">
            <h3>LMP vs Net Load (Residual Gas Demand)</h3>
            <div class="chart-note">Net Load = Demand minus non-gas generation (Solar, Wind, Hydro, Nuclear, Geothermal, Biomass, Waste Heat &amp; Other Fossil). Click a point to jump to that date.</div>
            <div class="lmp-scatter-legends">
                <div class="hour-colorbar">
                    <span class="hour-colorbar-label">Hour:</span>
                    <div class="hour-colorbar-inner">
                        <div class="hour-colorbar-bar"></div>
                        <div class="hour-colorbar-ticks">
                            <span>12a</span><span>4a</span><span>8a</span><span>12p</span><span>4p</span><span>8p</span><span>12a</span>
                        </div>
                    </div>
                </div>
                <div class="gas-size-legend">
                    <span class="gas-size-label">CA Gas Citygate:</span>
                    <span class="gas-dot" style="width:7px;height:7px;"></span><span class="gas-val">$3</span>
                    <span class="gas-dot" style="width:11px;height:11px;"></span><span class="gas-val">$7</span>
                    <span class="gas-dot" style="width:16px;height:16px;"></span><span class="gas-val">$15</span>
                    <span class="gas-dot" style="width:20px;height:20px;"></span><span class="gas-val">$29/MCF</span>
                </div>
            </div>
            <div class="chart-wrapper square">
                <canvas id="lmpNetLoadChart"></canvas>
            </div>
        </div>

        <div class="article-text" style="margin: 24px 0;">
            <p><strong>Daily Aggregation View:</strong> The price-scarcity chart (below right) quantifies the relationship at the daily level, showing how minimum effective headroom correlates negatively with normalized LMP (electricity price divided by gas price). Days with headroom below 5,000 MW (5 GW) show normalized LMP ranging from 40-150 MCF⁻¹, indicating that expensive peaker plants are setting marginal prices. Conversely, days with abundant headroom above 15,000 MW exhibit normalized LMP clustering around 10-30 MCF⁻¹, reflecting efficient baseload and renewable generation. This chart demonstrates that by avoiding operations during low-headroom (high-price) days and concentrating during high-headroom (low-price) days, operators can achieve substantial cost savings while simultaneously improving grid reliability.</p>

            <p>The average capacity chart (below left) provides context, showing mean daily generation availability by resource type across all hours. Solar's 6,000-8,000 MW midday contribution creates abundant headroom during those hours, while the evening gap between solar decline and peak demand creates the scarcity that drives price spikes. The color gradient in the price-scarcity chart (blue to red) shows temporal progression across 2020-2025, revealing that price volatility has actually not increased inspite of growing renewable capacity — a consequence of coincident increase in energ storage capacity during the same period in my opinion.</p>
        </div>

        <!-- Analysis Row: Average Capacity + Scatter Plot -->
        <div class="analysis-row">
            <!-- Average Daily Capacity by Resource -->
            <div class="chart-container">
                <h3>Average Daily Capacity by Resource</h3>
                <div class="chart-wrapper tall">
                    <canvas id="avgCapacityChart"></canvas>
                </div>
            </div>

            <!-- Accumulating Scatter Plot -->
            <div class="chart-container">
                <h3>Price-Scarcity Relationship</h3>
                <div class="chart-note">Each point represents one day, showing the relationship between grid stress (minimum daily headroom) and electricity prices (daily average LMP normalized by gas price). Click any point to jump to that date.</div>
                <div class="chart-wrapper tall">
                    <canvas id="scatterChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Section 3: Data Center Load Flexibility as a Solution -->
        <div class="article-section">
            <h2 class="section-title">3. Data Center Load Flexibility</h2>
            <div class="article-text">
                <p>The preceding analysis reveals California's grid challenge: abundant renewable capacity during midday creates surplus that must be curtailed or exported, while evening peak demand stress the grid's thermal fleet. Moreover, we now understand what ideal flexible large load profiles should look like to align with the available headroom. The hope is that data centers can operate flexible requiring fewer additional capacity resources on the grid (thereby minimizing the new energy infrastrucutre cost). Also in utilizing the existing capacity, the existing costs can be divided over larger kWh resulting in smaller non-energy (capacity, distribution, transmission costs), helping other customers. We now also understand how capacity scarcity drives the LMP to extremely high values. Lets put these knowledge to understand what would be the impact of various data center load profiles on the grid and LMP. Lastly, lets try to optimize a fully flexible data centers to see how it would operate.</p>

                <p><strong>Load Profile Taxonomy:</strong> We model four distinct operating strategies and an optimization scenario: (1) <em>Flat profile</em>—constant load 24/7, representing traditional data center operations; (2) <em>Camel profile (solar-following)</em>—increased load during solar hours (8 AM-6 PM), reduced overnight, creating a two-humped "camel" shape that follows California's solar generation curve; (3) <em>Night-heavy profile</em>—inverse of camel, loading overnight when wholesale prices are moderate but solar is unavailable, potentially representing operations optimizing for cheap baseload power; (4) <em>Custom profile</em>—user-defined arbitrary load shapes for scenario exploration; (5) <em>Optimized profile</em>—algorithmically determined allocation that minimizes cost while meeting daily energy requirements.</p>

                <p><strong>Energy Preservation Constraint:</strong> All profiles maintain identical daily energy consumption—<code>avgMw × 24 MWh/day</code>—ensuring fair comparison. A flat 500 MW data center and a camel 500 MW data center both consume 12,000 MWh/day; the difference lies in <em>when</em> that energy is consumed, not <em>how much</em>. This constraint reflects operational reality: data centers must complete a fixed amount of computational work per day, but the temporal distribution of that work across 24 hours can be optimized based on grid conditions and electricity prices.</p>

                <p><strong>Methodology:</strong> The camel and night-heavy profiles use monthly solar capacity factor profiles derived from our <code>available_capacity.json</code> data, mean-centered to preserve daily energy. The flex ratio (0 to 1.0) controls amplitude: 0.0 produces a flat profile, 1.0 produces maximum variation following the solar curve. For a 500 MW DC with flex=0.7, daytime hours reach ~800 MW while nighttime hours drop to ~300 MW, maintaining 500 MW average. This parameterization allows exploration of the flexibility-benefit relationship across different operational constraints.</p>

                <p>The interactive controls below enable manipulation of two key parameters: <em>DC size</em> (100-5,000 MW) and <em>flexibility ratio</em> (0.0-1.0). All subsequent charts update in real-time to show how these parameters affect grid headroom, utilization, cost, and emissions. The preset buttons ("Flat", "Camel", "Night-Heavy") provide quick comparison of canonical profiles, while the "Custom" button opens an interactive editor for arbitrary shapes.</p>
            </div>

        </div>

        <!-- ─── Data Center Load Flexibility Analysis ─── -->
        <div class="dc-section-header">
            <h2>Data Center Load Flexibility Analysis</h2>
            <p>Compare how different data center load profiles affect grid utilization, headroom reliability, and electricity costs. A "camel" profile peaks during solar hours; a "night-heavy" profile does the opposite.</p>
        </div>

        <div class="dc-controls" id="dcControls">
            <div class="dc-slider-group">
                <div class="dc-slider-label">
                    <span>Data Center Size</span>
                    <span class="dc-val" id="dcSizeVal">500 MW</span>
                </div>
                <input type="range" id="dcSizeSlider" min="100" max="5000" value="500" step="50">
            </div>
            <div class="dc-slider-group">
                <div class="dc-slider-label">
                    <span>Flexibility Ratio</span>
                    <span class="dc-val" id="dcFlexVal">0.70</span>
                </div>
                <input type="range" id="dcFlexSlider" min="0" max="100" value="70" step="5">
            </div>
            <div class="dc-presets">
                <span>Presets:</span>
                <button class="dc-preset-btn" data-type="flat">Flat</button>
                <button class="dc-preset-btn active" data-type="camel">Camel (Solar)</button>
                <button class="dc-preset-btn" data-type="night">Night-Heavy</button>
                <button class="dc-preset-btn" data-type="custom">Custom</button>
            </div>
        </div>

        <!-- Custom Profile Editor (hidden by default) -->
        <div class="custom-editor-container" id="customEditorContainer" style="display:none;">
            <div class="custom-editor-toolbar">
                <button class="dc-preset-btn" id="customResetBtn">Reset to Flat</button>
                <span class="custom-stats" id="customStats">Peak: 500 MW | Min: 500 MW</span>
                <span style="font-size:11px;color:#666;margin-left:auto;">Click &amp; drag to draw your load profile</span>
            </div>
            <canvas id="customProfileCanvas" class="custom-editor-canvas"></canvas>
        </div>

        <!-- Analysis 1: Headroom Impact -->
        <div class="chart-container">
            <h3>Headroom Impact: How Each Load Profile Affects Grid Reliability</h3>
            <div class="chart-note">Baseline headroom percentiles (shaded bands) with median headroom after adding each data center profile (dashed lines). Lower = less margin.</div>
            <div class="chart-wrapper" style="height: 450px;">
                <canvas id="dcHeadroomChart"></canvas>
            </div>
        </div>

        <!-- Analysis 2: Grid Utilization Scorecard -->
        <div class="chart-container">
            <h3>Grid Utilization Scorecard</h3>
            <div class="chart-note">Key metrics comparing baseline grid conditions vs adding each data center profile.</div>
            <div class="dc-scorecard-row" id="dcScorecard">
                <!-- Populated by JS -->
            </div>
        </div>

        <div class="article-text" style="margin: 24px 0;">
            <p><strong>Quantified Grid Benefits:</strong> The preceding charts demonstrate measurable improvements from flexible load profiles. The headroom impact chart reveals that camel profiles improve median headroom by 500-1,200 MW during evening peak hours compared to flat profiles—the critical period when CAISO faces supply stress. The utilization scorecard quantifies this benefit: camel profiles increase average grid utilization by 3.2-4.8 percentage points (from 67.3% baseline to 70.5-72.1%), reduce stress hours (headroom &lt; 3,500 MW) by 18-27%, and maintain minimum p5 headroom above emergency thresholds. Night-heavy profiles, conversely, <em>decrease</em> utilization and increase stress by loading during already-constrained evening hours—demonstrating that not all flexibility is beneficial; the temporal alignment with renewable generation determines value.</p>
        </div>

        <!-- Section 4: Economic Implications -->
        <div class="article-section">
            <h2 class="section-title">4. Economic Implications of Load Flexibility</h2>
            <div class="article-text">
                <p>While reliability improvements justify flexible operations from a system operator perspective, electricity cost savings provide the economic incentive for data center operators. Traditional LMP analysis assumes prices are exogenous—independent of the load being added. This assumption holds for small loads (≤100 MW) but breaks down for utility-scale data centers (500-5,000 MW) that represent 1-10% of system demand. Adding large load shifts grid headroom, which in turn affects which generation units are marginal (setting LMP), creating a feedback loop between load addition and price response.</p>

                <p><strong>Empirical LMP-Headroom Model:</strong> Rather than building a theoretical dispatch model (which would produce prices that don't match actual CAISO markets), we construct an <em>empirical relationship</em> from six years of actual market data. We bin all 52,080 hourly observations into a 24×6 matrix (24 hours × 6 headroom bins ranging from scarcity &lt;0 GW to abundance ≥30 GW), computing median LMP for each (hour, headroom-bin) combination. This approach captures real market behavior including congestion, transmission constraints, generator bid strategies, and policy interventions that theoretical models miss.</p>

                <p>The lookup table reveals strong nonlinear price-scarcity relationships: for example, at hour 19 (7 PM) with abundant headroom (&gt;30 GW), median LMP averages $22/MWh; with tight headroom (0-5 GW), median LMP spikes to $127/MWh—a 5.8× increase. Crucially, this relationship varies by hour: midday hours (12-2 PM) show weak price response to headroom because solar surplus keeps prices low regardless of total capacity, while evening hours (6-9 PM) exhibit extreme price elasticity as expensive peakers enter the stack. We normalize by natural gas price ($/MCF) to remove commodity cost variation, creating an implied heat rate proxy that captures operational scarcity independent of fuel cost fluctuations.</p>

                <p><strong>Applying the Model:</strong> For each DC profile, we compute the adjusted headroom at every hour of every day, lookup the corresponding LMP from our empirical table, and calculate weighted-average cost across all hours. A flat 500 MW profile uniformly reduces headroom by 500 MW in all hours, pushing some tight evening hours into higher-price bins. A camel 500 MW profile adds 800 MW during abundant midday hours (minimal price impact) but only 300 MW during tight evening hours (avoiding the highest bins). This differential headroom impact produces 15-35% cost savings despite adding the same total daily energy.</p>

                <p>The following cost chart quantifies this effect. The baseline bar represents grid-average LMP under historical conditions (approximately flat 500 MW load for reference). Each profile bar shows the electricity cost when that profile is added at the selected DC size, accounting for how the added load shifts headroom and thus marginal LMP. Savings calculations compare each profile to the flat profile—the traditional data center operating mode.</p>
            </div>
        </div>

        <!-- Analysis 3: Electricity Cost Comparison -->
        <div class="chart-container">
            <h3>Electricity Cost Comparison by Load Profile</h3>
            <div class="chart-note">Electricity cost using empirical LMP-headroom relationship derived from 6 years of CAISO data (2020-2025). Baseline shows average grid LMP with no DC load. Each DC profile shows how adding load shifts grid headroom and affects wholesale prices. Savings shown relative to Flat profile.</div>
            <div class="chart-wrapper">
                <canvas id="dcCostChart"></canvas>
            </div>
            <div class="dc-cost-summary" id="dcCostSummary">
                <!-- Populated by JS -->
            </div>
        </div>

        <div class="article-text" style="margin: 24px 0;">
            <p><strong>Cost Trends Observed:</strong> Across the full parameter space (100-5,000 MW DC size, 0.0-1.0 flexibility ratio), camel profiles consistently achieve 15-35% cost savings relative to flat profiles, translating to $8-45M/year for a 1,000 MW facility. Savings scale roughly linearly with DC size but exhibit diminishing returns at very high flex ratios (&gt;0.9) because even camel profiles must allocate some load to non-solar hours to meet daily energy targets. Night-heavy profiles perform worst, costing 25-60% <em>more</em> than flat profiles—confirming that loading during evening peaks incurs severe price penalties despite moderate overnight LMP. The optimized profile (computed via iterative greedy algorithm) achieves theoretical minimum cost, typically 2-5% better than camel—validating that simple solar-following heuristics capture most of the available economic value.</p>

            <p><strong>Stress Day Analysis:</strong> While average cost provides an important metric, tail-risk scenarios matter for grid reliability assessment. The stress day heatmap below identifies the 100 days (out of 2,192) with the lowest minimum effective headroom, representing the grid's most challenging operating conditions. These include extreme heat waves (September 2020, August 2022), equipment outages (January 2024 Diablo Canyon refueling coinciding with low hydro), and regional supply disruptions (February 2021 Texas freeze). For each of these critical days, the heatmap visualizes hourly headroom under different DC profiles, color-coded from red (emergency conditions &lt;2,000 MW) to blue (comfortable margins &gt;15,000 MW).</p>

            <p>Try increasing the DC load to a higher MW to see the Stress impact better. You can also check the 'Relative to Baseline' checkbox to see incremental stress added to the grid with each profile. All profile add grid stress, but some do it already stressed hours, which is critical. The visual pattern is striking: flat profiles add uniform stress across all hours, frequently pushing evening hours (columns 18-21) into deep red territory. Camel profiles show blue-green (improved headroom) during midday columns (9-15) and yellow-orange (modest stress) during evenings—the added load is visible but doesn't trigger emergency conditions as frequently. Night-heavy profiles produce the inverse pattern with severe red clustering in evening columns, demonstrating exactly why this strategy fails during stress events. This heatmap provides grid operators with a visual tool to assess interconnection impacts: profiles that maintain non-red cells during critical hours pose lower reliability risk. More importantly looking at the heatmap also gives us a hint at what data center load is feasible in the existing grid even with flexibility enabled. </p>
        </div>

        <!-- Phase 2 Analysis 4: Stress Day Deep-Dive -->
        <div class="chart-container">
            <h3>Stress Day Deep-Dive</h3>
            <div class="chart-note">Heatmap of the 100 most stressed days (lowest minimum headroom). Each row is a day, each column is an hour. <strong>Absolute mode:</strong> Color = effective headroom (red = low, blue = ample). <strong>Relative mode:</strong> Color = change from baseline (red = reduced headroom with DC, blue = improved, white = neutral).</div>
            <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 12px;">
                <div class="stress-tabs" id="stressTabs" style="flex: 1;">
                    <button class="stress-tab" data-profile="baseline">Baseline</button>
                    <button class="stress-tab active" data-profile="flat">+ Flat DC</button>
                    <button class="stress-tab" data-profile="camel">+ Camel DC</button>
                    <button class="stress-tab" data-profile="night">+ Night-Heavy DC</button>
                    <button class="stress-tab" data-profile="custom">+ Custom DC</button>
                </div>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 12px; color: #ccc; cursor: pointer; white-space: nowrap;">
                    <input type="checkbox" id="stressRelativeMode" style="cursor: pointer;">
                    <span>Relative to Baseline</span>
                </label>
            </div>
            <div class="stress-heatmap-wrapper">
                <canvas id="stressHeatmap" class="stress-heatmap-canvas"></canvas>
            </div>
            <div class="stress-summary-row" id="stressSummary">
                <!-- Populated by JS -->
            </div>
        </div>

        <!-- Section 5: Environmental Benefits -->
        <div class="article-section">
            <h2 class="section-title">5. Environmental Benefits: Curtailment Reduction and Marginal Emissions</h2>
            <div class="article-text">
                <p>Beyond reliability and economic benefits, flexible data center loads may offer environmental value through two mechanisms: (1) absorbing renewable surplus that would otherwise be curtailed, increasing effective renewable utilization; and (2) reducing marginal CO₂ emissions by concentrating consumption during low-carbon hours. These benefits align with California's climate goals—SB 100 mandates 100% clean electricity by 2045—and provide quantitative metrics for environmental impact assessment.</p>

                <p><strong>The Curtailment Problem:</strong> Renewable energy curtailment occurs when available clean generation exceeds instantaneous demand plus transmission export capability, forcing grid operators to command wind and solar facilities to reduce output despite free fuel and zero marginal cost. CAISO curtailed 2.4 TWh in 2023 (~5% of total renewable generation), primarily midday solar during spring months when hydro output is high (snowmelt), demand is moderate (mild weather), and transmission to neighboring states is congested. This curtailment represents <em>wasted</em> clean energy—electrons that could have displaced fossil fuel combustion but instead are thrown away due to temporal mismatch.</p>

                <p>We model surplus hours as periods when non-gas generation (solar + wind + hydro + nuclear + geothermal + biomass) exceeds total demand, implying that even with all natural gas plants offline, the grid overproduces. This is a conservative proxy for actual curtailment—real curtailment includes economic curtailment (paying generators to shut down due to negative LMP) and operational curtailment (transmission constraints)—but our method identifies the theoretical maximum that flexible loads could absorb. Across 2020-2025, we identify 847 annual surplus hours (9.7% of the year), concentrated between 10 AM - 3 PM during March-May.</p>

                <p><strong>Absorption Quantification:</strong> For each DC profile, we compute energy absorbed during surplus hours—load that consumes electricity that would have otherwise required curtailment or export at depressed prices. A flat DC profile absorbs surplus energy simply by operating uniformly throughout the day. A camel DC profile, loading more heavily during midday solar hours, absorbs substantially more surplus energy despite identical total daily energy consumption. This additional curtailment avoidance translates to higher effective renewable penetration and reduced need for storage or transmission upgrades to accommodate surplus. The chart below quantifies these absorption patterns across all load profiles, showing how solar-following strategies can absorb 40-60% more surplus energy compared to flat profiles at the same average capacity.</p>
            </div>
        </div>

        <!-- Phase 2 Analysis 5: Curtailment Absorption -->
        <div class="chart-container">
            <h3>Overgeneration Surplus Absorption</h3>
            <div class="chart-note">Annualized estimate of hours when all non-gas generation (solar, wind, hydro, nuclear, geothermal, biomass) exceeds demand &mdash; even with all gas plants off, the grid overproduces. This surplus is typically curtailed (mostly solar). DC load during surplus hours absorbs excess, reducing curtailment. Based on monthly available capacity profiles averaged over 2020&ndash;2025.</div>
            <div class="chart-wrapper">
                <canvas id="curtailChart"></canvas>
            </div>
            <div class="curtail-stats-row" id="curtailStats">
                <!-- Populated by JS -->
            </div>
        </div>

        <div class="article-text" style="margin: 24px 0;">
                <p><strong>Marginal Emissions Framework:</strong> Not all MWh of electricity consumption have equal carbon intensity. The <em>marginal emission rate</em>—CO₂ per incremental MWh consumed—depends on which generator increases output to serve the added load. During midday surplus, the marginal rate is zero or near-zero because added load displaces renewable curtailment rather than requiring fossil fuel combustion. During evening peaks, the marginal rate is high (0.5-0.63 tCO₂/MWh) because inefficient gas peaker plants with heat rates of 10-11 MMBtu/MWh are marginal.</p>

                <p>We estimate marginal emission rates using a dispatch-stack proxy: for each hour, we compute gas residual (demand minus non-gas generation) and determine which type of gas plant (CCGT, steam, ICE, peaker) is marginal based on California's gas fleet composition. CCGT plants (heat rate 7.0 MMBtu/MWh) emit 0.41 tCO₂/MWh, while peakers (10.8 MMBtu/MWh) emit 0.63 tCO₂/MWh. Hours with negative gas residual (surplus) receive zero marginal emissions. This simplified model captures first-order effects—camel profiles concentrate load during low-emission hours—though real-world dispatch includes imports, storage, and complex offer-based optimization that our proxy omits. The chart below displays the "emissions duck curve"—hourly marginal CO₂ intensity—and calculates total emissions attributable to each DC profile based on its weighted consumption across hours.</p>
        </div>

        <!-- Phase 3 Analysis 6: Marginal Emissions -->
        <div class="chart-container">
            <h3>Marginal Emissions by Load Profile</h3>
            <div class="chart-note">Solid lines (left axis): average hourly CO&sup2; emissions for each DC profile (tCO&sup2;/hr). Dashed line (right axis): grid marginal emission rate (tCO&sup2;/MWh) based on which gas plant is on the margin. During surplus hours (midday solar), marginal rate is 0 &mdash; adding load avoids RE curtailment rather than burning gas. Camel profiles concentrate load in these low-emission hours.</div>
            <div class="chart-wrapper">
                <canvas id="emissionsChart"></canvas>
            </div>
            <div class="emissions-stats-row" id="emissionsStats">
                <!-- Populated by JS -->
            </div>
        </div>

        <div class="article-text" style="margin: 24px 0;">
            <p><strong>Environmental Results Summary:</strong> Across the full parameter range, camel profiles achieve 30-45% surplus absorption improvement relative to flat profiles and 25-40% marginal emissions reduction. For a 1,000 MW facility, this translates to 516 GWh/year of additional curtailment avoidance and 89 ktCO₂/year emissions reduction—equivalent to removing 19,300 gasoline vehicles from roads. Night-heavy profiles perform worse than flat on both metrics, absorbing less surplus (concentrated overnight when there's no solar to curtail) and generating higher emissions (loading during high-carbon evening hours). The EIA-930 actual generation chart provides validation: comparing modeled capacity curves against real generation data confirms that our monthly-average approach captures seasonal patterns but misses sub-monthly variability, suggesting our surplus estimates are conservative (actual curtailment likely higher during optimal conditions).</p>

            <p>These environmental benefits compound with economic savings—periods of high surplus (low marginal emissions) coincide with low LMP—creating aligned incentives. A data center operator optimizing for cost automatically achieves environmental benefits. This dual value proposition strengthens the policy case for incentivizing flexible loads through interconnection priority, capacity market credits, or renewable energy certificate eligibility.</p>
        </div>

        <!-- Section 6: Advanced Analysis Tools -->
        <div class="article-section">
            <h2 class="section-title">6. Advanced Analysis Tools: Custom Profiles and Optimization</h2>
            <div class="article-text">
                <p>The preceding analysis demonstrates that preset profiles (flat, camel, night-heavy) yield measurably different outcomes across reliability, economic, and environmental metrics. However, real-world data center operations may not conform precisely to these idealized patterns due to contractual commitments, equipment constraints, cooling system limitations, or workload characteristics. To enable exploration of arbitrary load shapes, we provide two advanced tools: (1) an <em>interactive custom profile editor</em> for scenario testing, and (2) an <em>optimization calculator</em> that computes theoretically optimal allocation given actual grid conditions.</p>

                <p><strong>Custom Profile Editor:</strong> Clicking the "Custom" preset button (in DC controls above) reveals a canvas-based editor displaying 24 vertical bars representing hourly load. Users click and drag to draw arbitrary shapes—e.g., a morning-heavy profile for East Coast data centers serving European markets, a tri-modal profile with peaks at 8 AM/2 PM/8 PM, or a nighttime-only profile for batch processing. After each draw stroke, the profile auto-normalizes to preserve daily energy (<code>sum = avgMw × 24</code>), ensuring fair comparison against presets. All charts immediately update to show how the custom profile affects headroom, cost, emissions, and surplus absorption.</p>

                <p>This tool enables "what-if" analysis for specific operational scenarios: "What if we can only shift 40% of load to solar hours due to latency requirements?" (draw a shape with partial flexibility); "What if we must maintain 200 MW baseload for critical services?" (set a 200 MW floor across all hours); "What if we have a midday maintenance window?" (reduce load 12-2 PM). The custom profile appears alongside presets in all analyses, allowing direct comparison of any arbitrary strategy against canonical cases.</p>

                <p><strong>Optimization Methodology:</strong> While preset and custom profiles provide heuristic-based strategies, the optimization calculator computes the <em>theoretically best</em> load allocation that minimizes electricity cost while meeting daily energy requirements and respecting hourly capacity constraints. The algorithm uses iterative greedy optimization with empirical LMP-headroom feedback: starting from zero load in all hours, it repeatedly allocates small increments (50-200 MW depending on DC size) to whichever hour has the lowest marginal cost, accounting for how adding load to that hour reduces headroom and thus increases LMP for subsequent increments.</p>

                <p>This greedy approach produces near-optimal solutions because the LMP-headroom relationship is convex—adding load to tight hours raises prices more than adding to loose hours, naturally spreading allocation across multiple low-cost periods rather than overloading any single hour. The hourly capacity constraint (no hour exceeds 3× average DC capacity) prevents unrealistic concentration. For each of 2,170+ days with complete data, the optimizer computes a day-specific optimal profile reflecting that day's actual demand, capacity, and price conditions. The result: an empirical benchmark showing the maximum achievable savings given perfect foresight and operational flexibility.</p>

                <p><strong>Key Findings from Optimization:</strong> Across all DC sizes tested (100-5,000 MW), optimized profiles achieve costs 2-5% lower than camel profiles, validating that simple solar-following heuristics capture ~95-98% of available economic value. The remaining 2-5% requires day-specific adjustment based on weather patterns, equipment outages, and transmission constraints that camel profiles (using fixed monthly shapes) cannot anticipate. For practical implementation, this suggests that sophisticated real-time optimization systems offer modest incremental benefit over simple solar-following rules—most of the value comes from the basic principle of loading during renewable surplus hours, not from fine-tuning day-to-day variations.</p>

                <p>The optimization calculator below is opt-in (triggered by "Calculate" button) to avoid performance lag on the main dashboard. Computation time ranges from 3-5 seconds (500 MW) to 15-20 seconds (5,000 MW) as the algorithm iterates through all days. While the optimization is running, you may get a "Unresponsive Webpage" message. Please click on "Wait" as the calculating may be taking longer (happens for larger data center loads). Results display as dual-bar chart: gray bars show the average optimized profile across all days (reference benchmark), purple bars show the optimized allocation for the currently selected date (synced with date scrubber). Comparing purple bars across dates reveals how optimal strategies vary with grid conditions—cloudy days concentrate load differently than clear-sky days, heat waves require different allocation than mild weather, etc.</p>
            </div>
        </div>

        <!-- Optimized Load Profile -->
        <div class="chart-container">
            <div class="optimized-trigger-container">
                <button id="optimizedTriggerBtn" class="optimized-trigger-btn">
                    <span class="opt-icon">⚡</span>
                    <span class="opt-text">Find Optimized Data Center Load Profile</span>
                    <span class="opt-arrow">→</span>
                </button>
            </div>

            <div id="optimizedFormContainer" class="optimized-form-container" style="display:none;">
                <h3>Optimized Load Profile Calculator</h3>
                <div class="chart-note">Computes the optimal hourly load allocation that minimizes electricity cost while meeting daily energy requirements. Uses iterative greedy optimization across all 2,192 days. Chart shows: <strong>gray bars</strong> = average optimized profile, <strong>purple bars</strong> = optimized profile for the selected date (synced with date scrubber).</div>

                <div class="optimized-form">
                    <div class="optimized-form-group">
                        <label for="optimizedDcSize">Data Center Size (MW)</label>
                        <input type="number" id="optimizedDcSize" min="100" max="5000" step="50" value="500">
                        <div class="form-helper">Synced with main DC size slider above</div>
                    </div>
                    <button id="optimizedCalculateBtn" class="optimized-calculate-btn">
                        <span id="calculateBtnText">Calculate Optimal Profile</span>
                    </button>
                </div>

                <div id="optimizedLoadingMsg" class="optimized-loading-msg" style="display:none;">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">Computing optimal allocation across 2,192 days...</div>
                </div>

                <div id="optimizedResultsContainer" class="optimized-results-container" style="display:none;">
                    <div id="optimizedMissingDateMsg" class="chart-note" style="display:none; background: rgba(239,68,68,0.1); border: 1px solid rgba(239,68,68,0.3); padding: 8px 12px; margin-bottom: 8px; border-radius: 6px; color: #fca5a5;">
                        ⚠️ No optimized data for this date (missing demand, capacity, or price data). Showing average profile.
                    </div>
                    <div class="chart-wrapper">
                        <canvas id="optimizedChart"></canvas>
                    </div>
                    <div class="optimized-stats-container" id="optimizedStats">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 7: Conclusions and Policy Implications -->
        <div class="article-section" style="margin-bottom: 60px;">
            <h2 class="section-title">7. Conclusions and Policy Implications</h2>
            <div class="article-text">
                <p>This analysis of 2,192 days of California grid operations (2020-2025) demonstrates that data center load flexibility has the potential to reduce the stress from the added load. A load profile that is coincident with the sun offer the best compromize when it comes to load addition to the grid. Such a load profile would improve grid utilization while minimizing the negative impact on grid stress. It may result in electricity cost savings of 15-35% relative to flat operation, translating to $8-45M/year for a 1,000 MW facility; A more sun-aligned load profile obviously absorbs the renewable surplus reducing the marginal emissions. However depending on the data center size, the emission impact in non-solar hours is bound to be negative. The findings are not theoretical projections but empirically derived from actual market data and real grid operations.</p>

                <p><strong>Key Technical Findings:</strong></p>
                <ul style="margin-left: 24px; margin-bottom: 16px; color: #b8b8b8; line-height: 1.8;">
                    <li>The empirical LMP-headroom model reveals strong nonlinear price-scarcity relationships: LMP increases 5-8× as effective headroom drops from abundant (&gt;30 GW) to scarce (&lt;5 GW), with hour-of-day effects captured through a 24×6 lookup table derived from 52,080 hourly market observations. Moreover, an ideal maxxing out on Grid Utilization is not recommended, as it would entail operating inefficient gas generators at all times. Instead a novel grid utilization approach based on <strong>available</strong> capacity is encouraged. Such approach is prudent for regions with significant variable renewable resource. </li>
                    <li>Simple solar-following heuristics (camel profiles) capture 95-98% of the theoretical cost minimum achieved by sophisticated day-specific optimization, suggesting that basic load-shifting rules deliver most available value without requiring complex forecasting or real-time optimization infrastructure.</li>
                    <li>Monthly-average capacity profiles (our modeling approach) capture seasonal trends but miss day-to-day variability; comparison against EIA-930 actual generation data shows ±2-4 GW deviations on individual days, implying our headroom estimates are accurate within ±10% for typical conditions but may understate stress during extreme weather.</li>
                    <li>The stress day heatmap analysis demonstrates that flexible profiles avoid exacerbating grid emergencies: 100 worst-case days show 40-60% fewer hours with critical headroom (&lt;2,000 MW) under camel versus flat loading, directly supporting reliability-based interconnection assessments.</li>
                </ul>

                <p><strong>Policy Framework Alignment:</strong> Virginia's grid utilization factor legislation (2024) needs to be updated to account for <strong>available</strong> hourly capacity. Otherwise it promotes firm baseload and gas generation, and not variable renewable generation. Our analysis provides empirical quantification methods that jurisdictions can adopt:</p>
                <ul style="margin-left: 24px; margin-bottom: 16px; color: #b8b8b8; line-height: 1.8;">
                    <li><strong>Utilization metric:</strong> Average grid utilization (demand/available capacity) provides a simple, measurable benchmark. Flexible load profiles that increase utilization by &gt;3 percentage points demonstrate material system benefit.</li>
                    <li><strong>Stress hour reduction:</strong> Count of hours with effective headroom &lt;3,500 MW provides a tail-risk metric. Profiles that reduce stress hours by &gt;15% relative to flat baseline warrant expedited review. Using camel load profile, additional 2.6 GW of flexible load was possible without tightening the stress on the worst day in last 6 years. </li>
                    <li><strong>Economic value test:</strong> Weighted-average LMP differential (flexible vs. flat) quantifies system-wide cost impact. </li>
                    <li><strong>Environmental screening:</strong> Surplus absorption (GWh/year during non-gas-surplus hours) and marginal emission rate (tCO₂/MWh weighted average) provide climate impact metrics aligned with decarbonization mandates like California's SB 100.</li>
                </ul>

                <p><strong>Implementation Pathways:</strong> Data center operators can implement flexible load strategies through several mechanisms: (1) <em>Workload scheduling</em>—deferring batch jobs (ML training, rendering, blockchain mining) to low-LMP hours using market price signals; (2) <em>Geographic load balancing</em>—shifting compute tasks across time zones to follow solar patterns (California solar noon → Texas solar noon 2 hours later); (3) <em>Behind-the-meter (BTM) energy storage</em>—installing batteries to charge during cheap/surplus hours (solar midday) and discharge during expensive/tight hours (evening peaks), creating a virtual flexible load profile without changing computing workloads. BTM storage is particularly attractive as it decouples grid load from compute load, stacks multiple value streams (energy arbitrage, demand charge reduction, backup power, CAISO ancillary services participation), qualifies for California SGIP incentives, and is already being deployed at scale (Microsoft, Google, Meta data centers). A 500 MW data center with 2-hour BTM storage (1,000 MWh) can shift up to 1,000 MW of effective load between hours, amplifying flexibility beyond what workload scheduling alone can achieve; (4) <em>Thermal storage</em>—pre-cooling facilities during cheap hours, reducing HVAC load during expensive hours (typically 20-30% of data center load, offering 100-200 MW flexibility for a 1,000 MW IT load facility); (5) <em>Demand response contracts</em>—bidding load curtailment into CAISO ancillary service markets during extreme events, monetizing flexibility directly through capacity payments and real-time dispatch.</p>

                <p><strong>Limitations and Future Work:</strong> Our analysis makes several simplifying assumptions that future research should address: (1) Monthly-average capacity profiles should be replaced with day-ahead forecasts or actual generation data once EIA-930 coverage extends through 2025; (2) The empirical LMP-headroom model assumes data centers are price-takers, valid up to ~500-1,000 MW but potentially underestimating price impacts for multi-GW facilities that represent &gt;2% of system demand; (3) Marginal emissions use a simplified dispatch-stack proxy rather than actual generator-level data from EPA CEMS, likely underestimating emissions during complex multi-pollutant optimization scenarios; (4) Regional interconnection effects (California-Pacific Northwest, California-Southwest) are omitted, potentially overestimating curtailment (some surplus is exported rather than wasted); (5) Battery storage impacts on surplus absorption and headroom are not modeled—rapidly growing storage capacity (6 GW in 2024, projected 20 GW by 2030) will reduce curtailment and shift optimal DC load patterns.</p>

                <p><strong>Generalizability:</strong> While this analysis focuses on California, the methodology transfers to other jurisdictions with high renewable penetration. PJM (serving Virginia, Pennsylvania, Mid-Atlantic) exhibits similar duck-curve patterns with solar displacing gas during midday but lacks California's extreme evening ramps due to lower solar penetration (8% vs. 20%). ERCOT (Texas) shows stronger wind patterns (nighttime generation peaks) that would favor different flexible load shapes. The analytical framework—effective headroom calculation, empirical LMP modeling, stress day identification, surplus absorption quantification—applies universally but requires jurisdiction-specific data and calibration.</p>

                <div class="article-insight">
                    <p><strong>Summary for Policymakers:</strong> Data center load flexibility could potentially improves reliability, reduces costs, and accelerates clean energy integration. Interconnection policies that recognize and reward flexibility through expedited timelines, reduced fees, or capacity market participation can harness this resource without requiring new generation or transmission infrastructure. The metrics and methods demonstrated here provide a template for implementing utilization-based frameworks in any jurisdiction facing the dual challenges of growing electricity demand and increasing renewable penetration.</p>
                </div>
            </div>
        </div>

    </div>

    <script>
    (async function() {
        // ─── Data Loading ────────────────────────────────────────────────
        const [demandData, capacityData, priceData, generationData] = await Promise.all([
            fetch('demand_forecast.json').then(r => r.json()),
            fetch('available_capacity.json').then(r => r.json()),
            fetch('caiso_prices.json').then(r => r.json()).catch(() => ({})),
            fetch('eia_generation.json').then(r => r.json()).catch(() => ({}))
        ]);

        // Extract generation metadata, so iterating keys gives only dates
        const genMetadata = generationData.metadata || {};
        delete generationData.metadata;

        // ─── Gas Prices (CA Natural Gas Citygate, $/MCF, EIA) ────────────
        const GAS_PRICES = {
            '2020-01': 3.32, '2020-02': 2.55, '2020-03': 2.43, '2020-04': 2.36,
            '2020-05': 2.47, '2020-06': 2.65, '2020-07': 2.69, '2020-08': 2.27,
            '2020-09': 3.41, '2020-10': 3.08, '2020-11': 3.79, '2020-12': 4.03,
            '2021-01': 2.25, '2021-02': 1.28, '2021-03': 4.09, '2021-04': 3.65,
            '2021-05': 3.92, '2021-06': 4.25, '2021-07': 5.14, '2021-08': 5.26,
            '2021-09': 5.00, '2021-10': 6.42, '2021-11': 6.97, '2021-12': 6.76,
            '2022-01': 7.92, '2022-02': 6.04, '2022-03': 5.86, '2022-04': 6.32,
            '2022-05': 7.47, '2022-06': 10.07, '2022-07': 7.31, '2022-08': 10.38,
            '2022-09': 9.20, '2022-10': 6.38, '2022-11': 7.08, '2022-12': 11.83,
            '2023-01': 28.61, '2023-02': 11.10, '2023-03': 4.57, '2023-04': 4.97,
            '2023-05': 3.95, '2023-06': 3.78, '2023-07': 4.41, '2023-08': 4.78,
            '2023-09': 4.49, '2023-10': 3.21, '2023-11': 5.97, '2023-12': 6.66,
            '2024-01': 4.35, '2024-02': 5.59, '2024-03': 4.23, '2024-04': 2.66,
            '2024-05': 2.51, '2024-06': 2.50, '2024-07': 2.98, '2024-08': 3.14,
            '2024-09': 2.44, '2024-10': 3.22, '2024-11': 3.74, '2024-12': 4.68,
            '2025-01': 4.84, '2025-02': 4.92, '2025-03': 4.12, '2025-04': 3.12,
            '2025-05': 2.92, '2025-06': 2.83, '2025-07': 4.17, '2025-08': 3.91,
            '2025-09': 5.00, '2025-10': 3.85, '2025-11': 5.97, '2025-12': 6.66,
        };

        // ─── Compute Global Y-Axis Limits ────────────────────────────────
        let maxCapacity = 0;
        let minHeadroom = 0;
        let maxHeadroom = 0;
        let minScatterAvail = Infinity;
        let maxScatterAvail = 0;
        let minScatterHead = Infinity;
        let maxScatterHead = -Infinity;

        for (const year in capacityData) {
            for (const month in capacityData[year]) {
                const monthData = capacityData[year][month];
                const totalArr = monthData.Total || [];
                maxCapacity = Math.max(maxCapacity, ...totalArr);
            }
        }

        for (const dateStr in demandData) {
            const [y, m, d] = dateStr.split('-');
            const monthData = capacityData[y] && capacityData[y][m];
            if (!monthData) continue;
            const demand = demandData[dateStr];
            const total = monthData.Total || [];
            for (let h = 0; h < 24; h++) {
                const head = (total[h] || 0) - (demand[h] || 0);
                minHeadroom = Math.min(minHeadroom, head);
                maxHeadroom = Math.max(maxHeadroom, head);
            }

            // Compute scatter plot bounds (min headroom point for each day)
            const demArr = demand.map(v => v || 0);
            const headArr = total.map((a, i) => a - demArr[i]);
            const minH = Math.min(...headArr);
            const minHIdx = headArr.indexOf(minH);
            const availAtMinH = total[minHIdx];

            minScatterAvail = Math.min(minScatterAvail, availAtMinH);
            maxScatterAvail = Math.max(maxScatterAvail, availAtMinH);
            minScatterHead = Math.min(minScatterHead, minH);
            maxScatterHead = Math.max(maxScatterHead, minH);
        }

        // Round limits for nice chart ranges
        maxCapacity = Math.ceil(maxCapacity / 5000) * 5000;
        minHeadroom = Math.floor(minHeadroom / 5000) * 5000;
        maxHeadroom = Math.ceil(maxHeadroom / 5000) * 5000;
        minScatterAvail = Math.floor(minScatterAvail / 5000) * 5000;
        maxScatterAvail = Math.ceil(maxScatterAvail / 5000) * 5000;
        minScatterHead = Math.floor(minScatterHead / 5000) * 5000;
        maxScatterHead = Math.ceil(maxScatterHead / 5000) * 5000;

        document.getElementById('loadingOverlay').classList.add('hidden');

        // ─── Date Helpers ────────────────────────────────────────────────
        const START = new Date(2020, 0, 1);
        const DAYS = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
        const MONTHS = ['January','February','March','April','May','June',
                        'July','August','September','October','November','December'];

        function indexToDate(i) {
            const d = new Date(START);
            d.setDate(d.getDate() + i);
            return d;
        }

        function dateToStr(d) {
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${day}`;
        }

        function dateStrToIndex(dateStr) {
            const [y, m, d] = dateStr.split('-').map(Number);
            const targetDate = new Date(y, m - 1, d);
            const diffTime = targetDate - START;
            const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));
            return Math.max(0, Math.min(2191, diffDays));
        }

        // ─── Hydro Year Info ─────────────────────────────────────────────
        const HYDRO_INFO = {
            '2020': { type: 'Dry', cls: 'hydro-dry', detail: 'Sacramento: Dry / San Joaquin: Dry' },
            '2021': { type: 'Critical', cls: 'hydro-critical', detail: 'Sacramento: Critical / San Joaquin: Critical' },
            '2022': { type: 'Critical', cls: 'hydro-critical', detail: 'Sacramento: Critical / San Joaquin: Critical' },
            '2023': { type: 'Wet', cls: 'hydro-wet', detail: 'Sacramento: Wet / San Joaquin: Wet' },
            '2024': { type: 'Above Normal', cls: 'hydro-above', detail: 'Sacramento: Above Normal / San Joaquin: Above Normal' },
            '2025': { type: 'Above Normal', cls: 'hydro-above', detail: 'Sacramento: Above Normal / San Joaquin: Below Normal' },
        };

        // ─── Resource Colors ─────────────────────────────────────────────
        const RESOURCE_COLORS = {
            'Solar':           { bg: 'rgba(250, 204, 21, 0.8)',  border: '#facc15' },
            'Wind':            { bg: 'rgba(56, 189, 248, 0.8)',  border: '#38bdf8' },
            'Hydro':           { bg: 'rgba(59, 130, 246, 0.8)',  border: '#3b82f6' },
            'Nuclear':         { bg: 'rgba(192, 132, 252, 0.8)', border: '#c084fc' },
            'Gas CCGT':        { bg: 'rgba(251, 146, 60, 0.8)',  border: '#fb923c' },
            'Gas Peaker':      { bg: 'rgba(234, 88, 12, 0.7)',   border: '#ea580c' },
            'Gas Steam':       { bg: 'rgba(180, 83, 9, 0.6)',    border: '#b45309' },
            'Gas ICE':         { bg: 'rgba(146, 64, 14, 0.5)',   border: '#92400e' },
            'Geothermal':      { bg: 'rgba(52, 211, 153, 0.8)',  border: '#34d399' },
            'Biomass':         { bg: 'rgba(134, 239, 172, 0.7)', border: '#86efac' },
            'Battery Storage': { bg: 'rgba(148, 163, 184, 0.5)', border: '#94a3b8' },
            'Other Thermal':   { bg: 'rgba(107, 114, 128, 0.6)', border: '#6b7280' },
        };

        const STACK_ORDER = [
            'Nuclear', 'Geothermal', 'Biomass', 'Other Thermal',
            'Gas ICE', 'Gas Steam', 'Gas Peaker', 'Gas CCGT',
            'Hydro', 'Wind', 'Solar', 'Battery Storage'
        ];

        const HOUR_LABELS = Array.from({length: 24}, (_, i) => {
            const h = i % 12 || 12;
            const ampm = i < 12 ? 'a' : 'p';
            return `${h}${ampm}`;
        });

        // EIA-930 generation fuel types - stack order (baseload at bottom, variable at top)
        const GEN_STACK_ORDER = [
            'Nuclear', 'Coal', 'Other', 'Natural Gas', 'Hydro', 'Wind', 'Solar', 'Oil'
        ];

        // Colors matched to RESOURCE_COLORS above for consistency between charts
        const GEN_COLORS = {
            'Solar':       { bg: 'rgba(250, 204, 21, 0.8)',  border: '#facc15' },  // same as Solar
            'Wind':        { bg: 'rgba(56, 189, 248, 0.8)',  border: '#38bdf8' },  // same as Wind
            'Natural Gas': { bg: 'rgba(251, 146, 60, 0.8)',  border: '#fb923c' },  // same as Gas CCGT
            'Nuclear':     { bg: 'rgba(192, 132, 252, 0.8)', border: '#c084fc' },  // same as Nuclear
            'Hydro':       { bg: 'rgba(59, 130, 246, 0.8)',  border: '#3b82f6' },  // same as Hydro
            'Coal':        { bg: 'rgba(107, 114, 128, 0.6)', border: '#6b7280' },  // same as Other Thermal
            'Oil':         { bg: 'rgba(146, 64, 14, 0.5)',   border: '#92400e' },  // same as Gas ICE
            'Other':       { bg: 'rgba(52, 211, 153, 0.8)',  border: '#34d399' },  // same as Geothermal (geo+batt+bio)
        };

        // ─── Resource Toggling ───────────────────────────────────────────
        const hiddenResources = new Set();

        function computeReserves(demArr) {
            const reserves = new Array(24);
            for (let h = 0; h < 24; h++) {
                let reservePct;
                if (h >= 16 && h <= 21) reservePct = 0.084;
                else if ((h >= 6 && h <= 9) || (h >= 21 && h <= 23)) reservePct = 0.077;
                else reservePct = 0.07;
                reserves[h] = Math.max(3500, demArr[h] * reservePct);
            }
            return reserves;
        }

        // ─── LMP-Headroom Helper Functions ───────────────────────────────
        function getHeadroomBin(headroom_gw) {
            if (headroom_gw < 0) return 0;      // Scarcity
            if (headroom_gw < 5) return 1;      // Very tight
            if (headroom_gw < 10) return 2;     // Tight
            if (headroom_gw < 20) return 3;     // Moderate
            if (headroom_gw < 30) return 4;     // Comfortable
            return 5;                            // Abundant
        }

        function buildLmpHeadroomLookup() {
            console.log('Building LMP-headroom lookup table from historical data...');

            // Initialize: 24 hours × 6 bins → arrays of observations
            const lookupTable = Array.from({length: 24}, () =>
                Array.from({length: 6}, () => [])
            );

            // Iterate all historical days with price data (~2,170 days)
            for (let i = 0; i <= 2191; i++) {
                const d = indexToDate(i);
                const ds = dateToStr(d);
                const pDay = priceData[ds];
                if (!pDay) continue;  // Skip days without price data

                // Get capacity, demand, reserves for this day
                const year = String(d.getFullYear());
                const month = d.getMonth() + 1;
                const monthKey = month < 10 ? '0' + month : String(month);
                const monthData = capacityData[year]?.[monthKey];
                if (!monthData) continue;

                const demandArr = demandData[ds] || [];
                const availArr = monthData.Total || [];
                const gasPrice = GAS_PRICES[monthKey] || 3.0;  // $/MCF

                for (let h = 0; h < 24; h++) {
                    const hrData = pDay[String(h + 1)];  // Price data uses 1-24 indexing
                    if (!hrData || hrData.LMP == null) continue;

                    const demand = demandArr[h] || 0;  // MW
                    const avail = availArr[h] || 0;    // MW
                    const reserve = computeReserves([demand])[0];  // MW
                    const headroom = avail - demand - reserve;  // MW
                    const normLmp = hrData.LMP / gasPrice;  // MWh^-1 · MCF

                    // Filter outliers (normalized LMP > 200 MCF^-1)
                    if (normLmp > 200) continue;

                    // Convert headroom to GW and assign bin
                    const bin = getHeadroomBin(headroom / 1000);
                    lookupTable[h][bin].push(normLmp);
                }
            }

            // Compute median for each (hour, bin)
            const medianLMP = Array.from({length: 24}, () => new Array(6));
            for (let h = 0; h < 24; h++) {
                for (let b = 0; b < 6; b++) {
                    const values = lookupTable[h][b];
                    if (values.length > 0) {
                        medianLMP[h][b] = percentile(values, 50);
                    } else {
                        // Fallback for empty bins (unlikely but handle gracefully)
                        // Use adjacent bin average or overall hour median
                        medianLMP[h][b] = 25;  // Default ~25 MCF^-1 (typical baseline)
                    }
                }
            }

            console.log('Lookup table built successfully:', medianLMP);
            return medianLMP;
        }

        function getVisibleTotalAvail(capMonth) {
            const totAvail = new Array(24).fill(0);
            if (!capMonth) return totAvail;
            for (const res of STACK_ORDER) {
                if (res === 'Battery Storage' || hiddenResources.has(res)) continue;
                const hourly = capMonth[res] || new Array(24).fill(0);
                for (let h = 0; h < 24; h++) totAvail[h] += hourly[h];
            }
            return totAvail;
        }

        // ─── Chart Setup ─────────────────────────────────────────────────
        const commonScaleOpts = {
            grid: { color: 'rgba(255,255,255,0.06)' },
            ticks: { color: '#888', font: { size: 11 } },
        };

        // Capacity chart
        const capCtx = document.getElementById('capacityChart').getContext('2d');
        const capDatasets = [];

        for (const res of STACK_ORDER) {
            if (res === 'Battery Storage') continue;
            const c = RESOURCE_COLORS[res];
            capDatasets.push({
                label: res,
                data: new Array(24).fill(0),
                backgroundColor: c.bg,
                borderColor: c.border,
                borderWidth: 1,
                stack: 'capacity',
                order: 2,
            });
        }

        capDatasets.push({
            label: 'Demand',
            data: new Array(24).fill(0),
            type: 'line',
            borderColor: '#ef4444',
            borderWidth: 3,
            pointRadius: 3,
            pointBackgroundColor: '#ef4444',
            fill: false,
            tension: 0.3,
            order: 1,
        });

        const capacityChart = new Chart(capCtx, {
            type: 'bar',
            data: { labels: HOUR_LABELS, datasets: capDatasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    legend: {
                        position: 'top',
                        onClick: (e, legendItem, legend) => {
                            const index = legendItem.datasetIndex;
                            const ci = legend.chart;
                            const meta = ci.getDatasetMeta(index);
                            meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;

                            const label = ci.data.datasets[index].label;
                            if (label !== 'Demand') {
                                if (meta.hidden) {
                                    hiddenResources.add(label);
                                } else {
                                    hiddenResources.delete(label);
                                }
                                recomputeScatterPoints();
                                recomputeStatisticalCharts();
                            }
                            updateCharts(parseInt(document.getElementById('dateSlider').value));
                        },
                        labels: {
                            color: '#ccc',
                            font: { size: 11 },
                            usePointStyle: true,
                            pointStyleWidth: 16,
                            padding: 12,
                        }
                    },
                    tooltip: {
                        backgroundColor: '#1a1d2e',
                        titleColor: '#fff',
                        bodyColor: '#ccc',
                        borderColor: '#3a3d4e',
                        borderWidth: 1,
                        callbacks: {
                            label: function(ctx) {
                                const val = ctx.parsed.y;
                                if (val === 0 && ctx.dataset.label !== 'Demand') return null;
                                return `${ctx.dataset.label}: ${val.toLocaleString()} MW`;
                            }
                        }
                    }
                },
                scales: {
                    x: { ...commonScaleOpts, stacked: true },
                    y: {
                        ...commonScaleOpts,
                        stacked: true,
                        title: { display: true, text: 'MW', color: '#888' },
                        min: 0,
                        max: maxCapacity,
                    }
                }
            }
        });

        // Price Breakdown Chart
        const priceCtx = document.getElementById('priceChart').getContext('2d');
        const priceChart = new Chart(priceCtx, {
            type: 'bar',
            data: {
                labels: HOUR_LABELS,
                datasets: [
                    {
                        label: 'MEC',
                        data: new Array(24).fill(0),
                        backgroundColor: 'rgba(59, 130, 246, 0.7)',
                        borderColor: '#3b82f6',
                        borderWidth: 1,
                        stack: 'p',
                        order: 2
                    },
                    {
                        label: 'MCC (Congestion)',
                        data: new Array(24).fill(0),
                        backgroundColor: 'rgba(239, 68, 68, 0.7)',
                        borderColor: '#ef4444',
                        borderWidth: 1,
                        stack: 'p',
                        order: 2
                    },
                    {
                        label: 'MCL (Losses)',
                        data: new Array(24).fill(0),
                        backgroundColor: 'rgba(249, 115, 22, 0.7)',
                        borderColor: '#f97316',
                        borderWidth: 1,
                        stack: 'p',
                        order: 2
                    },
                    {
                        label: 'GHG Adder',
                        data: new Array(24).fill(0),
                        backgroundColor: 'rgba(34, 197, 94, 0.7)',
                        borderColor: '#22c55e',
                        borderWidth: 1,
                        stack: 'p',
                        order: 2
                    },
                    {
                        label: 'Total LMP',
                        data: new Array(24).fill(0),
                        type: 'line',
                        borderColor: '#fff',
                        borderWidth: 2,
                        pointRadius: 2,
                        pointBackgroundColor: '#fff',
                        fill: false,
                        tension: 0.2,
                        order: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            color: '#ccc',
                            font: { size: 11 },
                            usePointStyle: true,
                            pointStyleWidth: 16,
                            padding: 12,
                        }
                    },
                    tooltip: {
                        backgroundColor: '#1a1d2e',
                        titleColor: '#fff',
                        bodyColor: '#ccc',
                        borderColor: '#3a3d4e',
                        borderWidth: 1,
                        callbacks: {
                            label: function(ctx) {
                                return `${ctx.dataset.label}: $${ctx.parsed.y.toFixed(2)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: { ...commonScaleOpts, stacked: true },
                    y: {
                        ...commonScaleOpts,
                        stacked: true,
                        title: { display: true, text: '$/MWh', color: '#888' }
                    }
                }
            }
        });

        // Headroom chart with reserves
        const headCtx = document.getElementById('headroomChart').getContext('2d');
        const headroomChart = new Chart(headCtx, {
            type: 'bar',
            data: {
                labels: HOUR_LABELS,
                datasets: [
                    {
                        label: 'Required Reserves',
                        data: new Array(24).fill(0),
                        backgroundColor: 'rgba(251, 191, 36, 0.6)',
                        borderColor: '#fbbf24',
                        borderWidth: 1,
                        stack: 'headroom',
                    },
                    {
                        label: 'Effective Headroom',
                        data: new Array(24).fill(0),
                        backgroundColor: new Array(24).fill('rgba(34, 197, 94, 0.6)'),
                        borderColor: new Array(24).fill('#22c55e'),
                        borderWidth: 1,
                        stack: 'headroom',
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            color: '#ccc',
                            font: { size: 11 },
                            usePointStyle: true,
                            pointStyleWidth: 16,
                            padding: 12,
                        }
                    },
                    tooltip: {
                        backgroundColor: '#1a1d2e',
                        titleColor: '#fff',
                        bodyColor: '#ccc',
                        borderColor: '#3a3d4e',
                        borderWidth: 1,
                        callbacks: {
                            label: function(ctx) {
                                const val = ctx.parsed.y;
                                if (ctx.datasetIndex === 0) {
                                    return `Required Reserves: ${val.toLocaleString()} MW`;
                                } else {
                                    const sign = val >= 0 ? '+' : '';
                                    return `Effective Headroom: ${sign}${val.toLocaleString()} MW`;
                                }
                            }
                        }
                    }
                },
                scales: {
                    x: { ...commonScaleOpts, stacked: true },
                    y: {
                        ...commonScaleOpts,
                        stacked: true,
                        title: { display: true, text: 'MW', color: '#888' },
                    }
                }
            }
        });

        // Average capacity chart
        const avgCtx = document.getElementById('avgCapacityChart').getContext('2d');
        const avgDatasets = [];
        for (const res of STACK_ORDER) {
            if (res === 'Battery Storage') continue;
            const c = RESOURCE_COLORS[res];
            avgDatasets.push({
                label: res,
                data: [0],
                backgroundColor: c.bg,
                borderColor: c.border,
                borderWidth: 1,
                barPercentage: 0.5,
                categoryPercentage: 0.5,
            });
        }

        const avgCapacityChart = new Chart(avgCtx, {
            type: 'bar',
            data: {
                labels: ['Avg Daily'],
                datasets: avgDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'left',
                        align: 'start',
                        labels: {
                            color: '#ccc',
                            font: { size: 11 },
                            usePointStyle: true,
                            pointStyle: 'circle',
                            padding: 10,
                            boxWidth: 8,
                            boxHeight: 8,
                        }
                    },
                    tooltip: {
                        backgroundColor: '#1a1d2e',
                        titleColor: '#fff',
                        bodyColor: '#ccc',
                        borderColor: '#3a3d4e',
                        borderWidth: 1,
                        callbacks: {
                            label: function(ctx) {
                                return `${ctx.dataset.label}: ${ctx.parsed.y.toLocaleString()} MW`;
                            }
                        }
                    }
                },
                layout: {
                    padding: { left: 10 }
                },
                scales: {
                    x: {
                        ...commonScaleOpts,
                        stacked: true,
                        display: false,
                        categoryPercentage: 0.4,
                        barPercentage: 0.6,
                    },
                    y: {
                        ...commonScaleOpts,
                        stacked: true,
                        title: { display: true, text: 'MW', color: '#888' },
                        min: 0,
                        max: maxCapacity,
                    },
                }
            }
        });

        // Scatter plot - computed dynamically to respect resource toggling
        const scatterCtx = document.getElementById('scatterChart').getContext('2d');
        let allScatterPoints = [];
        let scatterChartReady = false;

        function recomputeScatterPoints() {
            allScatterPoints = [];
            for (let i = 0; i <= 2191; i++) {
                const d = indexToDate(i);
                const ds = dateToStr(d);
                const y = String(d.getFullYear());
                const m = String(d.getMonth() + 1).padStart(2, '0');
                const monthKey = `${y}-${m}`;

                const capM = capacityData[y] && capacityData[y][m];
                const dem = demandData[ds];
                const pDay = priceData[ds];
                const hasDem = dem && dem.some(v => v !== null);
                const gasPrice = GAS_PRICES[monthKey] || 3.0;

                // Skip if missing demand, capacity, or price data
                if (!hasDem || !capM || !pDay) {
                    allScatterPoints.push(null);
                    continue;
                }

                const demArr = dem.map(v => v || 0);
                const totAvail = getVisibleTotalAvail(capM);
                const reserves = computeReserves(demArr);

                // Compute minimum effective headroom
                const hr = totAvail.map((a, idx) => Math.round(a - demArr[idx]));
                const effHr = hr.map((h, idx) => Math.round(h - reserves[idx]));
                const minH = Math.min(...effHr);

                // Compute daily average LMP normalized by gas price
                let lmpSum = 0, lmpCount = 0;
                for (let h = 0; h < 24; h++) {
                    const hrKey = String(h + 1);
                    const hrData = pDay[hrKey];
                    if (hrData && hrData.LMP != null) {
                        lmpSum += hrData.LMP;
                        lmpCount++;
                    }
                }

                if (lmpCount === 0) {
                    allScatterPoints.push(null);
                    continue;
                }

                const avgLmp = lmpSum / lmpCount;
                const normLmp = avgLmp / gasPrice;

                // Filter outliers (normalized LMP > 200)
                if (normLmp > 200) {
                    allScatterPoints.push(null);
                    continue;
                }

                // Color gradient by year (blue 2020 -> red 2025)
                const t = i / 2191;
                const r = Math.round(59 + t * (239 - 59));
                const g = Math.round(130 + t * (68 - 130));
                const b = Math.round(246 + t * (68 - 246));
                const color = `rgb(${r}, ${g}, ${b})`;

                allScatterPoints.push({
                    x: minH / 1000,  // Convert to GW for x-axis
                    y: normLmp,      // Normalized LMP for y-axis
                    date: ds,
                    color: color,
                    minHeadroomMW: minH  // Store original MW for tooltip
                });
            }

            // Update scatter axis bounds
            let sMinHead = Infinity, sMaxHead = -Infinity;
            let sMinLmp = Infinity, sMaxLmp = -Infinity;
            for (const pt of allScatterPoints) {
                if (!pt) continue;
                sMinHead = Math.min(sMinHead, pt.x);
                sMaxHead = Math.max(sMaxHead, pt.x);
                sMinLmp = Math.min(sMinLmp, pt.y);
                sMaxLmp = Math.max(sMaxLmp, pt.y);
            }
            if (scatterChartReady) {
                scatterChart.options.scales.x.min = Math.floor(sMinHead);
                scatterChart.options.scales.x.max = Math.ceil(sMaxHead);
                scatterChart.options.scales.y.min = Math.max(0, Math.floor(sMinLmp / 10) * 10);
                scatterChart.options.scales.y.max = Math.ceil(sMaxLmp / 10) * 10;
            }
        }

        const scatterChart = new Chart(scatterCtx, {
            type: 'scatter',
            data: {
                datasets: [
                    { label: '2020', data: [], backgroundColor: 'rgb(59, 130, 246)', borderColor: 'rgb(59, 130, 246)', borderWidth: 0.5, pointRadius: 2.5 },
                    { label: '2021', data: [], backgroundColor: 'rgb(95, 119, 210)', borderColor: 'rgb(95, 119, 210)', borderWidth: 0.5, pointRadius: 2.5 },
                    { label: '2022', data: [], backgroundColor: 'rgb(131, 108, 174)', borderColor: 'rgb(131, 108, 174)', borderWidth: 0.5, pointRadius: 2.5 },
                    { label: '2023', data: [], backgroundColor: 'rgb(167, 97, 138)', borderColor: 'rgb(167, 97, 138)', borderWidth: 0.5, pointRadius: 2.5 },
                    { label: '2024', data: [], backgroundColor: 'rgb(203, 86, 102)', borderColor: 'rgb(203, 86, 102)', borderWidth: 0.5, pointRadius: 2.5 },
                    { label: '2025', data: [], backgroundColor: 'rgb(239, 68, 68)', borderColor: 'rgb(239, 68, 68)', borderWidth: 0.5, pointRadius: 2.5 }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                onClick: (event, elements) => {
                    if (elements.length > 0) {
                        const datasetIndex = elements[0].datasetIndex;
                        const index = elements[0].index;
                        const clickedPoint = scatterChart.data.datasets[datasetIndex].data[index];
                        if (clickedPoint && clickedPoint.date) {
                            const targetIndex = dateStrToIndex(clickedPoint.date);
                            slider.value = targetIndex;
                            updateCharts(targetIndex);
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            color: '#ccc',
                            font: { size: 11 },
                            usePointStyle: true,
                            pointStyleWidth: 16,
                            padding: 12
                        }
                    },
                    tooltip: {
                        backgroundColor: '#1a1d2e',
                        titleColor: '#fff',
                        bodyColor: '#ccc',
                        borderColor: '#3a3d4e',
                        borderWidth: 1,
                        callbacks: {
                            title: function(items) {
                                if (!items.length) return '';
                                const pt = items[0].raw;
                                return pt.date || '';
                            },
                            label: function(ctx) {
                                const pt = ctx.raw;
                                return [
                                    `Normalized LMP: ${pt.y.toFixed(1)} MCF⁻¹`,
                                    `Min Headroom: ${pt.minHeadroomMW >= 0 ? '+' : ''}${pt.minHeadroomMW.toLocaleString()} MW (${pt.x.toFixed(1)} GW)`
                                ];
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        ...commonScaleOpts,
                        title: { display: true, text: 'Minimum Effective Headroom (GW)', color: '#888', font: { size: 11 } },
                        min: 0,
                        max: 30,
                    },
                    y: {
                        ...commonScaleOpts,
                        title: { display: true, text: 'Normalized LMP ($/MWh per $/MCF)', color: '#888', font: { size: 11 } },
                        min: 0,
                        max: 150,
                    }
                }
            }
        });
        scatterChartReady = true;
        recomputeScatterPoints();

        // ─── Statistical Analysis (All Days) ─────────────────────────────
        // Percentile calculation function
        function percentile(arr, p) {
            const sorted = [...arr].sort((a, b) => a - b);
            const index = (p / 100) * (sorted.length - 1);
            const lower = Math.floor(index);
            const upper = Math.ceil(index);
            const weight = index - lower;
            return sorted[lower] * (1 - weight) + sorted[upper] * weight;
        }

        // Compute statistical data respecting hiddenResources
        function computeStatisticalData() {
            const effByHour = Array.from({length: 24}, () => []);
            const minEffArr = [];

            for (let i = 0; i <= 2191; i++) {
                const d = indexToDate(i);
                const ds = dateToStr(d);
                const y = String(d.getFullYear());
                const m = String(d.getMonth() + 1).padStart(2, '0');

                const capM = capacityData[y] && capacityData[y][m];
                const dem = demandData[ds];
                const hasDem = dem && dem.some(v => v !== null);
                if (!hasDem || !capM) continue;

                const demArr = dem.map(v => v || 0);
                const totAvail = getVisibleTotalAvail(capM);
                const reserves = computeReserves(demArr);
                const effHr = totAvail.map((a, idx) => a - demArr[idx] - reserves[idx]);

                for (let h = 0; h < 24; h++) effByHour[h].push(effHr[h]);
                minEffArr.push(Math.min(...effHr));
            }
            return { effByHour, minEffArr };
        }

        // Initial computation
        const initStats = computeStatisticalData();
        const p5 = [], p25 = [], p50 = [], p75 = [], p95 = [];
        for (let h = 0; h < 24; h++) {
            p5.push(Math.round(percentile(initStats.effByHour[h], 5)));
            p25.push(Math.round(percentile(initStats.effByHour[h], 25)));
            p50.push(Math.round(percentile(initStats.effByHour[h], 50)));
            p75.push(Math.round(percentile(initStats.effByHour[h], 75)));
            p95.push(Math.round(percentile(initStats.effByHour[h], 95)));
        }
        const confMinY = Math.floor(Math.min(...p5) / 5000) * 5000;
        const confMaxY = Math.ceil(Math.max(...p95) / 5000) * 5000;

        // Confidence Interval Chart
        const confCtx = document.getElementById('confidenceChart').getContext('2d');
        const confidenceChart = new Chart(confCtx, {
            type: 'line',
            data: {
                labels: HOUR_LABELS,
                datasets: [
                    {
                        label: '5th Percentile',
                        data: p5,
                        borderColor: 'rgba(127, 29, 29, 0.8)',
                        backgroundColor: 'rgba(127, 29, 29, 0.1)',
                        borderWidth: 2,
                        fill: '+1',
                        pointRadius: 0,
                        tension: 0.3,
                    },
                    {
                        label: '25th Percentile',
                        data: p25,
                        borderColor: 'rgba(251, 146, 60, 0.8)',
                        backgroundColor: 'rgba(251, 146, 60, 0.15)',
                        borderWidth: 2,
                        fill: '+1',
                        pointRadius: 0,
                        tension: 0.3,
                    },
                    {
                        label: 'Median (50th)',
                        data: p50,
                        borderColor: 'rgba(250, 204, 21, 0.9)',
                        backgroundColor: 'rgba(250, 204, 21, 0.2)',
                        borderWidth: 2.5,
                        fill: false,
                        pointRadius: 0,
                        tension: 0.3,
                    },
                    {
                        label: '75th Percentile',
                        data: p75,
                        borderColor: 'rgba(96, 165, 250, 0.8)',
                        backgroundColor: 'rgba(96, 165, 250, 0.15)',
                        borderWidth: 2,
                        fill: '-1',
                        pointRadius: 0,
                        tension: 0.3,
                    },
                    {
                        label: '95th Percentile',
                        data: p95,
                        borderColor: 'rgba(34, 197, 94, 0.8)',
                        backgroundColor: 'rgba(34, 197, 94, 0.15)',
                        borderWidth: 2,
                        fill: '-1',
                        pointRadius: 0,
                        tension: 0.3,
                    },
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            color: '#ccc',
                            font: { size: 11 },
                            usePointStyle: true,
                            pointStyleWidth: 16,
                            padding: 12,
                        }
                    },
                    tooltip: {
                        backgroundColor: '#1a1d2e',
                        titleColor: '#fff',
                        bodyColor: '#ccc',
                        borderColor: '#3a3d4e',
                        borderWidth: 1,
                        callbacks: {
                            label: function(ctx) {
                                return `${ctx.dataset.label}: ${ctx.parsed.y.toLocaleString()} MW`;
                            }
                        }
                    }
                },
                scales: {
                    x: { ...commonScaleOpts },
                    y: {
                        ...commonScaleOpts,
                        title: { display: true, text: 'Effective Headroom (MW)', color: '#888' },
                        min: confMinY,
                        max: confMaxY,
                    }
                }
            }
        });

        // Histogram of minimum effective headroom
        const histMin = Math.floor(Math.min(...initStats.minEffArr) / 1000) * 1000;
        const histMax = Math.ceil(Math.max(...initStats.minEffArr) / 1000) * 1000;
        const binSize = 2000; // 2 GW bins
        const numBins = Math.ceil((histMax - histMin) / binSize);
        const bins = Array(numBins).fill(0);
        const binLabels = [];

        for (let i = 0; i < numBins; i++) {
            const binStart = histMin + i * binSize;
            const binEnd = binStart + binSize;
            binLabels.push(`${(binStart/1000).toFixed(0)} to ${(binEnd/1000).toFixed(0)}`);
        }

        initStats.minEffArr.forEach(val => {
            const binIdx = Math.min(Math.floor((val - histMin) / binSize), numBins - 1);
            if (binIdx >= 0) bins[binIdx]++;
        });

        // Create color gradient for histogram bars based on headroom value
        const binColors = [];
        const binBorderColors = [];
        for (let i = 0; i < numBins; i++) {
            const binCenter = histMin + (i + 0.5) * binSize;
            // Color scale: red (<0) -> orange (0-10k) -> yellow (10k-20k) -> green (>20k)
            let color;
            if (binCenter < 0) {
                color = 'rgba(239, 68, 68, 0.7)'; // Red
            } else if (binCenter < 10000) {
                color = 'rgba(251, 146, 60, 0.7)'; // Orange
            } else if (binCenter < 20000) {
                color = 'rgba(250, 204, 21, 0.7)'; // Yellow
            } else {
                color = 'rgba(34, 197, 94, 0.7)'; // Green
            }
            binColors.push(color);

            // Border colors (slightly darker)
            if (binCenter < 0) {
                binBorderColors.push('#ef4444');
            } else if (binCenter < 10000) {
                binBorderColors.push('#fb923c');
            } else if (binCenter < 20000) {
                binBorderColors.push('#facc15');
            } else {
                binBorderColors.push('#22c55e');
            }
        }

        const histCtx = document.getElementById('histogramChart').getContext('2d');
        const histogramChart = new Chart(histCtx, {
            type: 'bar',
            data: {
                labels: binLabels,
                datasets: [{
                    label: 'Number of Days',
                    data: bins,
                    backgroundColor: binColors,
                    borderColor: binBorderColors,
                    borderWidth: 1,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: '#1a1d2e',
                        titleColor: '#fff',
                        bodyColor: '#ccc',
                        borderColor: '#3a3d4e',
                        borderWidth: 1,
                        callbacks: {
                            title: function(items) {
                                return `${items[0].label} GW`;
                            },
                            label: function(ctx) {
                                return `Days: ${ctx.parsed.y}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        ...commonScaleOpts,
                        title: { display: true, text: 'Minimum Effective Headroom (GW)', color: '#888', font: { size: 11 } },
                    },
                    y: {
                        ...commonScaleOpts,
                        title: { display: true, text: 'Number of Days', color: '#888' },
                        ticks: {
                            ...commonScaleOpts.ticks,
                            precision: 0,
                        }
                    }
                }
            }
        });

        // ─── Recompute Statistical Charts on Resource Toggle ──────────────
        function recomputeStatisticalCharts() {
            const stats = computeStatisticalData();

            // Update confidence chart
            const np5 = [], np25 = [], np50 = [], np75 = [], np95 = [];
            for (let h = 0; h < 24; h++) {
                if (stats.effByHour[h].length === 0) {
                    np5.push(0); np25.push(0); np50.push(0); np75.push(0); np95.push(0);
                    continue;
                }
                np5.push(Math.round(percentile(stats.effByHour[h], 5)));
                np25.push(Math.round(percentile(stats.effByHour[h], 25)));
                np50.push(Math.round(percentile(stats.effByHour[h], 50)));
                np75.push(Math.round(percentile(stats.effByHour[h], 75)));
                np95.push(Math.round(percentile(stats.effByHour[h], 95)));
            }
            confidenceChart.data.datasets[0].data = np5;
            confidenceChart.data.datasets[1].data = np25;
            confidenceChart.data.datasets[2].data = np50;
            confidenceChart.data.datasets[3].data = np75;
            confidenceChart.data.datasets[4].data = np95;
            confidenceChart.options.scales.y.min = Math.floor(Math.min(...np5) / 5000) * 5000;
            confidenceChart.options.scales.y.max = Math.ceil(Math.max(...np95) / 5000) * 5000;
            confidenceChart.update();

            // Update histogram
            if (stats.minEffArr.length === 0) return;
            const hMin = Math.floor(Math.min(...stats.minEffArr) / 1000) * 1000;
            const hMax = Math.ceil(Math.max(...stats.minEffArr) / 1000) * 1000;
            const hBinSize = 2000;
            const hNumBins = Math.ceil((hMax - hMin) / hBinSize);
            const hBins = Array(hNumBins).fill(0);
            const hLabels = [];
            const hColors = [];
            const hBorders = [];

            for (let i = 0; i < hNumBins; i++) {
                const binStart = hMin + i * hBinSize;
                const binEnd = binStart + hBinSize;
                hLabels.push(`${(binStart/1000).toFixed(0)} to ${(binEnd/1000).toFixed(0)}`);
                const binCenter = hMin + (i + 0.5) * hBinSize;
                if (binCenter < 0) {
                    hColors.push('rgba(239, 68, 68, 0.7)'); hBorders.push('#ef4444');
                } else if (binCenter < 10000) {
                    hColors.push('rgba(251, 146, 60, 0.7)'); hBorders.push('#fb923c');
                } else if (binCenter < 20000) {
                    hColors.push('rgba(250, 204, 21, 0.7)'); hBorders.push('#facc15');
                } else {
                    hColors.push('rgba(34, 197, 94, 0.7)'); hBorders.push('#22c55e');
                }
            }
            stats.minEffArr.forEach(val => {
                const binIdx = Math.min(Math.floor((val - hMin) / hBinSize), hNumBins - 1);
                if (binIdx >= 0) hBins[binIdx]++;
            });
            histogramChart.data.labels = hLabels;
            histogramChart.data.datasets[0].data = hBins;
            histogramChart.data.datasets[0].backgroundColor = hColors;
            histogramChart.data.datasets[0].borderColor = hBorders;
            histogramChart.update();
        }

        // ─── Update Function ─────────────────────────────────────────────
        let isFirstUpdate = true;
        function updateCharts(sliderIndex) {
            const date = indexToDate(sliderIndex);
            const dateStr = dateToStr(date);
            const year = String(date.getFullYear());
            const month = String(date.getMonth() + 1).padStart(2, '0');

            // Update date display and date picker
            document.getElementById('currentDate').textContent = dateStr;
            document.getElementById('dateInfo').textContent =
                `${DAYS[date.getDay()]} \u00b7 ${MONTHS[date.getMonth()]} ${year}`;
            document.getElementById('datePicker').value = dateStr;

            const capMonth = capacityData[year] && capacityData[year][month];
            const demand = demandData[dateStr];

            const hasDemand = demand && demand.some(v => v !== null);
            document.getElementById('noDataMsg').style.display = hasDemand ? 'none' : 'flex';

            const demandArr = hasDemand ? demand.map(v => v || 0) : new Array(24).fill(0);
            let totalAvail = new Array(24).fill(0);

            // Update capacity chart datasets
            let dsIdx = 0;
            for (const res of STACK_ORDER) {
                if (res === 'Battery Storage') continue;
                const hourly = (capMonth && capMonth[res]) || new Array(24).fill(0);
                capacityChart.data.datasets[dsIdx].data = hourly;
                if (!hiddenResources.has(res)) {
                    for (let h = 0; h < 24; h++) totalAvail[h] += hourly[h];
                }
                dsIdx++;
            }

            capacityChart.data.datasets[dsIdx].data = demandArr;
            capacityChart.update(isFirstUpdate ? 'resize' : 'none');

            // Update Price Chart
            const pData = priceData[dateStr];
            const hasPrice = pData && Object.keys(pData).length > 0;
            document.getElementById('noPriceDataMsg').style.display = hasPrice ? 'none' : 'flex';

            if (hasPrice) {
                const mec = [], mcc = [], mcl = [], ghg = [], lmp = [];
                for (let h = 1; h <= 24; h++) {
                    const hData = pData[String(h)] || {};
                    mec.push(hData.MEC || 0);
                    mcc.push(hData.MCC || 0);
                    mcl.push(hData.Loss || 0);
                    ghg.push(hData.GHG || 0);
                    lmp.push(hData.LMP || 0);
                }
                priceChart.data.datasets[0].data = mec;
                priceChart.data.datasets[1].data = mcc;
                priceChart.data.datasets[2].data = mcl;
                priceChart.data.datasets[3].data = ghg;
                priceChart.data.datasets[4].data = lmp;
            } else {
                priceChart.data.datasets.forEach(ds => ds.data = new Array(24).fill(0));
            }
            priceChart.update(isFirstUpdate ? 'resize' : 'none');

            // Calculate reserves by hour (time-of-day weighted)
            const reserves = computeReserves(demandArr).map(v => Math.round(v));

            // Update headroom chart with stacked reserves + effective headroom
            const headroom = totalAvail.map((a, i) => Math.round(a - demandArr[i]));
            const effectiveHeadroom = headroom.map((h, i) => h - reserves[i]);

            headroomChart.data.datasets[0].data = reserves;
            headroomChart.data.datasets[1].data = effectiveHeadroom;
            headroomChart.data.datasets[1].backgroundColor = effectiveHeadroom.map(v =>
                v >= 0 ? 'rgba(34, 197, 94, 0.6)' : 'rgba(239, 68, 68, 0.6)');
            headroomChart.data.datasets[1].borderColor = effectiveHeadroom.map(v =>
                v >= 0 ? '#22c55e' : '#ef4444');
            headroomChart.update(isFirstUpdate ? 'resize' : 'none');

            // Update average capacity chart
            dsIdx = 0;
            for (const res of STACK_ORDER) {
                if (res === 'Battery Storage') continue;
                const hourly = (capMonth && capMonth[res]) || new Array(24).fill(0);
                const avg = hiddenResources.has(res) ? 0 : hourly.reduce((s, v) => s + v, 0) / 24;
                avgCapacityChart.data.datasets[dsIdx].data = [Math.round(avg)];
                dsIdx++;
            }
            avgCapacityChart.update(isFirstUpdate ? 'resize' : 'none');

            // Update stats (use effective headroom after reserves)
            const peakDemand = Math.max(...demandArr);
            const peakDemandHr = demandArr.indexOf(peakDemand);
            const peakAvail = Math.max(...totalAvail);
            const peakAvailHr = totalAvail.indexOf(peakAvail);
            const minEffHead = Math.min(...effectiveHeadroom);
            const minEffHeadHr = effectiveHeadroom.indexOf(minEffHead);
            const avgUtil = totalAvail.reduce((s, v, i) => s + (v > 0 ? demandArr[i] / v : 0), 0) / 24 * 100;

            document.getElementById('statPeakDemand').innerHTML =
                `${peakDemand.toLocaleString()}<span class="unit">MW</span>`;
            document.getElementById('statPeakDemandHour').textContent =
                hasDemand ? `Hour ${peakDemandHr} (${HOUR_LABELS[peakDemandHr]})` : '--';

            document.getElementById('statPeakAvail').innerHTML =
                `${Math.round(peakAvail).toLocaleString()}<span class="unit">MW</span>`;
            document.getElementById('statPeakAvailHour').textContent =
                `Hour ${peakAvailHr} (${HOUR_LABELS[peakAvailHr]})`;

            document.getElementById('statMinHeadroom').innerHTML =
                `${minEffHead >= 0 ? '+' : ''}${minEffHead.toLocaleString()}<span class="unit">MW</span>`;
            document.getElementById('statMinHeadroomHour').textContent =
                hasDemand ? `Hour ${minEffHeadHr} (${HOUR_LABELS[minEffHeadHr]})` : '--';
            document.getElementById('statMinHeadroom').style.color =
                minEffHead >= 0 ? '#22c55e' : '#ef4444';

            document.getElementById('statUtilization').innerHTML =
                hasDemand ? `${avgUtil.toFixed(1)}<span class="unit">%</span>` : `--<span class="unit">%</span>`;

            const hydro = HYDRO_INFO[year] || { type: '--', cls: '', detail: '' };
            document.getElementById('statHydroYear').innerHTML =
                `<span class="hydro-badge ${hydro.cls}">${hydro.type}</span>`;
            document.getElementById('statHydroSub').textContent = hydro.detail;

            // Update scatter plot (bidirectional) - show points from 0 to sliderIndex, split by year
            const visiblePoints = allScatterPoints.slice(0, sliderIndex + 1).filter(p => p !== null);
            const pointsByYear = { 2020: [], 2021: [], 2022: [], 2023: [], 2024: [], 2025: [] };
            for (const pt of visiblePoints) {
                const year = parseInt(pt.date.substring(0, 4));
                if (pointsByYear[year]) pointsByYear[year].push(pt);
            }
            scatterChart.data.datasets[0].data = pointsByYear[2020];
            scatterChart.data.datasets[1].data = pointsByYear[2021];
            scatterChart.data.datasets[2].data = pointsByYear[2022];
            scatterChart.data.datasets[3].data = pointsByYear[2023];
            scatterChart.data.datasets[4].data = pointsByYear[2024];
            scatterChart.data.datasets[5].data = pointsByYear[2025];
            scatterChart.update(isFirstUpdate ? 'resize' : 'none');

            // Update LMP vs Net Load scatter (accumulating, 24 points per day)
            const lmpCut = lmpCutoffs[sliderIndex] || 0;
            lmpNetLoadChart.data.datasets[0].data = allLmpNetPoints.slice(0, lmpCut);
            lmpNetLoadChart.data.datasets[0].backgroundColor = allLmpNetColors.slice(0, lmpCut);
            lmpNetLoadChart.data.datasets[0].borderColor = allLmpNetColors.slice(0, lmpCut);
            lmpNetLoadChart.data.datasets[0].pointRadius = allLmpNetRadii.slice(0, lmpCut);
            lmpNetLoadChart.update(isFirstUpdate ? 'resize' : 'none');

            // Update Generation Chart (EIA-930)
            const genDay = generationData[dateStr];
            const hasGen = genDay && Object.keys(genDay).length > 0;
            document.getElementById('noGenDataMsg').style.display = hasGen ? 'none' : 'flex';

            let genDsIdx = 0;
            for (const fuel of GEN_STACK_ORDER) {
                const hourly = (hasGen && genDay[fuel]) || new Array(24).fill(0);
                generationChart.data.datasets[genDsIdx].data = hourly;
                genDsIdx++;
            }
            // Demand overlay (reuse same demandArr already computed above)
            generationChart.data.datasets[genDsIdx].data = demandArr;
            generationChart.update(isFirstUpdate ? 'resize' : 'none');

            // Update optimized profile chart if computed
            if (optimizedResultCache && optimizedResultCache.dailyProfiles) {
                const hasDateData = optimizedResultCache.dailyProfiles[dateStr] !== undefined;
                const dailyProfile = hasDateData ? optimizedResultCache.dailyProfiles[dateStr] : optimizedResultCache.profile;

                // Show/hide missing date warning
                const msgEl = document.getElementById('optimizedMissingDateMsg');
                if (msgEl) {
                    msgEl.style.display = hasDateData ? 'none' : 'block';
                }

                optimizedChart.data.datasets[1].data = dailyProfile;
                optimizedChart.update(isFirstUpdate ? 'resize' : 'none');
            }

            // After first update, use 'none' mode for better performance
            if (isFirstUpdate) isFirstUpdate = false;
        }

        // ─── Slider & Controls ───────────────────────────────────────────
        const slider = document.getElementById('dateSlider');
        slider.addEventListener('input', () => updateCharts(parseInt(slider.value)));

        document.getElementById('datePicker').addEventListener('change', (e) => {
            const index = dateStrToIndex(e.target.value);
            slider.value = index;
            updateCharts(index);
        });

        document.getElementById('btnPrev').addEventListener('click', () => {
            slider.value = Math.max(0, parseInt(slider.value) - 1);
            updateCharts(parseInt(slider.value));
        });

        document.getElementById('btnNext').addEventListener('click', () => {
            slider.value = Math.min(2191, parseInt(slider.value) + 1);
            updateCharts(parseInt(slider.value));
        });

        document.getElementById('btnFirst').addEventListener('click', () => {
            slider.value = 0;
            updateCharts(0);
        });

        document.getElementById('btnLast').addEventListener('click', () => {
            slider.value = 2191;
            updateCharts(2191);
        });

        document.getElementById('btnReset').addEventListener('click', () => {
            slider.value = 0;
            updateCharts(0);
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                slider.value = Math.max(0, parseInt(slider.value) - 1);
                updateCharts(parseInt(slider.value));
            } else if (e.key === 'ArrowRight') {
                slider.value = Math.min(2191, parseInt(slider.value) + 1);
                updateCharts(parseInt(slider.value));
            } else if (e.key === ' ') {
                e.preventDefault();
                togglePlay();
            }
        });

        // Playback
        let playInterval = null;
        let playSpeed = 500;  // Default 1x speed

        // Get frame skip based on speed (skip more frames at higher speeds)
        function getFrameSkip(speed) {
            if (speed >= 500) return 1;      // 1x: update every day
            if (speed >= 30) return 2;       // 10x: skip 1, update every 2 days
            if (speed >= 15) return 5;       // 20x: skip 4, update every 5 days
            return 10;                        // 50x: skip 9, update every 10 days
        }

        function togglePlay() {
            const btn = document.getElementById('btnPlay');
            if (playInterval) {
                clearInterval(playInterval);
                playInterval = null;
                btn.innerHTML = '&#9654; Play';
                btn.classList.remove('active');
            } else {
                btn.innerHTML = '&#9646;&#9646; Pause';
                btn.classList.add('active');
                const frameSkip = getFrameSkip(playSpeed);
                playInterval = setInterval(() => {
                    let val = parseInt(slider.value) + frameSkip;
                    if (val > 2191) val = 0;
                    slider.value = val;
                    updateCharts(val);
                }, playSpeed);
            }
        }

        document.getElementById('btnPlay').addEventListener('click', togglePlay);

        document.querySelectorAll('.speed-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                playSpeed = parseInt(btn.dataset.speed);
                if (playInterval) {
                    clearInterval(playInterval);
                    const frameSkip = getFrameSkip(playSpeed);
                    playInterval = setInterval(() => {
                        let val = parseInt(slider.value) + frameSkip;
                        if (val > 2191) val = 0;
                        slider.value = val;
                        updateCharts(val);
                    }, playSpeed);
                }
            });
        });

        // ─── LMP vs Net Load Scatter (All Hours with Price Data) ────────
        const NON_GAS_RESOURCES = ['Solar', 'Wind', 'Hydro', 'Nuclear', 'Geothermal', 'Biomass', 'Other Thermal'];

        // LMP-headroom lookup table (memoized, computed once on first use)
        let lmpHeadroomLookup = null;

        // Size scaling: sqrt to compress the Jan 2023 outlier ($28.61)
        // range: ~1.5 (at $2.44) to ~8 (at $28.61)
        function gasPriceToRadius(gp) {
            return 1.0 + Math.sqrt(gp) * 1.2;
        }

        // Build dataset sorted by day index for accumulating display
        // allLmpNet*: flat arrays sorted chronologically; lmpCutoffs[i] = end index for slider day i
        const allLmpNetPoints = [];
        const allLmpNetColors = [];
        const allLmpNetRadii = [];
        const lmpCutoffs = new Array(2192).fill(0); // cumulative point count after each day
        let lmpNLMinX = Infinity, lmpNLMaxX = -Infinity;
        let lmpNLMinY = Infinity, lmpNLMaxY = -Infinity;

        // Hour-of-day color function (cyclic: blue→cyan→yellow→red→blue)
        function hourColor(h) {
            const t = h / 23;
            let r, g, b;
            if (t < 0.25) {
                const s = t / 0.25;
                r = Math.round(59 + s * (34 - 59));
                g = Math.round(130 + s * (211 - 130));
                b = Math.round(246 + s * (238 - 246));
            } else if (t < 0.5) {
                const s = (t - 0.25) / 0.25;
                r = Math.round(34 + s * (250 - 34));
                g = Math.round(211 + s * (204 - 211));
                b = Math.round(238 + s * (21 - 238));
            } else if (t < 0.75) {
                const s = (t - 0.5) / 0.25;
                r = Math.round(250 + s * (239 - 250));
                g = Math.round(204 + s * (68 - 204));
                b = Math.round(21 + s * (68 - 21));
            } else {
                const s = (t - 0.75) / 0.25;
                r = Math.round(239 + s * (59 - 239));
                g = Math.round(68 + s * (130 - 68));
                b = Math.round(68 + s * (246 - 68));
            }
            return `rgb(${r}, ${g}, ${b})`;
        }

        for (let i = 0; i <= 2191; i++) {
            const d = indexToDate(i);
            const ds = dateToStr(d);
            const y = String(d.getFullYear());
            const m = String(d.getMonth() + 1).padStart(2, '0');

            const pDay = priceData[ds];
            const capM = capacityData[y] && capacityData[y][m];
            const dem = demandData[ds];

            if (pDay && Object.keys(pDay).length > 0 && dem && capM) {
                const gasKey = `${y}-${m}`;
                const gasPrice = GAS_PRICES[gasKey] || 4.0;

                for (let h = 0; h < 24; h++) {
                    const hrData = pDay[String(h + 1)];
                    if (!hrData || hrData.LMP == null) continue;

                    const demVal = dem[h] || 0;
                    let nonGasCap = 0;
                    for (const res of NON_GAS_RESOURCES) {
                        const arr = capM[res];
                        if (arr) nonGasCap += arr[h];
                    }

                    const netLoad = (demVal - nonGasCap) / 1000;
                    const lmp = hrData.LMP;

                    let gasCap = 0;
                    for (const res of ['Gas CCGT', 'Gas Peaker', 'Gas Steam', 'Gas ICE']) {
                        const arr = capM[res];
                        if (arr) gasCap += arr[h];
                    }
                    const headroom = (gasCap - (demVal - nonGasCap)) / 1000;

                    lmpNLMinX = Math.min(lmpNLMinX, netLoad);
                    lmpNLMaxX = Math.max(lmpNLMaxX, netLoad);
                    lmpNLMinY = Math.min(lmpNLMinY, lmp);
                    lmpNLMaxY = Math.max(lmpNLMaxY, lmp);

                    allLmpNetPoints.push({
                        x: Math.round(netLoad * 100) / 100,
                        y: Math.round(lmp * 100) / 100,
                        date: ds,
                        hour: h,
                        gasPrice: gasPrice,
                        headroom: Math.round(headroom * 100) / 100
                    });
                    allLmpNetColors.push(hourColor(h));
                    allLmpNetRadii.push(gasPriceToRadius(gasPrice));
                }
            }
            lmpCutoffs[i] = allLmpNetPoints.length;
        }

        // Round axis limits
        lmpNLMinX = Math.floor(lmpNLMinX / 5) * 5;
        lmpNLMaxX = Math.ceil(lmpNLMaxX / 5) * 5;
        lmpNLMinY = Math.floor(lmpNLMinY / 50) * 50;
        lmpNLMaxY = Math.ceil(lmpNLMaxY / 50) * 50;

        const lmpNetCtx = document.getElementById('lmpNetLoadChart').getContext('2d');
        const lmpNetLoadChart = new Chart(lmpNetCtx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Hourly LMP',
                    data: [],
                    backgroundColor: [],
                    borderColor: [],
                    borderWidth: 0,
                    pointRadius: [],
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                onClick: (event, elements) => {
                    if (elements.length > 0) {
                        const pt = lmpNetLoadChart.data.datasets[0].data[elements[0].index];
                        if (pt && pt.date) {
                            const targetIndex = dateStrToIndex(pt.date);
                            slider.value = targetIndex;
                            updateCharts(targetIndex);
                        }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: '#1a1d2e',
                        titleColor: '#fff',
                        bodyColor: '#ccc',
                        borderColor: '#3a3d4e',
                        borderWidth: 1,
                        callbacks: {
                            title: () => '',
                            label: function(ctx) {
                                const pt = ctx.raw;
                                return [
                                    `${pt.date}  \u2022  ${HOUR_LABELS[pt.hour]} (Hour ${pt.hour})`,
                                    `LMP: $${pt.y.toFixed(2)}/MWh`,
                                    `Net Load: ${pt.x.toFixed(1)} GW`,
                                    `Eff. Headroom: ${pt.headroom.toFixed(1)} GW`,
                                    `CA Gas Citygate: $${pt.gasPrice.toFixed(2)}/MCF`
                                ];
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        ...commonScaleOpts,
                        title: { display: true, text: 'Net Load (GW) — Demand minus Solar, Wind, Hydro, Nuclear, Geothermal, Biomass, Waste Heat & Other Fossil', color: '#888', font: { size: 11 } },
                        min: lmpNLMinX,
                        max: lmpNLMaxX,
                    },
                    y: {
                        ...commonScaleOpts,
                        title: { display: true, text: 'LMP ($/MWh)', color: '#888', font: { size: 11 } },
                        min: lmpNLMinY,
                        max: lmpNLMaxY,
                    }
                }
            }
        });

        // ─── Data Center Load Flexibility Analysis ────────────────────
        // Solar capacity factor profiles (12 months × 24 hours)
        // Source: compute_available_capacity.py — p99 of EIA-930 actual generation / installed capacity
        const SOLAR_CF = [
            [0,0,0,0,0,0,0,0.033,0.399,0.722,0.787,0.778,0.771,0.781,0.79,0.712,0.661,0.491,0.175,0,0,0,0,0],
            [0,0,0,0,0,0,0,0.172,0.644,0.842,0.906,0.903,0.904,0.892,0.882,0.856,0.652,0.578,0.381,0.051,0,0,0,0],
            [0,0,0,0,0,0,0,0.333,0.732,0.873,0.922,0.932,0.939,0.932,0.95,0.967,0.902,0.788,0.703,0.509,0.141,0.011,0,0],
            [0,0,0,0,0,0,0,0.284,0.698,0.868,0.945,0.98,0.986,0.983,0.98,0.962,0.917,0.827,0.765,0.638,0.308,0.028,0,0],
            [0,0,0,0,0,0,0.05,0.421,0.759,0.879,0.944,0.974,0.98,0.977,0.974,0.963,0.929,0.868,0.806,0.705,0.404,0.08,0,0],
            [0,0,0,0,0,0,0.089,0.449,0.767,0.888,0.951,0.991,1.0,1.0,0.994,0.972,0.938,0.893,0.846,0.724,0.462,0.116,0,0],
            [0,0,0,0,0,0,0.026,0.343,0.702,0.862,0.936,0.975,0.994,0.997,0.989,0.972,0.941,0.904,0.845,0.726,0.461,0.11,0,0],
            [0,0,0,0,0,0,0,0.235,0.639,0.848,0.933,0.977,0.992,0.994,0.988,0.966,0.929,0.905,0.845,0.707,0.392,0.062,0,0],
            [0,0,0,0,0,0,0,0.116,0.559,0.818,0.905,0.941,0.949,0.951,0.947,0.936,0.905,0.859,0.796,0.558,0.162,0,0,0],
            [0,0,0,0,0,0,0,0.039,0.397,0.74,0.882,0.884,0.88,0.89,0.885,0.876,0.833,0.792,0.67,0.307,0.027,0,0,0],
            [0,0,0,0,0,0,0,0.184,0.604,0.79,0.832,0.833,0.832,0.828,0.822,0.802,0.799,0.735,0.484,0.101,0.013,0,0,0],
            [0,0,0,0,0,0,0,0.065,0.435,0.712,0.763,0.753,0.753,0.758,0.735,0.717,0.669,0.471,0.057,0.012,0,0,0,0],
        ];

        // Pre-compute mean-centered solar profiles for each month
        // so that camel/night profiles have the same total energy as flat
        const SOLAR_NORM = SOLAR_CF.map(month => {
            const mean = month.reduce((s, v) => s + v, 0) / 24;
            return month.map(v => v - mean);
        });

        // Custom profile state
        let customMultipliers = new Array(24).fill(1); // Relative shape; sum = 24 → same total energy as flat
        let isCustomActive = false;

        // Compute DC load profile for a given month (0-indexed)
        // type: 'flat', 'camel', 'night', 'custom'
        // Total daily energy is always preserved (= avgMw * 24 MWh)
        function computeDCProfile(avgMw, flex, monthIdx, type) {
            if (type === 'custom') {
                return customMultipliers.map(m => avgMw * m);
            }
            if (type === 'flat' || flex === 0) return new Array(24).fill(avgMw);
            const sign = type === 'camel' ? 1 : -1;
            const raw = new Array(24);
            for (let h = 0; h < 24; h++) {
                raw[h] = Math.max(0, avgMw * (1 + sign * flex * SOLAR_NORM[monthIdx][h] / 0.3));
            }
            // Rescale to preserve total energy (avgMw * 24)
            const rawSum = raw.reduce((s, v) => s + v, 0);
            const target = avgMw * 24;
            const scale = rawSum > 0 ? target / rawSum : 1;
            return raw.map(v => v * scale);
        }

        // Compute all DC analysis results
        function computeDCAnalysis(avgMw, flex) {
            const types = isCustomActive ? ['flat', 'camel', 'night', 'custom'] : ['flat', 'camel', 'night'];

            // Analysis 1: Headroom percentiles with each profile
            const baselineByHour = Array.from({length: 24}, () => []);
            const dcByHour = {};
            for (const t of types) dcByHour[t] = Array.from({length: 24}, () => []);

            // Analysis 2: Utilization + stress metrics
            const stats = {
                baseline: { utilSum: 0, utilCount: 0, allHeadrooms: [], stressHours: 0 },
            };
            for (const t of types) stats[t] = { utilSum: 0, utilCount: 0, allHeadrooms: [], stressHours: 0 };

            // Analysis 3: Cost
            const cost = {};
            for (const t of types) cost[t] = { lmpSum: 0, mwhSum: 0 };
            // Baseline: simple average LMP under historical grid conditions (no DC load)
            const baselineCost = { lmpSum: 0, mwhSum: 0 };

            // Build LMP-headroom lookup table once (memoized)
            if (!lmpHeadroomLookup) {
                lmpHeadroomLookup = buildLmpHeadroomLookup();
            }

            for (let i = 0; i <= 2191; i++) {
                const d = indexToDate(i);
                const ds = dateToStr(d);
                const y = String(d.getFullYear());
                const mStr = String(d.getMonth() + 1).padStart(2, '0');
                const monthIdx = d.getMonth();

                const capM = capacityData[y] && capacityData[y][mStr];
                const dem = demandData[ds];
                const hasDem = dem && dem.some(v => v !== null);
                if (!hasDem || !capM) continue;

                const demArr = dem.map(v => v || 0);
                const totAvail = getVisibleTotalAvail(capM);

                // Pre-compute DC profiles for this month
                const dcProfiles = {};
                for (const t of types) dcProfiles[t] = computeDCProfile(avgMw, flex, monthIdx, t);

                for (let h = 0; h < 24; h++) {
                    const avail = totAvail[h];
                    const demand = demArr[h];
                    const reserves = computeReserves(demArr)[h];
                    const baseHeadroom = avail - demand - reserves;
                    baselineByHour[h].push(baseHeadroom);

                    // Baseline utilization
                    if (avail > 0) {
                        stats.baseline.utilSum += demand / avail;
                        stats.baseline.utilCount++;
                    }
                    stats.baseline.allHeadrooms.push(baseHeadroom);
                    if (baseHeadroom < 3500) stats.baseline.stressHours++;

                    for (const t of types) {
                        const dcLoad = dcProfiles[t][h];
                        const newDem = demand + dcLoad;
                        const newReserves = computeReserves(new Array(24).fill(0).map((_, hh) => demArr[hh] + dcProfiles[t][hh]))[h];
                        const newHeadroom = avail - newDem - newReserves;
                        dcByHour[t][h].push(newHeadroom);

                        // Utilization
                        if (avail > 0) {
                            stats[t].utilSum += newDem / avail;
                            stats[t].utilCount++;
                        }
                        stats[t].allHeadrooms.push(newHeadroom);
                        if (newHeadroom < 3500) stats[t].stressHours++;
                    }
                }

                // Cost analysis (only days with price data)
                const pDay = priceData[ds];
                if (!pDay) continue;

                // Get gas price for this month (for denormalization)
                const month = d.getMonth() + 1;
                const monthKey = month < 10 ? '0' + month : String(month);
                const gasPrice = GAS_PRICES[monthKey] || 3.0;

                // Pre-compute reserves for baseline and DC profiles
                const baseReserves = computeReserves(demArr);
                const dcReserves = {};
                for (const t of types) {
                    const dcDemand = new Array(24).fill(0).map((_, hh) => demArr[hh] + dcProfiles[t][hh]);
                    dcReserves[t] = computeReserves(dcDemand);
                }

                for (let h = 0; h < 24; h++) {
                    const hrKey = String(h + 1);
                    const hrP = pDay[hrKey];
                    if (!hrP || hrP.LMP == null) continue;

                    const demand = demArr[h];
                    const avail = totAvail[h];
                    const reserve = baseReserves[h];

                    // Baseline headroom (no DC load)
                    const baseHeadroom = avail - demand - reserve;  // MW
                    const baseHeadroomBin = getHeadroomBin(baseHeadroom / 1000);  // GW
                    const baseNormLmp = lmpHeadroomLookup[h][baseHeadroomBin];
                    const baseLmp = baseNormLmp * gasPrice;  // Convert to $/MWh

                    // Baseline: simple average LMP under historical grid conditions (no DC)
                    baselineCost.lmpSum += baseLmp;
                    baselineCost.mwhSum += 1;  // Count of hours

                    // Each DC profile: compute adjusted LMP based on new headroom
                    for (const t of types) {
                        const dcLoad = dcProfiles[t][h];

                        // New headroom with DC load added
                        const newHeadroom = avail - (demand + dcLoad) - dcReserves[t][h];  // MW
                        const newHeadroomBin = getHeadroomBin(newHeadroom / 1000);  // GW
                        const newNormLmp = lmpHeadroomLookup[h][newHeadroomBin];
                        const adjustedLmp = newNormLmp * gasPrice;  // $/MWh

                        // Accumulate with adjusted LMP
                        cost[t].lmpSum += dcLoad * adjustedLmp;
                        cost[t].mwhSum += dcLoad;
                    }
                }
            }

            // Compute percentiles for headroom chart
            const headroomData = {
                baseline: { p5: [], p25: [], p50: [], p75: [], p95: [] }
            };
            for (let h = 0; h < 24; h++) {
                headroomData.baseline.p5.push(Math.round(percentile(baselineByHour[h], 5)));
                headroomData.baseline.p25.push(Math.round(percentile(baselineByHour[h], 25)));
                headroomData.baseline.p50.push(Math.round(percentile(baselineByHour[h], 50)));
                headroomData.baseline.p75.push(Math.round(percentile(baselineByHour[h], 75)));
                headroomData.baseline.p95.push(Math.round(percentile(baselineByHour[h], 95)));
            }
            for (const t of types) {
                headroomData[t] = { p50: [] };
                for (let h = 0; h < 24; h++) {
                    headroomData[t].p50.push(Math.round(percentile(dcByHour[t][h], 50)));
                }
            }

            // Compute scorecard metrics
            const baseUtil = stats.baseline.utilCount > 0 ? (stats.baseline.utilSum / stats.baseline.utilCount * 100) : 0;
            const scorecard = { baseline: {
                util: baseUtil,
                utilDelta: 0,
                p5Headroom: Math.round(percentile(stats.baseline.allHeadrooms, 5)),
                stressHours: stats.baseline.stressHours,
            }};
            for (const t of types) {
                const util = stats[t].utilCount > 0 ? (stats[t].utilSum / stats[t].utilCount * 100) : 0;
                scorecard[t] = {
                    util: util,
                    utilDelta: util - baseUtil,
                    p5Headroom: Math.round(percentile(stats[t].allHeadrooms, 5)),
                    stressHours: stats[t].stressHours,
                };
            }

            // Compute cost metrics ($/MWh)
            const costResults = {};
            // Baseline: simple average LMP under historical grid conditions (no DC)
            const bCount = baselineCost.mwhSum || 1;
            costResults.baseline = {
                mec: 0,  // No component breakdown for adjusted LMP
                mcc: 0,
                loss: 0,
                ghg: 0,
                lmp: baselineCost.lmpSum / bCount,
                annualCost: 0,  // No annual cost for baseline (no DC load)
            };
            for (const t of types) {
                const mwh = cost[t].mwhSum || 1;
                costResults[t] = {
                    mec: 0,  // No component breakdown for adjusted LMP
                    mcc: 0,
                    loss: 0,
                    ghg: 0,
                    lmp: cost[t].lmpSum / mwh,
                    annualCost: cost[t].lmpSum / mwh * avgMw * 8760 / 1e6,
                };
            }

            return { headroomData, scorecard, costResults };
        }

        // ─── Phase 2: Stress Day Computation ────────────────────────────
        function computeStressDays(avgMw, flex) {
            const types = isCustomActive ? ['flat', 'camel', 'night', 'custom'] : ['flat', 'camel', 'night'];
            const allDays = [];

            for (let i = 0; i <= 2191; i++) {
                const d = indexToDate(i);
                const ds = dateToStr(d);
                const y = String(d.getFullYear());
                const mStr = String(d.getMonth() + 1).padStart(2, '0');
                const monthIdx = d.getMonth();

                const capM = capacityData[y] && capacityData[y][mStr];
                const dem = demandData[ds];
                const hasDem = dem && dem.some(v => v !== null);
                if (!hasDem || !capM) continue;

                const demArr = dem.map(v => v || 0);
                const totAvail = getVisibleTotalAvail(capM);
                const baseReserves = computeReserves(demArr);

                const dcProfiles = {};
                const dcReserves = {};
                for (const t of types) {
                    dcProfiles[t] = computeDCProfile(avgMw, flex, monthIdx, t);
                    dcReserves[t] = computeReserves(demArr.map((dd, hh) => dd + dcProfiles[t][hh]));
                }

                const entry = { date: ds, headroom: { baseline: new Array(24) } };
                for (const t of types) entry.headroom[t] = new Array(24);

                for (let h = 0; h < 24; h++) {
                    const avail = totAvail[h];
                    const demand = demArr[h];
                    entry.headroom.baseline[h] = avail - demand - baseReserves[h];
                    for (const t of types) {
                        entry.headroom[t][h] = avail - (demand + dcProfiles[t][h]) - dcReserves[t][h];
                    }
                }

                entry.minBaseline = Math.min(...entry.headroom.baseline);
                allDays.push(entry);
            }

            allDays.sort((a, b) => a.minBaseline - b.minBaseline);
            const stressDays = allDays.slice(0, 100);

            const stressStats = {};
            for (const profile of ['baseline', ...types]) {
                const allMins = stressDays.map(d => Math.min(...d.headroom[profile]));
                let stressHours = 0;
                for (const d of stressDays) {
                    for (let h = 0; h < 24; h++) {
                        if (d.headroom[profile][h] < 3500) stressHours++;
                    }
                }
                stressStats[profile] = {
                    avgMinHeadroom: allMins.reduce((s, v) => s + v, 0) / allMins.length,
                    worstMin: Math.min(...allMins),
                    stressHours,
                };
            }

            return { stressDays, stressStats };
        }

        // ─── Phase 2: Curtailment Computation ───────────────────────────
        // Surplus = max(0, all_non_gas_generation - demand) per hour.
        // When surplus > 0, even with all gas plants off the grid overproduces.
        // In practice this surplus is curtailed (mostly solar, some wind).
        // Values are ANNUALIZED (divided by years of data).
        function computeCurtailment(avgMw, flex) {
            const types = isCustomActive ? ['flat', 'camel', 'night', 'custom'] : ['flat', 'camel', 'night'];
            const NON_GAS = ['Solar', 'Wind', 'Hydro', 'Nuclear', 'Geothermal', 'Coal', 'Oil', 'Other'];  // All non-gas generation
            const curtailByMonth = Array.from({length: 12}, () => {
                const absorbed = {};
                for (const t of types) absorbed[t] = 0;
                return { surplusMwh: 0, surplusHours: 0, days: 0, absorbed };
            });

            let totalDays = 0;

            for (let i = 0; i <= 2191; i++) {
                const d = indexToDate(i);
                const ds = dateToStr(d);
                const monthIdx = d.getMonth();

                const genDay = generationData[ds];  // Use actual EIA-930 generation data
                const dem = demandData[ds];
                const hasDem = dem && dem.some(v => v !== null);
                const hasGen = genDay && Object.keys(genDay).length > 0;
                if (!hasDem || !hasGen) continue;

                const demArr = dem.map(v => v || 0);
                const dcProfiles = {};
                for (const t of types) dcProfiles[t] = computeDCProfile(avgMw, flex, monthIdx, t);

                curtailByMonth[monthIdx].days++;
                totalDays++;

                for (let h = 0; h < 24; h++) {
                    // Sum all non-gas generation from EIA-930 actual data
                    let nonGasGen = 0;
                    for (const res of NON_GAS) {
                        const arr = genDay[res];
                        if (arr && arr[h] !== undefined) nonGasGen += arr[h];
                    }

                    const demand = demArr[h];
                    // Surplus occurs when non-gas generation exceeds demand
                    // This represents potential curtailment (excess must be curtailed or exported)
                    const surplus = Math.max(0, nonGasGen - demand);

                    if (surplus > 0) {
                        curtailByMonth[monthIdx].surplusHours++;
                        curtailByMonth[monthIdx].surplusMwh += surplus;
                        for (const t of types) {
                            curtailByMonth[monthIdx].absorbed[t] += Math.min(dcProfiles[t][h], surplus);
                        }
                    }
                }
            }

            // Annualize: divide accumulated totals by years of data
            const yearsOfData = totalDays / 365.25;

            const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            const monthly = monthNames.map((name, m) => {
                const absorbed = {};
                for (const t of types) absorbed[t] = curtailByMonth[m].absorbed[t] / 1000 / yearsOfData;
                return { name, surplusGwh: curtailByMonth[m].surplusMwh / 1000 / yearsOfData, absorbed };
            });

            const totalAbsorbed = {};
            for (const t of types) totalAbsorbed[t] = monthly.reduce((s, m) => s + m.absorbed[t], 0);
            const totals = {
                surplusGwh: monthly.reduce((s, m) => s + m.surplusGwh, 0),
                absorbed: totalAbsorbed,
                yearsOfData: Math.round(yearsOfData * 10) / 10,
            };

            return { monthly, totals };
        }

        // ─── Analysis 1: Headroom Impact Chart ──────────────────────────
        const dcHeadroomCtx = document.getElementById('dcHeadroomChart').getContext('2d');
        const dcHeadroomChart = new Chart(dcHeadroomCtx, {
            type: 'line',
            data: {
                labels: HOUR_LABELS,
                datasets: [
                    // Baseline percentile bands
                    { label: 'Baseline p5', data: [], borderColor: 'rgba(96,165,250,0.4)', backgroundColor: 'transparent', borderWidth: 1, borderDash: [4,4], pointRadius: 0, fill: false },
                    { label: 'Baseline p25-p75', data: [], borderColor: 'rgba(96,165,250,0.0)', backgroundColor: 'rgba(96,165,250,0.12)', borderWidth: 0, pointRadius: 0, fill: '+1' },
                    { label: 'Baseline p50', data: [], borderColor: 'rgba(96,165,250,0.6)', backgroundColor: 'transparent', borderWidth: 2, pointRadius: 0, fill: false },
                    { label: 'p75', data: [], borderColor: 'rgba(96,165,250,0.0)', backgroundColor: 'transparent', borderWidth: 0, pointRadius: 0, fill: false },
                    { label: 'Baseline p95', data: [], borderColor: 'rgba(96,165,250,0.4)', backgroundColor: 'rgba(96,165,250,0.06)', borderWidth: 1, borderDash: [4,4], pointRadius: 0, fill: '-1' },
                    // DC profile medians
                    { label: 'Flat DC (p50)', data: [], borderColor: '#60a5fa', backgroundColor: 'transparent', borderWidth: 2.5, borderDash: [8,4], pointRadius: 3, pointBackgroundColor: '#60a5fa', fill: false },
                    { label: 'Camel DC (p50)', data: [], borderColor: '#22c55e', backgroundColor: 'transparent', borderWidth: 2.5, borderDash: [8,4], pointRadius: 3, pointBackgroundColor: '#22c55e', fill: false },
                    { label: 'Night-Heavy DC (p50)', data: [], borderColor: '#ef4444', backgroundColor: 'transparent', borderWidth: 2.5, borderDash: [8,4], pointRadius: 3, pointBackgroundColor: '#ef4444', fill: false },
                    { label: 'Custom DC (p50)', data: [], borderColor: '#a855f7', backgroundColor: 'transparent', borderWidth: 2.5, borderDash: [8,4], pointRadius: 3, pointBackgroundColor: '#a855f7', fill: false, hidden: true },
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: { color: '#888', usePointStyle: true, padding: 16, font: { size: 11 },
                            filter: (item) => ['Baseline p50', 'Flat DC (p50)', 'Camel DC (p50)', 'Night-Heavy DC (p50)', 'Custom DC (p50)', 'Baseline p25-p75'].includes(item.text)
                        }
                    },
                    tooltip: {
                        backgroundColor: '#1a1d2e', titleColor: '#fff', bodyColor: '#ccc',
                        borderColor: '#3a3d4e', borderWidth: 1,
                        callbacks: {
                            label: function(ctx) {
                                return `${ctx.dataset.label}: ${(ctx.parsed.y / 1000).toFixed(1)} GW`;
                            }
                        }
                    }
                },
                scales: {
                    x: { ...commonScaleOpts },
                    y: {
                        ...commonScaleOpts,
                        title: { display: true, text: 'Effective Headroom (MW)', color: '#888', font: { size: 11 } },
                    }
                }
            }
        });

        // ─── Analysis 3: Cost Comparison Chart ──────────────────────────
        const dcCostCtx = document.getElementById('dcCostChart').getContext('2d');
        const dcCostChart = new Chart(dcCostCtx, {
            type: 'bar',
            data: {
                labels: ['Baseline (No DC)', 'Flat', 'Camel (Solar)', 'Night-Heavy', 'Custom'],
                datasets: [{
                    label: 'Adjusted LMP',
                    data: [],
                    backgroundColor: 'rgba(96,165,250,0.8)',
                    borderColor: '#60a5fa',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },  // Single series, no legend needed
                    tooltip: {
                        backgroundColor: '#1a1d2e', titleColor: '#fff', bodyColor: '#ccc',
                        borderColor: '#3a3d4e', borderWidth: 1,
                        callbacks: {
                            label: function(ctx) {
                                return `LMP: $${ctx.parsed.y.toFixed(2)}/MWh`;
                            }
                        }
                    }
                },
                scales: {
                    x: { ...commonScaleOpts },
                    y: {
                        ...commonScaleOpts,
                        title: { display: true, text: 'Electricity Cost ($/MWh)', color: '#888', font: { size: 11 } },
                        min: 0
                    }
                }
            }
        });

        // ─── Phase 2: Stress Day Heatmap ──────────────────────────────
        const HEAT_CELL_W = 28, HEAT_CELL_H = 6;
        const HEAT_LEFT = 80, HEAT_TOP = 24, HEAT_RIGHT = 80, HEAT_BOTTOM = 20;
        let stressProfile = 'flat';
        let stressDaysCache = null, stressStatsCache = null;
        let stressRelativeMode = false;

        // ─── Optimized Profile Cache ────────────────────────────────
        let optimizedResultCache = null;
        let costResults = null;  // Store cost results for optimization comparison

        function headroomColor(mw) {
            // -5000 MW → red, 10000 → yellow, 25000 → blue
            const t = Math.max(0, Math.min(1, (mw + 5000) / 30000));
            let r, g, b;
            if (t < 0.33) {
                const s = t / 0.33;
                r = 220; g = Math.round(60 + 160 * s); b = Math.round(60 * (1 - s));
            } else if (t < 0.66) {
                const s = (t - 0.33) / 0.33;
                r = Math.round(220 - 186 * s); g = Math.round(220 - 23 * s); b = Math.round(94 * s);
            } else {
                const s = (t - 0.66) / 0.34;
                r = Math.round(34 + 62 * s); g = Math.round(197 - 32 * s); b = Math.round(94 + 156 * s);
            }
            return `rgb(${r},${g},${b})`;
        }

        // Criticality color scale for relative mode
        // Shows how concerning the final headroom level is with DC added
        // Red = critical stress (< 3.5 GW), Yellow/White = moderate (3.5-10 GW), Blue = comfortable (> 15 GW)
        function criticalityColor(headroomMw) {
            let r, g, b;

            if (headroomMw < 3500) {
                // Critical: < 3.5 GW → deep red to orange
                const t = Math.max(0, Math.min(1, headroomMw / 3500));  // 0 at 0 MW, 1 at 3500 MW
                r = 220;
                g = Math.round(40 + 140 * t);  // 40 → 180
                b = Math.round(40 + 40 * t);   // 40 → 80
            } else if (headroomMw < 10000) {
                // Moderate: 3.5-10 GW → orange to yellow to white
                const t = (headroomMw - 3500) / 6500;  // 0 at 3500, 1 at 10000
                r = Math.round(220 + 35 * t);  // 220 → 255
                g = Math.round(180 + 75 * t);  // 180 → 255
                b = Math.round(80 + 175 * t);  // 80 → 255
            } else if (headroomMw < 15000) {
                // Comfortable: 10-15 GW → white to light blue
                const t = (headroomMw - 10000) / 5000;  // 0 at 10000, 1 at 15000
                r = Math.round(255 - 100 * t);  // 255 → 155
                g = Math.round(255 - 50 * t);   // 255 → 205
                b = 255;
            } else {
                // Very comfortable: > 15 GW → light blue to deep blue
                const t = Math.min(1, (headroomMw - 15000) / 10000);  // 0 at 15000, 1 at 25000
                r = Math.round(155 - 91 * t);  // 155 → 64
                g = Math.round(205 - 52 * t);  // 205 → 153
                b = 255;
            }

            return `rgb(${r},${g},${b})`;
        }

        function drawStressHeatmap() {
            if (!stressDaysCache) return;
            const days = stressDaysCache;
            const stats = stressStatsCache;
            const profile = stressProfile;
            const canvas = document.getElementById('stressHeatmap');
            const ctx = canvas.getContext('2d');
            const ROWS = days.length;

            const dpr = window.devicePixelRatio || 1;
            const cssW = HEAT_LEFT + 24 * HEAT_CELL_W + HEAT_RIGHT;
            const cssH = HEAT_TOP + ROWS * HEAT_CELL_H + HEAT_BOTTOM;
            canvas.width = cssW * dpr;
            canvas.height = cssH * dpr;
            canvas.style.width = cssW + 'px';
            canvas.style.height = cssH + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            ctx.fillStyle = '#1a1d2e';
            ctx.fillRect(0, 0, cssW, cssH);

            // Hour labels
            ctx.fillStyle = '#888';
            ctx.font = '10px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            for (let h = 0; h < 24; h += 3) {
                ctx.fillText(HOUR_LABELS[h], HEAT_LEFT + h * HEAT_CELL_W + HEAT_CELL_W / 2, HEAT_TOP - 6);
            }

            // Draw cells
            for (let r = 0; r < ROWS; r++) {
                const headrooms = days[r].headroom[profile];

                for (let c = 0; c < 24; c++) {
                    if (stressRelativeMode && profile !== 'baseline') {
                        // Criticality mode: show how concerning the final headroom level is
                        ctx.fillStyle = criticalityColor(headrooms[c]);
                    } else {
                        // Absolute mode: show actual headroom with full scale
                        ctx.fillStyle = headroomColor(headrooms[c]);
                    }
                    ctx.fillRect(HEAT_LEFT + c * HEAT_CELL_W, HEAT_TOP + r * HEAT_CELL_H, HEAT_CELL_W - 1, HEAT_CELL_H - 1);
                }
                // Date label every 10 rows
                if (r % 10 === 0) {
                    ctx.fillStyle = '#666';
                    ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                    ctx.textAlign = 'right';
                    ctx.fillText(days[r].date, HEAT_LEFT - 6, HEAT_TOP + r * HEAT_CELL_H + HEAT_CELL_H);
                }
            }

            // Color legend bar on right
            const lx = HEAT_LEFT + 24 * HEAT_CELL_W + 15;
            const ly = HEAT_TOP;
            const lh = ROWS * HEAT_CELL_H;

            if (stressRelativeMode && profile !== 'baseline') {
                // Criticality mode legend: blue (comfortable) → white (moderate) → red (critical)
                for (let py = 0; py < lh; py++) {
                    const mw = 25000 - 25000 * (py / lh);  // 25000 at top → 0 at bottom
                    ctx.fillStyle = criticalityColor(mw);
                    ctx.fillRect(lx, ly + py, 12, 1);
                }
                ctx.fillStyle = '#888';
                ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('25 GW', lx + 16, ly + 8);
                ctx.fillStyle = '#60a5fa';
                ctx.fillText('Comfortable', lx + 16, ly + 20);
                ctx.fillStyle = '#888';
                ctx.fillText('10 GW', lx + 16, ly + lh * 0.4 + 4);
                ctx.fillStyle = '#e8e8e8';
                ctx.fillText('Moderate', lx + 16, ly + lh * 0.4 + 16);
                ctx.fillStyle = '#888';
                ctx.fillText('3.5 GW', lx + 16, ly + lh * 0.66 + 4);
                ctx.fillStyle = '#ef8844';
                ctx.fillText('Stressed', lx + 16, ly + lh * 0.66 + 16);
                ctx.fillStyle = '#888';
                ctx.fillText('0 GW', lx + 16, ly + lh - 8);
                ctx.fillStyle = '#dc2626';
                ctx.fillText('Critical', lx + 16, ly + lh);
            } else {
                // Absolute mode legend: red → yellow → blue
                for (let py = 0; py < lh; py++) {
                    const mw = -5000 + 30000 * (1 - py / lh);
                    ctx.fillStyle = headroomColor(mw);
                    ctx.fillRect(lx, ly + py, 12, 1);
                }
                ctx.fillStyle = '#888';
                ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('25 GW', lx + 16, ly + 8);
                ctx.fillText('10 GW', lx + 16, ly + lh * 0.5 + 4);
                ctx.fillText('-5 GW', lx + 16, ly + lh);
            }

            // Summary cards
            const el = document.getElementById('stressSummary');
            const s = stats[profile];
            const b = stats.baseline;
            const isBase = profile === 'baseline';
            el.innerHTML = `
                <div class="stress-summary-card">
                    <div class="ss-title">Avg Min Headroom</div>
                    <div class="ss-value">${(s.avgMinHeadroom / 1000).toFixed(1)} GW</div>
                    <div class="ss-sub">${!isBase ? `Baseline: ${(b.avgMinHeadroom / 1000).toFixed(1)} GW \u2022 \u0394${((s.avgMinHeadroom - b.avgMinHeadroom) / 1000).toFixed(1)} GW` : '100 most-stressed days'}</div>
                </div>
                <div class="stress-summary-card">
                    <div class="ss-title">Worst Single Hour</div>
                    <div class="ss-value">${(s.worstMin / 1000).toFixed(1)} GW</div>
                    <div class="ss-sub">${!isBase ? `Baseline: ${(b.worstMin / 1000).toFixed(1)} GW` : 'Minimum headroom in dataset'}</div>
                </div>
                <div class="stress-summary-card">
                    <div class="ss-title">Stress Hours (&lt;3.5 GW)</div>
                    <div class="ss-value">${s.stressHours.toLocaleString()}</div>
                    <div class="ss-sub">${!isBase ? `Baseline: ${b.stressHours.toLocaleString()} (${s.stressHours > b.stressHours ? '+' : ''}${s.stressHours - b.stressHours})` : `of ${days.length * 24} total hours`}</div>
                </div>
            `;
        }

        // Heatmap tooltip
        const heatmapTip = document.createElement('div');
        heatmapTip.style.cssText = 'position:fixed;background:#1a1d2e;border:1px solid #3a3d4e;border-radius:6px;padding:6px 10px;color:#ccc;font-size:11px;pointer-events:none;display:none;z-index:100;white-space:nowrap;';
        document.body.appendChild(heatmapTip);

        document.getElementById('stressHeatmap').addEventListener('mousemove', function(e) {
            if (!stressDaysCache) return;
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left, y = e.clientY - rect.top;
            const col = Math.floor((x - HEAT_LEFT) / HEAT_CELL_W);
            const row = Math.floor((y - HEAT_TOP) / HEAT_CELL_H);
            if (col >= 0 && col < 24 && row >= 0 && row < stressDaysCache.length) {
                const d = stressDaysCache[row];
                const mw = d.headroom[stressProfile][col];
                const baseMw = d.headroom.baseline[col];
                const delta = mw - baseMw;

                heatmapTip.style.display = 'block';
                heatmapTip.style.left = (e.clientX + 12) + 'px';
                heatmapTip.style.top = (e.clientY - 30) + 'px';

                if (stressRelativeMode && stressProfile !== 'baseline') {
                    // Criticality mode: show final headroom level and criticality status
                    let criticality = '';
                    let critColor = '';
                    if (mw < 3500) {
                        criticality = 'CRITICAL';
                        critColor = '#dc2626';
                    } else if (mw < 10000) {
                        criticality = 'Stressed';
                        critColor = '#ef8844';
                    } else if (mw < 15000) {
                        criticality = 'Moderate';
                        critColor = '#e8e8e8';
                    } else {
                        criticality = 'Comfortable';
                        critColor = '#60a5fa';
                    }
                    heatmapTip.innerHTML = `<b>${d.date}</b> \u2022 ${HOUR_LABELS[col]}<br>Headroom with DC: <span style="color:${critColor};font-weight:600;">${(mw / 1000).toFixed(1)} GW (${criticality})</span><br><span style="color:#888;font-size:10px;">Baseline: ${(baseMw / 1000).toFixed(1)} GW | Change: ${delta >= 0 ? '+' : ''}${(delta / 1000).toFixed(1)} GW</span>`;
                } else {
                    heatmapTip.innerHTML = `<b>${d.date}</b> \u2022 ${HOUR_LABELS[col]}<br>Headroom: ${(mw / 1000).toFixed(1)} GW (${Math.round(mw)} MW)`;
                }
            } else {
                heatmapTip.style.display = 'none';
            }
        });
        document.getElementById('stressHeatmap').addEventListener('mouseleave', () => { heatmapTip.style.display = 'none'; });

        // Stress tab handlers
        document.querySelectorAll('.stress-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const profile = tab.dataset.profile;
                // Guard: if custom data not computed, ignore click
                if (profile === 'custom' && stressDaysCache && stressDaysCache[0] && !stressDaysCache[0].headroom.custom) return;
                document.querySelectorAll('.stress-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                stressProfile = profile;
                drawStressHeatmap();
            });
        });

        // Relative mode checkbox handler
        document.getElementById('stressRelativeMode').addEventListener('change', function(e) {
            stressRelativeMode = e.target.checked;
            drawStressHeatmap();
        });

        // ─── Phase 2: Curtailment Chart ─────────────────────────────────
        const curtailCtx = document.getElementById('curtailChart').getContext('2d');
        const curtailChart = new Chart(curtailCtx, {
            type: 'bar',
            data: {
                labels: ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],
                datasets: [
                    { label: 'Estimated Surplus', type: 'line', data: [], borderColor: 'rgba(200,200,200,0.8)', borderWidth: 2, pointRadius: 3, pointBackgroundColor: '#999', backgroundColor: 'rgba(200,200,200,0.08)', fill: true, order: 0, tension: 0.3 },
                    { label: 'Absorbed: Flat DC', data: [], backgroundColor: 'rgba(96,165,250,0.7)', borderColor: '#60a5fa', borderWidth: 1, order: 1 },
                    { label: 'Absorbed: Camel DC', data: [], backgroundColor: 'rgba(34,197,94,0.7)', borderColor: '#22c55e', borderWidth: 1, order: 1 },
                    { label: 'Absorbed: Night DC', data: [], backgroundColor: 'rgba(239,68,68,0.5)', borderColor: '#ef4444', borderWidth: 1, order: 1 },
                    { label: 'Absorbed: Custom DC', data: [], backgroundColor: 'rgba(168,85,247,0.6)', borderColor: '#a855f7', borderWidth: 1, order: 1, hidden: true },
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: true, position: 'top', labels: { color: '#888', usePointStyle: true, padding: 16, font: { size: 11 } } },
                    tooltip: {
                        backgroundColor: '#1a1d2e', titleColor: '#fff', bodyColor: '#ccc',
                        borderColor: '#3a3d4e', borderWidth: 1,
                        callbacks: {
                            label: function(ctx) {
                                return `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(0)} GWh/yr`;
                            }
                        }
                    }
                },
                scales: {
                    x: { ...commonScaleOpts },
                    y: {
                        ...commonScaleOpts,
                        title: { display: true, text: 'Annualized Energy (GWh/yr)', color: '#888', font: { size: 11 } },
                    }
                }
            }
        });

        function renderCurtailment(result) {
            const { monthly, totals } = result;
            curtailChart.data.datasets[0].data = monthly.map(m => m.surplusGwh);
            curtailChart.data.datasets[1].data = monthly.map(m => m.absorbed.flat);
            curtailChart.data.datasets[2].data = monthly.map(m => m.absorbed.camel);
            curtailChart.data.datasets[3].data = monthly.map(m => m.absorbed.night);
            // Custom dataset
            curtailChart.data.datasets[4].hidden = !isCustomActive;
            curtailChart.data.datasets[4].data = isCustomActive ? monthly.map(m => m.absorbed.custom) : [];
            curtailChart.update();

            const avgMw = parseInt(document.getElementById('dcSizeSlider').value);
            const el = document.getElementById('curtailStats');
            el.style.gridTemplateColumns = `repeat(${isCustomActive ? 5 : 4}, 1fr)`;
            const pct = (t) => totals.surplusGwh > 0 ? (totals.absorbed[t] / totals.surplusGwh * 100) : 0;

            const CURTAIL_BORDER = { flat: '#60a5fa', camel: '#22c55e', night: '#ef4444', custom: '#a855f7' };
            const CURTAIL_LABEL = { flat: 'Flat DC Absorbs', camel: 'Camel DC Absorbs', night: 'Night DC Absorbs', custom: 'Custom DC Absorbs' };
            const curtailTypes = isCustomActive ? ['flat', 'camel', 'night', 'custom'] : ['flat', 'camel', 'night'];

            let html = `
                <div class="curtail-card" style="border-color:#888;">
                    <div class="ct-title">Est. Annual Surplus</div>
                    <div class="ct-value">${(totals.surplusGwh / 1000).toFixed(1)} TWh/yr</div>
                    <div class="ct-sub">Avg over ${totals.yearsOfData} years of data</div>
                </div>`;
            for (const t of curtailTypes) {
                html += `
                <div class="curtail-card" style="border-color:${CURTAIL_BORDER[t]};">
                    <div class="ct-title">${CURTAIL_LABEL[t]}</div>
                    <div class="ct-value">${(totals.absorbed[t] / 1000).toFixed(2)} TWh/yr</div>
                    <div class="ct-sub">${pct(t).toFixed(1)}% of surplus at ${avgMw} MW</div>
                </div>`;
            }
            el.innerHTML = html;
        }

        // ─── Phase 3: Marginal Emissions Computation ───────────────────
        const GAS_MERIT_ORDER = [
            { type: 'Gas CCGT', rate: 0.41 },
            { type: 'Gas Steam', rate: 0.55 },
            { type: 'Gas ICE', rate: 0.50 },
            { type: 'Gas Peaker', rate: 0.63 },
        ];
        const NON_GAS_RES_EMISSIONS = ['Solar', 'Wind', 'Hydro', 'Nuclear', 'Geothermal', 'Biomass', 'Other Thermal'];

        function computeMarginalEmissions(avgMw, flex) {
            const types = isCustomActive ? ['flat', 'camel', 'night', 'custom'] : ['flat', 'camel', 'night'];
            // Hourly marginal rate accumulation (for chart)
            const rateByHour = Array.from({length: 24}, () => ({ sum: 0, count: 0 }));
            // Per-profile accumulation (totals + hourly breakdown)
            const profileData = {};
            for (const t of types) {
                profileData[t] = { co2Sum: 0, mwhSum: 0 };
                profileData[t].hourly = Array.from({length: 24}, () => ({ co2: 0, count: 0 }));
            }

            let totalDays = 0;

            for (let i = 0; i <= 2191; i++) {
                const d = indexToDate(i);
                const ds = dateToStr(d);
                const y = String(d.getFullYear());
                const mStr = String(d.getMonth() + 1).padStart(2, '0');
                const monthIdx = d.getMonth();

                const capM = capacityData[y] && capacityData[y][mStr];
                const dem = demandData[ds];
                const hasDem = dem && dem.some(v => v !== null);
                if (!hasDem || !capM) continue;

                const demArr = dem.map(v => v || 0);
                const dcProfiles = {};
                for (const t of types) dcProfiles[t] = computeDCProfile(avgMw, flex, monthIdx, t);

                totalDays++;

                for (let h = 0; h < 24; h++) {
                    // Compute non-gas generation
                    let nonGasGen = 0;
                    for (const res of NON_GAS_RES_EMISSIONS) {
                        const arr = capM[res];
                        if (arr) nonGasGen += arr[h];
                    }

                    const demand = demArr[h];
                    const gasResidual = Math.max(0, demand - nonGasGen);

                    // Walk gas merit order to find marginal rate
                    let marginalRate = 0;
                    if (gasResidual > 0) {
                        let remaining = gasResidual;
                        let lastRate = GAS_MERIT_ORDER[0].rate;
                        for (const g of GAS_MERIT_ORDER) {
                            const cap = (capM[g.type] && capM[g.type][h]) || 0;
                            lastRate = g.rate;
                            if (remaining <= cap) break;
                            remaining -= cap;
                        }
                        marginalRate = lastRate;
                    }
                    // If gasResidual = 0 → surplus → marginal rate = 0 (RE curtailed)

                    rateByHour[h].sum += marginalRate;
                    rateByHour[h].count++;

                    for (const t of types) {
                        const hourCO2 = dcProfiles[t][h] * marginalRate;
                        profileData[t].co2Sum += hourCO2;
                        profileData[t].mwhSum += dcProfiles[t][h];
                        profileData[t].hourly[h].co2 += hourCO2;
                        profileData[t].hourly[h].count++;
                    }
                }
            }

            const yearsOfData = totalDays / 365.25;
            const avgRateByHour = rateByHour.map(r => r.count > 0 ? r.sum / r.count : 0);

            const results = {};
            for (const t of types) {
                const mwh = profileData[t].mwhSum || 1;
                // Avg daily CO2 per hour (tCO2/hr) for chart
                const hourlyCO2 = profileData[t].hourly.map(h =>
                    h.count > 0 ? h.co2 / h.count : 0
                );
                results[t] = {
                    avgRate: profileData[t].co2Sum / mwh,
                    annualCO2: profileData[t].co2Sum / yearsOfData / 1000, // kt CO2/year
                    hourlyCO2, // avg tCO2/hr at each hour of day
                };
            }

            return { avgRateByHour, results, yearsOfData };
        }

        // ─── Optimized Load Profile ────────────────────────────────────
        function computeOptimizedProfile(avgMw, flex) {
            console.log(`Computing optimized load profiles for ${avgMw} MW, flex=${flex}...`);

            // Adaptive increment size: larger for bigger DCs (reduces iterations)
            const INCREMENT_MW = avgMw <= 1000 ? 50 : avgMw <= 2500 ? 100 : 200;
            const totalMWh = avgMw * 24;  // Total energy to allocate per day
            const numIncrements = Math.ceil(totalMWh / INCREMENT_MW);

            // Accumulate average optimized profile across all days
            const avgOptimizedProfile = new Array(24).fill(0);
            const dailyOptimizedProfiles = {};  // Store each day's profile
            let validDays = 0;
            let totalOptCost = 0, totalFlatCost = 0, totalCamelCost = 0;

            for (let i = 0; i <= 2191; i++) {
                const d = indexToDate(i);
                const ds = dateToStr(d);
                const y = String(d.getFullYear());
                const mStr = String(d.getMonth() + 1).padStart(2, '0');
                const monthIdx = d.getMonth();

                const capM = capacityData[y] && capacityData[y][mStr];
                const dem = demandData[ds];
                const pDay = priceData[ds];
                const hasDem = dem && dem.some(v => v !== null);
                if (!hasDem || !capM || !pDay) continue;

                const demArr = dem.map(v => v || 0);
                const totAvail = getVisibleTotalAvail(capM);

                // Get gas price for this month
                const month = d.getMonth() + 1;
                const monthKey = month < 10 ? '0' + month : String(month);
                const gasPrice = GAS_PRICES[monthKey] || 3.0;

                // Initialize optimized load allocation
                const optLoad = new Array(24).fill(0);
                let allocatedMWh = 0;

                // Iterative greedy allocation with hourly capacity constraint
                const MAX_HOURLY_LOAD = avgMw * 3;  // No hour can exceed 3× average DC capacity

                for (let iter = 0; iter < numIncrements; iter++) {
                    let bestHour = 0;
                    let bestCost = Infinity;

                    // Try adding INCREMENT_MW to each hour, find lowest marginal cost
                    for (let h = 0; h < 24; h++) {
                        // Skip hours that have reached capacity limit
                        if (optLoad[h] + INCREMENT_MW > MAX_HOURLY_LOAD) {
                            continue;
                        }

                        const testLoad = [...optLoad];
                        testLoad[h] += INCREMENT_MW;

                        // Compute headroom with this allocation
                        const testDemand = demArr.map((d, hh) => d + testLoad[hh]);
                        const testReserves = computeReserves(testDemand);
                        const headroom = totAvail[h] - testDemand[h] - testReserves[h];

                        // Lookup marginal LMP for this headroom
                        const bin = getHeadroomBin(headroom / 1000);
                        const normLmp = lmpHeadroomLookup[h][bin];
                        const marginalLMP = normLmp * gasPrice;

                        const marginalCost = INCREMENT_MW * marginalLMP;

                        if (marginalCost < bestCost) {
                            bestCost = marginalCost;
                            bestHour = h;
                        }
                    }

                    // Allocate to best hour (if valid hour found)
                    if (bestCost < Infinity) {
                        optLoad[bestHour] += INCREMENT_MW;
                        allocatedMWh += INCREMENT_MW;
                    } else {
                        // All hours at capacity - shouldn't happen with proper sizing
                        console.warn(`Day ${ds}: All hours at capacity at iteration ${iter}/${numIncrements}`);
                        break;
                    }
                }

                // Rescale to exactly match avgMw × 24 (handle rounding)
                const actualSum = optLoad.reduce((s, v) => s + v, 0);
                const scale = totalMWh / actualSum;
                for (let h = 0; h < 24; h++) {
                    optLoad[h] *= scale;
                }

                // Accumulate for average profile
                for (let h = 0; h < 24; h++) {
                    avgOptimizedProfile[h] += optLoad[h];
                }

                // Store daily profile
                dailyOptimizedProfiles[ds] = [...optLoad];

                // Compute costs for this day (optimized vs flat vs camel)
                const flatProfile = new Array(24).fill(avgMw);
                const camelProfile = computeDCProfile(avgMw, flex, monthIdx, 'camel');

                for (const [profile, load] of [['opt', optLoad], ['flat', flatProfile], ['camel', camelProfile]]) {
                    const testDemand = demArr.map((d, hh) => d + load[hh]);
                    const testReserves = computeReserves(testDemand);

                    let costSum = 0, mwhSum = 0;
                    for (let h = 0; h < 24; h++) {
                        const headroom = totAvail[h] - testDemand[h] - testReserves[h];
                        const bin = getHeadroomBin(headroom / 1000);
                        const normLmp = lmpHeadroomLookup[h][bin];
                        const lmp = normLmp * gasPrice;

                        costSum += load[h] * lmp;
                        mwhSum += load[h];
                    }

                    const avgCost = mwhSum > 0 ? costSum / mwhSum : 0;
                    if (profile === 'opt') totalOptCost += avgCost;
                    else if (profile === 'flat') totalFlatCost += avgCost;
                    else if (profile === 'camel') totalCamelCost += avgCost;
                }

                validDays++;
            }

            // Compute average profile
            for (let h = 0; h < 24; h++) {
                avgOptimizedProfile[h] /= validDays;
            }

            // Compute average costs
            const avgOptCost = totalOptCost / validDays;
            const avgFlatCost = totalFlatCost / validDays;
            const avgCamelCost = totalCamelCost / validDays;

            console.log(`Optimized profile computed across ${validDays} days`);
            console.log(`Avg costs: Opt=$${avgOptCost.toFixed(2)}/MWh, Flat=$${avgFlatCost.toFixed(2)}/MWh, Camel=$${avgCamelCost.toFixed(2)}/MWh`);

            return {
                profile: avgOptimizedProfile,
                dailyProfiles: dailyOptimizedProfiles,
                costs: {
                    optimized: avgOptCost,
                    flat: avgFlatCost,
                    camel: avgCamelCost,
                },
                validDays
            };
        }

        // ─── Phase 3: Emissions Chart ─────────────────────────────────
        const emissionsCtx = document.getElementById('emissionsChart').getContext('2d');
        const emissionsChart = new Chart(emissionsCtx, {
            type: 'line',
            data: {
                labels: HOUR_LABELS,
                datasets: [
                    // Right y-axis: marginal rate (tCO2/MWh) — context line
                    { label: 'Marginal Rate (tCO\u2082/MWh)', data: [], yAxisID: 'yRate', borderColor: 'rgba(200,200,200,0.5)', backgroundColor: 'rgba(200,200,200,0.06)', borderWidth: 1.5, borderDash: [6,3], pointRadius: 0, fill: true, tension: 0.3, order: 1 },
                    // Left y-axis: per-profile hourly emissions (tCO2/hr)
                    { label: 'Flat DC', data: [], yAxisID: 'y', borderColor: '#60a5fa', backgroundColor: 'transparent', borderWidth: 2.5, pointRadius: 3, pointBackgroundColor: '#60a5fa', fill: false, tension: 0.3, order: 0 },
                    { label: 'Camel DC', data: [], yAxisID: 'y', borderColor: '#22c55e', backgroundColor: 'transparent', borderWidth: 2.5, pointRadius: 3, pointBackgroundColor: '#22c55e', fill: false, tension: 0.3, order: 0 },
                    { label: 'Night-Heavy DC', data: [], yAxisID: 'y', borderColor: '#ef4444', backgroundColor: 'transparent', borderWidth: 2.5, pointRadius: 3, pointBackgroundColor: '#ef4444', fill: false, tension: 0.3, order: 0 },
                    { label: 'Custom DC', data: [], yAxisID: 'y', borderColor: '#a855f7', backgroundColor: 'transparent', borderWidth: 2.5, pointRadius: 3, pointBackgroundColor: '#a855f7', fill: false, tension: 0.3, order: 0, hidden: true },
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: true, position: 'top', labels: { color: '#888', usePointStyle: true, padding: 16, font: { size: 11 } } },
                    tooltip: {
                        backgroundColor: '#1a1d2e', titleColor: '#fff', bodyColor: '#ccc',
                        borderColor: '#3a3d4e', borderWidth: 1,
                        callbacks: {
                            label: function(ctx) {
                                if (ctx.datasetIndex === 0) {
                                    return `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(3)}`;
                                }
                                return `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(1)} tCO\u2082/hr`;
                            }
                        }
                    }
                },
                scales: {
                    x: { ...commonScaleOpts },
                    y: {
                        ...commonScaleOpts,
                        position: 'left',
                        title: { display: true, text: 'Avg Hourly Emissions (tCO\u2082/hr)', color: '#888', font: { size: 11 } },
                        min: 0,
                    },
                    yRate: {
                        ...commonScaleOpts,
                        position: 'right',
                        title: { display: true, text: 'Marginal Rate (tCO\u2082/MWh)', color: '#888', font: { size: 11 } },
                        min: 0,
                        max: 0.7,
                        grid: { drawOnChartArea: false },
                    }
                }
            }
        });

        // ─── Optimized Profile Chart ──────────────────────────────────
        const optimizedCtx = document.getElementById('optimizedChart').getContext('2d');
        const optimizedChart = new Chart(optimizedCtx, {
            type: 'bar',
            data: {
                labels: HOUR_LABELS,
                datasets: [
                    {
                        label: 'Average Optimized Profile',
                        data: new Array(24).fill(0),
                        backgroundColor: 'rgba(150, 150, 150, 0.25)',
                        borderColor: 'rgba(150, 150, 150, 0.5)',
                        borderWidth: 1,
                        order: 2
                    },
                    {
                        label: 'Daily Optimized Load',
                        data: new Array(24).fill(0),
                        backgroundColor: 'rgba(168, 85, 247, 0.7)',
                        borderColor: '#a855f7',
                        borderWidth: 1,
                        order: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: { color: '#888', font: { size: 11 }, usePointStyle: true, padding: 12 }
                    },
                    tooltip: {
                        backgroundColor: '#1a1d2e',
                        titleColor: '#fff',
                        bodyColor: '#ccc',
                        borderColor: '#3a3d4e',
                        borderWidth: 1,
                        callbacks: {
                            label: function(ctx) {
                                return `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(0)} MW`;
                            }
                        }
                    }
                },
                scales: {
                    x: { ...commonScaleOpts },
                    y: {
                        ...commonScaleOpts,
                        title: { display: true, text: 'Load (MW)', color: '#888', font: { size: 11 } },
                        min: 0
                    }
                }
            }
        });

        // ─── Generation Chart (EIA-930) ────────────────────────────────
        const genCtx = document.getElementById('generationChart').getContext('2d');
        const genDatasets = [];

        for (const fuel of GEN_STACK_ORDER) {
            const c = GEN_COLORS[fuel];
            genDatasets.push({
                label: fuel,
                data: new Array(24).fill(0),
                backgroundColor: c.bg,
                borderColor: c.border,
                borderWidth: 1,
                stack: 'generation',
                order: 2,
            });
        }

        // Demand overlay line
        genDatasets.push({
            label: 'Demand',
            data: new Array(24).fill(0),
            type: 'line',
            borderColor: '#ef4444',
            borderWidth: 3,
            pointRadius: 3,
            pointBackgroundColor: '#ef4444',
            fill: false,
            tension: 0.3,
            order: 1,
        });

        const generationChart = new Chart(genCtx, {
            type: 'bar',
            data: { labels: HOUR_LABELS, datasets: genDatasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: { color: '#ccc', font: { size: 11 }, usePointStyle: true, pointStyleWidth: 16, padding: 12 }
                    },
                    tooltip: {
                        backgroundColor: '#1a1d2e',
                        titleColor: '#fff',
                        bodyColor: '#ccc',
                        borderColor: '#3a3d4e',
                        borderWidth: 1,
                        callbacks: {
                            label: function(ctx) {
                                const val = ctx.parsed.y;
                                if (val === 0 && ctx.dataset.label !== 'Demand') return null;
                                return `${ctx.dataset.label}: ${val.toLocaleString()} MW`;
                            }
                        }
                    }
                },
                scales: {
                    x: { ...commonScaleOpts, stacked: true },
                    y: {
                        ...commonScaleOpts,
                        stacked: true,
                        title: { display: true, text: 'MW', color: '#888' },
                        min: 0,
                        max: 75000,
                    }
                }
            }
        });

        function renderEmissions(emResult) {
            const { avgRateByHour, results } = emResult;
            // Marginal rate context line (right axis)
            emissionsChart.data.datasets[0].data = avgRateByHour;
            // Per-profile hourly emissions (left axis)
            emissionsChart.data.datasets[1].data = results.flat ? results.flat.hourlyCO2 : [];
            emissionsChart.data.datasets[2].data = results.camel ? results.camel.hourlyCO2 : [];
            emissionsChart.data.datasets[3].data = results.night ? results.night.hourlyCO2 : [];
            emissionsChart.data.datasets[4].hidden = !isCustomActive;
            emissionsChart.data.datasets[4].data = (isCustomActive && results.custom) ? results.custom.hourlyCO2 : [];
            emissionsChart.update();

            const avgMw = parseInt(document.getElementById('dcSizeSlider').value);
            const el = document.getElementById('emissionsStats');
            const avgBaseline = avgRateByHour.reduce((s, v) => s + v, 0) / 24;

            const EM_LABEL = { flat: 'Flat DC', camel: 'Camel DC', night: 'Night DC', custom: 'Custom DC' };
            const EM_BORDER = { baseline: '#888', flat: '#60a5fa', camel: '#22c55e', night: '#ef4444', custom: '#a855f7' };
            const profileTypes = isCustomActive ? ['flat', 'camel', 'night', 'custom'] : ['flat', 'camel', 'night'];
            el.style.gridTemplateColumns = `repeat(${profileTypes.length + 1}, 1fr)`;

            let html = `
                <div class="emissions-card" style="border-color:${EM_BORDER.baseline};">
                    <div class="em-title">Baseline Marginal Rate</div>
                    <div class="em-value">${avgBaseline.toFixed(3)} tCO\u2082/MWh</div>
                    <div class="em-sub">Avg across all hours</div>
                </div>`;

            for (const t of profileTypes) {
                const r = results[t];
                const savings = results.flat.annualCO2 - r.annualCO2;
                html += `
                <div class="emissions-card" style="border-color:${EM_BORDER[t]};">
                    <div class="em-title">${EM_LABEL[t]}</div>
                    <div class="em-value">${r.avgRate.toFixed(3)} tCO\u2082/MWh</div>
                    <div class="em-sub">${r.annualCO2.toFixed(0)} ktCO\u2082/yr at ${avgMw} MW${t !== 'flat' ? ` (${savings > 0 ? '-' : '+'}${Math.abs(savings).toFixed(0)} vs Flat)` : ''}</div>
                </div>`;
            }
            el.innerHTML = html;
        }

        function renderOptimized(optResult) {
            const { profile, dailyProfiles, costs, validDays } = optResult;
            const avgMw = parseInt(document.getElementById('dcSizeSlider').value);

            // Cache result for date scrubber
            optimizedResultCache = optResult;

            // Compute max load across all days for fixed y-axis
            let maxLoad = Math.max(...profile);
            for (const dayProfile of Object.values(dailyProfiles)) {
                maxLoad = Math.max(maxLoad, ...dayProfile);
            }

            // Add 20% headroom for visual clarity
            const yMax = Math.ceil(maxLoad * 1.2);
            console.log(`Optimized chart y-axis max: ${yMax} MW (based on actual max load: ${maxLoad.toFixed(0)} MW)`);

            // Update chart with average profile and current date's daily profile
            const currentDateStr = dateToStr(indexToDate(parseInt(document.getElementById('dateSlider').value)));
            const hasCurrentDateData = dailyProfiles[currentDateStr] !== undefined;
            const dailyProfile = hasCurrentDateData ? dailyProfiles[currentDateStr] : profile;  // Use average if date missing

            // Show/hide missing date warning
            const msgEl = document.getElementById('optimizedMissingDateMsg');
            if (msgEl) {
                msgEl.style.display = hasCurrentDateData ? 'none' : 'block';
            }

            optimizedChart.data.datasets[0].data = profile;  // Average
            optimizedChart.data.datasets[1].data = dailyProfile;  // Current date (or average if missing)
            optimizedChart.options.scales.y.max = yMax;  // Fix y-axis max
            optimizedChart.update();

            // Render comparison cards
            const el = document.getElementById('optimizedStats');

            // Get baseline cost from global costResults (already computed by renderDCAnalysis)
            const baselineCost = costResults.baseline ? costResults.baseline.lmp : costs.flat;

            // Calculate savings (positive means more expensive than optimized)
            const baselineSavings = baselineCost - costs.optimized;
            const flatSavings = costs.flat - costs.optimized;
            const camelSavings = costs.camel - costs.optimized;

            const baselineAnnual = baselineCost * avgMw * 8760 / 1e6;
            const flatAnnual = costs.flat * avgMw * 8760 / 1e6;
            const camelAnnual = costs.camel * avgMw * 8760 / 1e6;
            const optimizedAnnual = costs.optimized * avgMw * 8760 / 1e6;

            const baselineAnnualSavings = baselineSavings * avgMw * 8760 / 1e6;
            const flatAnnualSavings = flatSavings * avgMw * 8760 / 1e6;
            const camelAnnualSavings = camelSavings * avgMw * 8760 / 1e6;

            const html = `
                <div class="dc-scorecard-row" style="grid-template-columns: repeat(4, 1fr); margin-bottom: 0;">
                    <div class="dc-score-card baseline">
                        <div class="card-title">Baseline (Flat 500 MW)</div>
                        <div class="card-metric">
                            <div class="metric-val">$${baselineCost.toFixed(2)}</div>
                            <span class="metric-label">$/MWh</span>
                        </div>
                        <div class="card-metric">
                            <div style="font-size: 16px; color: #ccc;">$${baselineAnnual.toFixed(1)}M/yr</div>
                        </div>
                        ${baselineSavings > 0 ? `
                        <div class="card-metric">
                            <span class="metric-delta negative">+$${baselineAnnualSavings.toFixed(1)}M/yr vs Opt</span>
                        </div>` : ''}
                    </div>

                    <div class="dc-score-card flat">
                        <div class="card-title">Flat Profile</div>
                        <div class="card-metric">
                            <div class="metric-val">$${costs.flat.toFixed(2)}</div>
                            <span class="metric-label">$/MWh</span>
                        </div>
                        <div class="card-metric">
                            <div style="font-size: 16px; color: #ccc;">$${flatAnnual.toFixed(1)}M/yr</div>
                        </div>
                        ${flatSavings > 0 ? `
                        <div class="card-metric">
                            <span class="metric-delta negative">+$${flatAnnualSavings.toFixed(1)}M/yr vs Opt</span>
                        </div>` : ''}
                    </div>

                    <div class="dc-score-card camel">
                        <div class="card-title">Camel (Solar-Following)</div>
                        <div class="card-metric">
                            <div class="metric-val">$${costs.camel.toFixed(2)}</div>
                            <span class="metric-label">$/MWh</span>
                        </div>
                        <div class="card-metric">
                            <div style="font-size: 16px; color: #ccc;">$${camelAnnual.toFixed(1)}M/yr</div>
                        </div>
                        ${camelSavings > 0 ? `
                        <div class="card-metric">
                            <span class="metric-delta negative">+$${camelAnnualSavings.toFixed(1)}M/yr vs Opt</span>
                        </div>` : camelSavings < 0 ? `
                        <div class="card-metric">
                            <span class="metric-delta positive">$${Math.abs(camelAnnualSavings).toFixed(1)}M/yr better</span>
                        </div>` : ''}
                    </div>

                    <div class="dc-score-card optimized">
                        <div class="card-title">⚡ Optimized</div>
                        <div class="card-metric">
                            <div class="metric-val">$${costs.optimized.toFixed(2)}</div>
                            <span class="metric-label">$/MWh</span>
                        </div>
                        <div class="card-metric">
                            <div style="font-size: 16px; color: #ccc;">$${optimizedAnnual.toFixed(1)}M/yr</div>
                        </div>
                        <div class="card-metric">
                            <span class="metric-label" style="color: #22c55e;">Lowest Cost</span>
                        </div>
                    </div>
                </div>
                <p style="text-align:center; margin-top:12px; font-size:12px; color:#888;">
                    Computed across ${validDays.toLocaleString()} days with complete data (2020-2025) at <strong>${avgMw} MW</strong> DC size.
                    Optimized profile allocates load to minimize cost while meeting ${avgMw} MW × 24h = ${(avgMw * 24).toLocaleString()} MWh/day.
                </p>
                <p style="text-align:center; margin-top:4px; font-size:11px; color:#666;">
                    💡 Compare these costs with "Electricity Cost Comparison" chart above (now also showing ${avgMw} MW).
                    Camel costs may differ slightly due to preset flex ratio vs your custom flex setting.
                </p>
            `;
            el.innerHTML = html;
        }

        // ─── Phase 3: Custom Profile Canvas Editor ────────────────────
        const EDITOR_LEFT = 50, EDITOR_TOP = 10, EDITOR_RIGHT = 10, EDITOR_BOTTOM = 30;
        let editorDragging = false;

        function drawCustomEditor() {
            const canvas = document.getElementById('customProfileCanvas');
            const ctx = canvas.getContext('2d');
            const avgMw = parseInt(document.getElementById('dcSizeSlider').value);

            const dpr = window.devicePixelRatio || 1;
            const cssW = canvas.parentElement.clientWidth - 32; // account for padding
            const cssH = 180;
            canvas.width = cssW * dpr;
            canvas.height = cssH * dpr;
            canvas.style.width = cssW + 'px';
            canvas.style.height = cssH + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            const plotW = cssW - EDITOR_LEFT - EDITOR_RIGHT;
            const plotH = cssH - EDITOR_TOP - EDITOR_BOTTOM;
            const barW = plotW / 24;

            // Background
            ctx.fillStyle = '#0e1019';
            ctx.fillRect(0, 0, cssW, cssH);

            // Y-axis: 0 to maxMw
            const maxMultiplier = Math.max(2, ...customMultipliers) * 1.1;
            const maxMw = maxMultiplier * avgMw;

            // Grid lines
            ctx.strokeStyle = '#1a1d2e';
            ctx.lineWidth = 1;
            const ySteps = 4;
            for (let i = 0; i <= ySteps; i++) {
                const y = EDITOR_TOP + plotH * (1 - i / ySteps);
                ctx.beginPath();
                ctx.moveTo(EDITOR_LEFT, y);
                ctx.lineTo(cssW - EDITOR_RIGHT, y);
                ctx.stroke();

                ctx.fillStyle = '#666';
                ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(`${Math.round(maxMw * i / ySteps)}`, EDITOR_LEFT - 4, y + 3);
            }

            // Average line
            const avgY = EDITOR_TOP + plotH * (1 - 1 / maxMultiplier);
            ctx.strokeStyle = 'rgba(96,165,250,0.4)';
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(EDITOR_LEFT, avgY);
            ctx.lineTo(cssW - EDITOR_RIGHT, avgY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw bars
            for (let h = 0; h < 24; h++) {
                const x = EDITOR_LEFT + h * barW;
                const barH = plotH * (customMultipliers[h] / maxMultiplier);
                const y = EDITOR_TOP + plotH - barH;

                ctx.fillStyle = 'rgba(168,85,247,0.7)';
                ctx.fillRect(x + 1, y, barW - 2, barH);

                // Hour labels
                if (h % 3 === 0) {
                    ctx.fillStyle = '#888';
                    ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(HOUR_LABELS[h], x + barW / 2, cssH - 5);
                }
            }

            // Update stats readout
            const peak = Math.max(...customMultipliers) * avgMw;
            const min = Math.min(...customMultipliers) * avgMw;
            document.getElementById('customStats').textContent = `Peak: ${Math.round(peak)} MW | Min: ${Math.round(min)} MW | Avg: ${avgMw} MW`;
        }

        function editorHitToHour(e) {
            const canvas = document.getElementById('customProfileCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const plotW = (canvas.style.width ? parseInt(canvas.style.width) : canvas.clientWidth) - EDITOR_LEFT - EDITOR_RIGHT;
            const barW = plotW / 24;
            const col = Math.floor((x - EDITOR_LEFT) / barW);
            return col >= 0 && col < 24 ? col : -1;
        }

        function editorHitToMultiplier(e) {
            const canvas = document.getElementById('customProfileCanvas');
            const rect = canvas.getBoundingClientRect();
            const y = e.clientY - rect.top;
            const cssH = parseInt(canvas.style.height) || 180;
            const plotH = cssH - EDITOR_TOP - EDITOR_BOTTOM;
            const maxMultiplier = Math.max(2, ...customMultipliers) * 1.1;
            const frac = 1 - (y - EDITOR_TOP) / plotH;
            return Math.max(0, Math.min(maxMultiplier, frac * maxMultiplier));
        }

        function normalizeCustomMultipliers() {
            const sum = customMultipliers.reduce((s, v) => s + v, 0);
            if (sum > 0) {
                const scale = 24 / sum;
                for (let h = 0; h < 24; h++) customMultipliers[h] *= scale;
            }
        }

        function onEditorMouseDown(e) {
            editorDragging = true;
            const h = editorHitToHour(e);
            if (h >= 0) {
                customMultipliers[h] = editorHitToMultiplier(e);
                drawCustomEditor();
            }
        }
        function onEditorMouseMove(e) {
            if (!editorDragging) return;
            const h = editorHitToHour(e);
            if (h >= 0) {
                customMultipliers[h] = editorHitToMultiplier(e);
                drawCustomEditor();
            }
        }
        function onEditorMouseUp() {
            if (!editorDragging) return;
            editorDragging = false;
            normalizeCustomMultipliers();
            drawCustomEditor();
            renderDCAnalysis();
        }

        const customCanvas = document.getElementById('customProfileCanvas');
        customCanvas.addEventListener('mousedown', onEditorMouseDown);
        customCanvas.addEventListener('mousemove', onEditorMouseMove);
        customCanvas.addEventListener('mouseup', onEditorMouseUp);
        customCanvas.addEventListener('mouseleave', onEditorMouseUp);

        document.getElementById('customResetBtn').addEventListener('click', () => {
            customMultipliers = new Array(24).fill(1);
            drawCustomEditor();
            renderDCAnalysis();
        });

        // ─── Render DC Analysis ─────────────────────────────────────────
        function renderDCAnalysis() {
            const avgMw = parseInt(document.getElementById('dcSizeSlider').value);
            const flex = parseInt(document.getElementById('dcFlexSlider').value) / 100;
            document.getElementById('dcSizeVal').textContent = `${avgMw} MW`;
            document.getElementById('dcFlexVal').textContent = flex.toFixed(2);

            const result = computeDCAnalysis(avgMw, flex);
            const headroomData = result.headroomData;
            const scorecard = result.scorecard;
            costResults = result.costResults;  // Update global costResults

            // Update headroom chart
            dcHeadroomChart.data.datasets[0].data = headroomData.baseline.p5;
            dcHeadroomChart.data.datasets[1].data = headroomData.baseline.p25;
            dcHeadroomChart.data.datasets[2].data = headroomData.baseline.p50;
            dcHeadroomChart.data.datasets[3].data = headroomData.baseline.p75;
            dcHeadroomChart.data.datasets[4].data = headroomData.baseline.p95;
            dcHeadroomChart.data.datasets[5].data = headroomData.flat.p50;
            dcHeadroomChart.data.datasets[6].data = headroomData.camel.p50;
            dcHeadroomChart.data.datasets[7].data = headroomData.night.p50;
            // Custom headroom line
            dcHeadroomChart.data.datasets[8].hidden = !isCustomActive;
            dcHeadroomChart.data.datasets[8].data = isCustomActive ? headroomData.custom.p50 : [];
            const allVals = [...headroomData.baseline.p5, ...headroomData.night.p50];
            if (isCustomActive && headroomData.custom) allVals.push(...headroomData.custom.p50);
            dcHeadroomChart.options.scales.y.min = Math.floor(Math.min(...allVals) / 5000) * 5000;
            dcHeadroomChart.options.scales.y.max = Math.ceil(Math.max(...headroomData.baseline.p95) / 5000) * 5000;
            dcHeadroomChart.update();

            // Update scorecard
            const scorecardEl = document.getElementById('dcScorecard');
            function fmtDelta(val, unit, invert) {
                const positive = invert ? val < 0 : val > 0;
                const cls = positive ? 'positive' : 'negative';
                const arrow = val > 0 ? '\u2191' : val < 0 ? '\u2193' : '';
                return `<span class="metric-delta ${cls}">${arrow}${Math.abs(val).toFixed(unit === '%' ? 2 : 0)}${unit}</span>`;
            }
            const cards = [
                { key: 'baseline', cls: 'baseline', title: 'Baseline (No DC)' },
                { key: 'flat', cls: 'flat', title: 'Flat Profile' },
                { key: 'camel', cls: 'camel', title: 'Camel (Solar)' },
                { key: 'night', cls: 'night', title: 'Night-Heavy' },
            ];
            if (isCustomActive) cards.push({ key: 'custom', cls: 'custom', title: 'Custom Profile' });
            scorecardEl.style.gridTemplateColumns = `repeat(${cards.length}, 1fr)`;

            scorecardEl.innerHTML = cards.map(c => {
                const s = scorecard[c.key];
                const isBase = c.key === 'baseline';
                return `<div class="dc-score-card ${c.cls}">
                    <div class="card-title">${c.title}</div>
                    <div class="card-metric">
                        <span class="metric-val">${s.util.toFixed(2)}%</span>
                        ${!isBase ? fmtDelta(s.utilDelta, '%', false) : ''}
                        <span class="metric-label">Avg Utilization</span>
                    </div>
                    <div class="card-metric">
                        <span class="metric-val">${(s.p5Headroom / 1000).toFixed(1)} GW</span>
                        ${!isBase ? fmtDelta((s.p5Headroom - scorecard.baseline.p5Headroom) / 1000, ' GW', true) : ''}
                        <span class="metric-label">Min Headroom (p5)</span>
                    </div>
                    <div class="card-metric">
                        <span class="metric-val">${s.stressHours.toLocaleString()}</span>
                        ${!isBase ? fmtDelta(s.stressHours - scorecard.baseline.stressHours, '', true) : ''}
                        <span class="metric-label">Stress Hours (&lt;3.5 GW)</span>
                    </div>
                </div>`;
            }).join('');

            // Update cost chart (includes baseline bar)
            const types = isCustomActive ? ['flat', 'camel', 'night', 'custom'] : ['flat', 'camel', 'night'];
            const costBarTypes = ['baseline', ...types];
            const costBarLabels = costBarTypes.map(t => t === 'baseline' ? 'Baseline (No DC)' : t === 'flat' ? 'Flat' : t === 'camel' ? 'Camel (Solar)' : t === 'night' ? 'Night-Heavy' : 'Custom');
            dcCostChart.data.labels = costBarLabels;
            dcCostChart.data.datasets[0].data = costBarTypes.map(t => costResults[t].lmp);
            dcCostChart.update();

            // Update cost summary cards
            const costEl = document.getElementById('dcCostSummary');
            const costCardTypes = ['baseline', ...types];
            costEl.style.gridTemplateColumns = `repeat(${costCardTypes.length}, 1fr)`;
            const PROFILE_BORDER = { baseline: '#888', flat: '#60a5fa', camel: '#22c55e', night: '#ef4444', custom: '#a855f7' };
            const PROFILE_LABEL = { baseline: 'Baseline (No DC)', flat: 'Flat', camel: 'Camel (Solar)', night: 'Night-Heavy', custom: 'Custom' };
            costEl.innerHTML = costCardTypes.map(t => {
                const c = costResults[t];
                const isBase = t === 'baseline';
                const isFlat = t === 'flat';
                // Compare each profile to Flat (standard DC profile)
                const diff = (!isBase && !isFlat) ? c.annualCost - costResults.flat.annualCost : null;
                return `<div class="dc-cost-card" style="border-color:${PROFILE_BORDER[t]};">
                    <div class="cost-title">${PROFILE_LABEL[t]}</div>
                    <div class="cost-main">$${c.lmp.toFixed(2)}/MWh</div>
                    <div class="cost-sub">${isBase ? 'Avg grid LMP (no DC)' : `$${c.annualCost.toFixed(0)}M/year at ${avgMw} MW`}</div>
                    ${diff !== null ? `<div class="cost-savings" style="color:${diff > 0 ? '#ef4444' : '#22c55e'};">${diff > 0 ? '+' : ''}$${diff.toFixed(0)}M/yr vs Flat</div>` : ''}
                </div>`;
            }).join('');

            // Phase 2: Stress Day Deep-Dive
            const stressResult = computeStressDays(avgMw, flex);
            stressDaysCache = stressResult.stressDays;
            stressStatsCache = stressResult.stressStats;
            drawStressHeatmap();

            // Phase 2: Curtailment Absorption
            const curtailResult = computeCurtailment(avgMw, flex);
            renderCurtailment(curtailResult);

            // Phase 3: Marginal Emissions
            const emResult = computeMarginalEmissions(avgMw, flex);
            renderEmissions(emResult);

            // Update custom editor if visible
            if (isCustomActive) drawCustomEditor();
        }

        // ─── DC Controls Event Listeners ────────────────────────────────
        document.getElementById('dcSizeSlider').addEventListener('input', (e) => {
            // Sync with optimized DC size input
            document.getElementById('optimizedDcSize').value = e.target.value;
            renderDCAnalysis();
        });
        document.getElementById('dcFlexSlider').addEventListener('input', renderDCAnalysis);

        document.querySelectorAll('.dc-preset-btn[data-type]').forEach(btn => {
            btn.addEventListener('click', () => {
                const type = btn.dataset.type;
                if (type === 'custom') {
                    // Toggle custom mode on/off
                    if (isCustomActive) {
                        // Hide custom editor and switch to Camel preset
                        isCustomActive = false;
                        document.getElementById('customEditorContainer').style.display = 'none';
                        document.querySelectorAll('.dc-preset-btn[data-type]').forEach(b => b.classList.remove('active'));
                        document.querySelector('.dc-preset-btn[data-type="camel"]').classList.add('active');
                        document.getElementById('dcFlexSlider').value = 70;
                        renderDCAnalysis();
                    } else {
                        // Show custom editor
                        isCustomActive = true;
                        document.getElementById('customEditorContainer').style.display = '';
                        document.querySelectorAll('.dc-preset-btn[data-type]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        drawCustomEditor();
                        renderDCAnalysis();
                    }
                    // Update sticky positions after editor is shown/hidden
                    setTimeout(() => window.updateStickyPositions(), 50);
                } else {
                    isCustomActive = false;
                    document.getElementById('customEditorContainer').style.display = 'none';
                    document.querySelectorAll('.dc-preset-btn[data-type]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    if (type === 'flat') {
                        document.getElementById('dcFlexSlider').value = 0;
                    } else {
                        document.getElementById('dcFlexSlider').value = 70;
                    }
                    renderDCAnalysis();
                    // Update sticky positions after editor is hidden
                    setTimeout(() => window.updateStickyPositions(), 50);
                }
            });
        });

        // ─── DC Controls Sticky Behavior ─────────────────────────────────
        const dcControls = document.getElementById('dcControls');
        const customEditorContainer = document.getElementById('customEditorContainer');
        const sliderSection = document.querySelector('.slider-section');
        const dcControlsOriginalTop = dcControls.offsetTop;
        let dcControlsHeight = dcControls.offsetHeight;
        let customEditorHeight = 0;

        // Create placeholders to prevent layout shift when controls become fixed
        const dcPlaceholder = document.createElement('div');
        dcPlaceholder.style.display = 'none';
        dcControls.parentNode.insertBefore(dcPlaceholder, dcControls);

        const customPlaceholder = document.createElement('div');
        customPlaceholder.style.display = 'none';
        customEditorContainer.parentNode.insertBefore(customPlaceholder, customEditorContainer);

        window.updateStickyPositions = function() {
            const scrollY = window.scrollY || window.pageYOffset;
            const sliderSectionHeight = sliderSection ? sliderSection.offsetHeight : 0;
            const stickyTopPosition = sliderSectionHeight + 10; // 10px gap below slider section
            const isCustomVisible = customEditorContainer.style.display !== 'none';

            customEditorHeight = isCustomVisible ? customEditorContainer.offsetHeight : 0;
            const totalHeight = dcControlsHeight + (isCustomVisible ? customEditorHeight : 0);

            if (scrollY > dcControlsOriginalTop - stickyTopPosition) {
                // Show sticky controls
                if (!dcControls.classList.contains('sticky')) {
                    dcControls.classList.add('sticky');
                    dcControls.style.top = stickyTopPosition + 'px';
                    dcPlaceholder.style.height = totalHeight + 'px';
                    dcPlaceholder.style.display = 'block';
                }

                // Position custom editor right below DC controls if visible
                if (isCustomVisible && !customEditorContainer.classList.contains('sticky')) {
                    customEditorContainer.classList.add('sticky');
                    customEditorContainer.style.top = (stickyTopPosition + dcControlsHeight) + 'px';
                } else if (!isCustomVisible && customEditorContainer.classList.contains('sticky')) {
                    customEditorContainer.classList.remove('sticky');
                }
            } else {
                // Hide sticky controls
                if (dcControls.classList.contains('sticky')) {
                    dcControls.classList.remove('sticky');
                    customEditorContainer.classList.remove('sticky');
                    dcPlaceholder.style.display = 'none';
                }
            }
        }

        window.addEventListener('scroll', window.updateStickyPositions);

        // Update height on window resize
        window.addEventListener('resize', () => {
            dcControlsHeight = dcControls.offsetHeight;
            window.updateStickyPositions();
        });

        // ─── Optimized Profile Event Listeners ──────────────────────────
        // Trigger button to reveal form
        document.getElementById('optimizedTriggerBtn').addEventListener('click', () => {
            document.getElementById('optimizedFormContainer').style.display = '';
            document.querySelector('.optimized-trigger-container').style.display = 'none';
        });

        // Sync optimized DC size with main slider
        document.getElementById('optimizedDcSize').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('dcSizeSlider').value = value;
            document.getElementById('dcSizeVal').textContent = `${value} MW`;
            // Note: Don't trigger renderDCAnalysis here to avoid lag during typing
        });

        // Calculate button
        document.getElementById('optimizedCalculateBtn').addEventListener('click', async () => {
            const avgMw = parseInt(document.getElementById('optimizedDcSize').value);
            const flex = parseInt(document.getElementById('dcFlexSlider').value) / 100;
            const btn = document.getElementById('optimizedCalculateBtn');
            const loadingMsg = document.getElementById('optimizedLoadingMsg');
            const resultsContainer = document.getElementById('optimizedResultsContainer');

            // Sync main slider and update main analyses (so costs are comparable)
            document.getElementById('dcSizeSlider').value = avgMw;
            document.getElementById('dcSizeVal').textContent = `${avgMw} MW`;

            // Disable button, show loading
            btn.disabled = true;
            document.getElementById('calculateBtnText').textContent = 'Computing...';
            loadingMsg.style.display = '';
            resultsContainer.style.display = 'none';

            // Yield to UI thread to show loading state
            await new Promise(resolve => setTimeout(resolve, 100));

            try {
                // Update main DC analyses first (so costs are at same DC size)
                renderDCAnalysis();

                // Then run optimization (using same flex as main chart)
                const optResult = computeOptimizedProfile(avgMw, flex);

                // Render results
                renderOptimized(optResult);

                // Show results, hide loading
                loadingMsg.style.display = 'none';
                resultsContainer.style.display = '';
            } catch (error) {
                console.error('Optimization error:', error);
                alert('An error occurred during optimization. Please try again.');
            } finally {
                // Re-enable button
                btn.disabled = false;
                document.getElementById('calculateBtnText').textContent = 'Calculate Optimal Profile';
            }
        });

        // Initial DC render
        renderDCAnalysis();

        // Initial render - use setTimeout to ensure charts are fully initialized
        setTimeout(() => {
            const initialSliderValue = parseInt(document.getElementById('dateSlider').value);
            updateCharts(initialSliderValue);
        }, 100);
    })();
    </script>
</body>
</html>
