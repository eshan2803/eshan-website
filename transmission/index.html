<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>California Power Grid Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #map {
            height: 100vh; /* Full viewport height */
            width: 100%; /* Full width */
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            max-width: 300px;
        }
        #controls p {
            margin: 5px 0;
        }
        .grayscale {
            filter: grayscale(100%);
            -webkit-filter: grayscale(100%);
        }
        #legend {
            position: absolute;
            bottom: 20px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            max-width: 220px;
        }
        .legend-item {
            margin: 3px 0;
            font-size: 13px;
        }
        #legend strong {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .legend-color {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 5px;
            vertical-align: middle;
        }
        .custom-div-icon {
            background: transparent !important;
            border: none !important;
        }
        .leaflet-tooltip {
            background-color: rgba(255, 255, 255, 0.95);
            border: 2px solid #333;
            border-radius: 6px;
            padding: 8px;
            font-size: 12px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        /* Position zoom controls at top-left */
        .leaflet-top.leaflet-left {
            top: 10px;
            left: 10px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-ant-path@1.3.0/dist/leaflet-ant-path.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
</head>
<body>
    <div id="controls">
        <p><strong>California Power Grid Simulator</strong></p>
        <p>Hover over plants to see details.</p>
        <p>Click on plants to turn them ON/OFF.</p>
        <p id="status" style="margin-top: 10px; padding: 5px; background-color: #f0f0f0; border-radius: 4px; text-align: center;">
            <strong>Active Plants: <span id="activeCount">0</span></strong>
        </p>
    </div>
    <div id="legend">
        <strong>Power Plant Types:</strong>
        <div class="legend-item">
            <span style="display: inline-block; width: 20px; height: 20px; margin-right: 5px; vertical-align: middle;">
                <svg width="20" height="20"><circle cx="10" cy="10" r="7" fill="#FFD700" stroke="#000" stroke-width="1"/></svg>
            </span>Solar (SUN)
        </div>
        <div class="legend-item">
            <span style="display: inline-block; width: 20px; height: 20px; margin-right: 5px; vertical-align: middle;">
                <svg width="20" height="20"><polygon points="10,3 17,17 3,17" fill="#00FF00" stroke="#000" stroke-width="1"/></svg>
            </span>Wind (WIND)
        </div>
        <div class="legend-item">
            <span style="display: inline-block; width: 20px; height: 20px; margin-right: 5px; vertical-align: middle;">
                <svg width="20" height="20"><rect x="4" y="4" width="12" height="12" fill="#FF4500" stroke="#000" stroke-width="1"/></svg>
            </span>Natural Gas (NG)
        </div>
        <div class="legend-item">
            <span style="display: inline-block; width: 20px; height: 20px; margin-right: 5px; vertical-align: middle;">
                <svg width="20" height="20"><circle cx="10" cy="10" r="5" fill="#808080" stroke="#000" stroke-width="1"/></svg>
            </span>Other
        </div>
        <div class="legend-item" style="margin-top: 10px;"><span class="legend-color" style="background-color: #808080;"></span>OFF (Grey)</div>
        <div class="legend-item"><span class="legend-color" style="background-color: #39FF14;"></span>Electricity Flow</div>
    </div>
    <div id="map"></div>
    <script>
        // Initialize the map centered on California with smooth zoom
        var map = L.map('map', {
            zoomSnap: 0.25,      // Allow zoom in 0.25 increments for smoother control
            zoomDelta: 0.5,      // Zoom in/out by 0.5 levels per click
            wheelPxPerZoomLevel: 120  // Smoother mouse wheel zoom
        }).setView([36.7783, -119.4179], 6);

        // Add grayscale base tile layer
        var baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);
        baseLayer.getContainer().classList.add('grayscale');

        // URLs for local data
        const transmissionUrl = './transmission.geojson';
        const substationsUrl = './substations.geojson'; // No data yet
        const plantsUrl = './powerplant.geojson';

        // Layers (declared globally)
        let transmissionLayer = L.layerGroup().addTo(map);
        let substationsLayer = L.layerGroup().addTo(map);
        let plantsLayer = L.layerGroup().addTo(map);
        let customGenerators = L.layerGroup().addTo(map);
        let staticLinesLayer, animatedLinesLayer;

        // Track active generators
        let activeGenerators = 0;

        // Network graph data structures
        let networkGraph = {
            substations: [], // {id, latlng, name, voltage, connectedLines: [], marker}
            plants: [],      // {id, latlng, name, fuel, capacity, nearestSubstationId, marker, isOn}
            lines: [],       // {id, coords, startNodeId, endNodeId, feature, antPath}
            linesBySubstation: {} // Map of substationId -> [lineIds]
        };

        // Data loading promises
        let transmissionData, substationsData, plantsData;

        // Fetch transmission lines
        let transmissionPromise = fetch(transmissionUrl)
            .then(response => {
                if (!response.ok) throw new Error('Failed to fetch transmission lines');
                return response.json();
            })
            .then(data => {
                transmissionData = data;
                console.log(`Loaded ${data.features.length} transmission lines`);
            })
            .catch(error => {
                console.error('Error loading transmission lines:', error);
            });

        // Fetch substations
        let substationsPromise = fetch(substationsUrl)
            .then(response => {
                if (!response.ok) throw new Error('Failed to fetch substations');
                return response.json();
            })
            .then(data => {
                substationsData = data;
                console.log(`Loaded ${data.features.length} substations`);
            })
            .catch(error => {
                console.error('Error loading substations:', error);
            });

        // Fetch power plants
        let plantsPromise = fetch(plantsUrl)
            .then(response => {
                if (!response.ok) throw new Error('Failed to fetch power plants');
                return response.json();
            })
            .then(data => {
                plantsData = data;
                console.log(`Loaded ${data.features.length} power plants`);
            })
            .catch(error => {
                console.error('Error loading power plants:', error);
            });

        // Wait for all data to load, then build network and render
        Promise.all([transmissionPromise, substationsPromise, plantsPromise])
            .then(() => {
                console.log('All data loaded. Building network graph...');
                try {
                    buildNetworkGraph();
                    renderMap();
                    console.log('Network graph built and map rendered.');
                } catch (error) {
                    console.error('Error building network or rendering map:', error);
                }
            });

        // Removed custom generator functionality - we're using real power plant data

        // Custom triangle marker
        L.TriangleMarker = L.CircleMarker.extend({
            options: { rotation: 0 }
        });
        L.triangleMarker = function (latlng, options) {
            return new L.TriangleMarker(latlng, options);
        };

        // Build network graph from loaded data
        function buildNetworkGraph() {
            const TOLERANCE = 0.01; // ~1km tolerance for matching line endpoints to substations

            // 1. Build substations nodes
            substationsData.features.forEach((feature, idx) => {
                const props = feature.properties;
                const coords = feature.geometry.coordinates;

                // Validate coordinates
                if (!coords || coords.length < 2 ||
                    typeof coords[0] !== 'number' || typeof coords[1] !== 'number' ||
                    isNaN(coords[0]) || isNaN(coords[1])) {
                    console.warn(`Invalid substation coordinates at index ${idx}:`, coords);
                    return;
                }

                networkGraph.substations.push({
                    id: `sub_${idx}`,
                    latlng: [coords[1], coords[0]], // Leaflet uses [lat, lng]
                    name: props.Name || 'Unknown',
                    voltage: props.Max_Voltage || 0,
                    connectedLines: [],
                    feature: feature
                });
            });

            // Create substation points collection once (outside the loop for efficiency)
            const substationPoints = turf.featureCollection(
                networkGraph.substations.map(sub =>
                    turf.point([sub.latlng[1], sub.latlng[0]], {id: sub.id})
                )
            );

            if (substationPoints.features.length === 0) {
                console.error('No valid substations found!');
                return;
            }

            // 2. Build transmission lines and connect to substations
            transmissionData.features.forEach((feature, idx) => {
                const coords = feature.geometry.coordinates;
                if (!coords || coords.length < 2) return;

                // Handle MultiLineString (nested arrays) - flatten to first linestring
                let actualCoords = coords;
                if (Array.isArray(coords[0][0])) {
                    // This is a MultiLineString - use the first line
                    actualCoords = coords[0];
                    if (!actualCoords || actualCoords.length < 2) return;
                }

                // Validate start and end coordinates
                const startCoord = actualCoords[0];
                const endCoord = actualCoords[actualCoords.length - 1];

                if (!startCoord || startCoord.length < 2 ||
                    typeof startCoord[0] !== 'number' || typeof startCoord[1] !== 'number' ||
                    isNaN(startCoord[0]) || isNaN(startCoord[1])) {
                    console.warn(`Invalid start coord for line ${idx}:`, startCoord);
                    return;
                }

                if (!endCoord || endCoord.length < 2 ||
                    typeof endCoord[0] !== 'number' || typeof endCoord[1] !== 'number' ||
                    isNaN(endCoord[0]) || isNaN(endCoord[1])) {
                    console.warn(`Invalid end coord for line ${idx}:`, endCoord);
                    return;
                }

                // Get start and end points
                const startPoint = turf.point(startCoord);
                const endPoint = turf.point(endCoord);

                // Find nearest substations to start and end
                const nearestStart = turf.nearestPoint(startPoint, substationPoints);
                const nearestEnd = turf.nearestPoint(endPoint, substationPoints);

                // Only connect if within tolerance
                const distStart = turf.distance(startPoint, nearestStart, {units: 'kilometers'});
                const distEnd = turf.distance(endPoint, nearestEnd, {units: 'kilometers'});

                let startNodeId = null, endNodeId = null;

                if (distStart < TOLERANCE) {
                    startNodeId = nearestStart.properties.id;
                }
                if (distEnd < TOLERANCE) {
                    endNodeId = nearestEnd.properties.id;
                }

                const lineId = `line_${idx}`;
                networkGraph.lines.push({
                    id: lineId,
                    coords: actualCoords, // Use actualCoords instead of coords
                    startNodeId: startNodeId,
                    endNodeId: endNodeId,
                    feature: feature
                });

                // Add line to substations' connected lines
                if (startNodeId) {
                    const sub = networkGraph.substations.find(s => s.id === startNodeId);
                    if (sub) sub.connectedLines.push(lineId);
                    if (!networkGraph.linesBySubstation[startNodeId]) {
                        networkGraph.linesBySubstation[startNodeId] = [];
                    }
                    networkGraph.linesBySubstation[startNodeId].push(lineId);
                }
                if (endNodeId && endNodeId !== startNodeId) {
                    const sub = networkGraph.substations.find(s => s.id === endNodeId);
                    if (sub) sub.connectedLines.push(lineId);
                    if (!networkGraph.linesBySubstation[endNodeId]) {
                        networkGraph.linesBySubstation[endNodeId] = [];
                    }
                    networkGraph.linesBySubstation[endNodeId].push(lineId);
                }
            });

            // 3. Connect plants to nearest substations
            plantsData.features.forEach((feature, idx) => {
                const props = feature.properties;
                const coords = feature.geometry.coordinates;

                // Validate coordinates
                if (!coords || coords.length < 2 ||
                    typeof coords[0] !== 'number' || typeof coords[1] !== 'number' ||
                    isNaN(coords[0]) || isNaN(coords[1])) {
                    console.warn(`Invalid plant coordinates at index ${idx}:`, coords);
                    return;
                }

                const plantPoint = turf.point(coords);

                // Reuse substationPoints already created above
                const nearest = turf.nearestPoint(plantPoint, substationPoints);

                networkGraph.plants.push({
                    id: `plant_${idx}`,
                    latlng: [coords[1], coords[0]],
                    name: props.PlantName || 'Unknown',
                    fuel: props.PriEnergySource || 'UNKNOWN',
                    capacity: props.Capacity_Latest || 0,
                    nearestSubstationId: nearest.properties.id,
                    feature: feature,
                    isOn: false
                });
            });

            console.log(`Network graph built: ${networkGraph.substations.length} substations, ${networkGraph.plants.length} plants, ${networkGraph.lines.length} lines`);

            // Log connectivity stats
            const connectedLines = networkGraph.lines.filter(l => l.startNodeId || l.endNodeId).length;
            console.log(`${connectedLines} lines connected to substations (${(connectedLines/networkGraph.lines.length*100).toFixed(1)}%)`);
        }

        // BFS to find all lines connected to a substation
        function getConnectedLines(startSubstationId) {
            const visited = new Set();
            const connectedLineIds = new Set();
            const queue = [startSubstationId];

            while (queue.length > 0) {
                const currentSubId = queue.shift();

                if (visited.has(currentSubId)) continue;
                visited.add(currentSubId);

                // Get all lines connected to this substation
                const lines = networkGraph.linesBySubstation[currentSubId] || [];

                lines.forEach(lineId => {
                    connectedLineIds.add(lineId);

                    // Find the line and get the other end substation
                    const line = networkGraph.lines.find(l => l.id === lineId);
                    if (!line) return;

                    // Add the other end to the queue
                    if (line.startNodeId === currentSubId && line.endNodeId) {
                        if (!visited.has(line.endNodeId)) {
                            queue.push(line.endNodeId);
                        }
                    } else if (line.endNodeId === currentSubId && line.startNodeId) {
                        if (!visited.has(line.startNodeId)) {
                            queue.push(line.startNodeId);
                        }
                    }
                });
            }

            return Array.from(connectedLineIds);
        }

        // Get fuel color for plant
        function getFuelColor(fuel) {
            switch ((fuel || 'UNKNOWN').toUpperCase()) {
                case 'SUN': return '#FFD700'; // Solar - Gold
                case 'WIND': return '#00FF00'; // Wind - Green
                case 'NG': return '#FF4500'; // Natural Gas - Orange-Red
                case 'PC': return '#808080'; // Petroleum Coke - Gray
                default: return '#808080'; // Unknown - Gray
            }
        }

        // Render map with all layers
        function renderMap() {
            // Initialize layers
            staticLinesLayer = L.layerGroup().addTo(map);
            animatedLinesLayer = L.layerGroup();

            // Render transmission lines (all grey initially)
            networkGraph.lines.forEach(lineData => {
                const coords = lineData.coords.map(c => [c[1], c[0]]); // Convert to [lat, lng]

                // Static grey line
                const staticLine = L.polyline(coords, {
                    color: '#808080',
                    weight: 2,
                    opacity: 0.5
                });
                staticLine.lineId = lineData.id;
                staticLinesLayer.addLayer(staticLine);

                // Pre-create animated line (hidden initially)
                const antPath = L.polyline.antPath(coords, {
                    color: '#39FF14', // Neon green flow
                    weight: 3,
                    opacity: 0.8,
                    delay: 500,
                    dashArray: [10, 20],
                    pulseColor: '#FFFFFF',
                    hardwareAccelerated: true
                });
                antPath.lineId = lineData.id;
                lineData.antPath = antPath;
            });

            // Render substations (grey triangles)
            networkGraph.substations.forEach(subData => {
                const marker = L.circleMarker(subData.latlng, {
                    radius: 4,
                    fillColor: '#808080',
                    color: '#000',
                    weight: 1,
                    opacity: 0.7,
                    fillOpacity: 0.5
                });

                const props = subData.feature.properties;
                const name = props.Name || 'Unknown Substation';
                const voltage = props.Max_Voltage || 'Unknown';
                const county = props.COUNTY || 'Unknown';

                // Bind popup (shows on click)
                marker.bindPopup(`<b>${name}</b><br>Voltage: ${voltage} kV<br>County: ${county}`);

                // Bind tooltip (shows on hover)
                marker.bindTooltip(`<b>${name}</b> Substation<br>${voltage} kV`, {
                    direction: 'top',
                    offset: [0, -5],
                    opacity: 0.9
                });

                substationsLayer.addLayer(marker);
                subData.marker = marker;
            });

            // Render power plants with different shapes based on fuel type
            networkGraph.plants.forEach(plantData => {
                const color = getFuelColor(plantData.fuel);
                const fuelType = (plantData.fuel || 'UNKNOWN').toUpperCase();

                let marker;

                // Create different shapes based on fuel type
                switch(fuelType) {
                    case 'SUN': // Solar - Circle
                        marker = L.circleMarker(plantData.latlng, {
                            radius: 8,
                            fillColor: '#808080',
                            color: '#000',
                            weight: 1,
                            opacity: 1,
                            fillOpacity: 0.8
                        });
                        break;

                    case 'WIND': // Wind - Triangle pointing up
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<div style="width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-bottom: 14px solid #808080; margin-left: -8px; margin-top: -7px; filter: drop-shadow(0 0 1px #000);"></div>`,
                                iconSize: [16, 16],
                                iconAnchor: [8, 8]
                            })
                        });
                        break;

                    case 'NG': // Natural Gas - Square
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<div style="width: 14px; height: 14px; background-color: #808080; border: 1px solid #000; margin-left: -7px; margin-top: -7px;"></div>`,
                                iconSize: [16, 16],
                                iconAnchor: [8, 8]
                            })
                        });
                        break;

                    default: // Other - Small circle
                        marker = L.circleMarker(plantData.latlng, {
                            radius: 6,
                            fillColor: '#808080',
                            color: '#000',
                            weight: 1,
                            opacity: 1,
                            fillOpacity: 0.8
                        });
                }

                const name = plantData.name;
                const fuel = plantData.fuel;
                const capacity = plantData.capacity;

                // Bind popup (shows on click)
                marker.bindPopup(`<b>${name}</b><br>Type: ${fuel}<br>Capacity: ${capacity} MW`);

                // Bind tooltip (shows on hover)
                marker.bindTooltip(`<b>${name}</b><br>Type: ${fuel}<br>Capacity: ${capacity} MW<br><i>Click to turn ON/OFF</i>`, {
                    direction: 'top',
                    offset: [0, -10],
                    opacity: 0.9
                });

                // Click handler to toggle plant on/off
                marker.on('click', function(e) {
                    L.DomEvent.stopPropagation(e); // Prevent map click
                    plantData.isOn = !plantData.isOn;

                    if (plantData.isOn) {
                        activeGenerators++;

                        // Update marker color based on type
                        if (marker instanceof L.CircleMarker) {
                            marker.setStyle({ fillColor: color });
                        } else {
                            // Update divIcon color
                            const shape = fuelType === 'WIND' ? 'triangle' : 'square';
                            const html = fuelType === 'WIND'
                                ? `<div style="width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-bottom: 14px solid ${color}; margin-left: -8px; margin-top: -7px; filter: drop-shadow(0 0 1px #000);"></div>`
                                : `<div style="width: 14px; height: 14px; background-color: ${color}; border: 1px solid #000; margin-left: -7px; margin-top: -7px;"></div>`;
                            marker.setIcon(L.divIcon({
                                className: 'custom-div-icon',
                                html: html,
                                iconSize: [16, 16],
                                iconAnchor: [8, 8]
                            }));
                        }
                    } else {
                        activeGenerators--;

                        // Reset to grey
                        if (marker instanceof L.CircleMarker) {
                            marker.setStyle({ fillColor: '#808080' });
                        } else {
                            const html = fuelType === 'WIND'
                                ? `<div style="width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-bottom: 14px solid #808080; margin-left: -8px; margin-top: -7px; filter: drop-shadow(0 0 1px #000);"></div>`
                                : `<div style="width: 14px; height: 14px; background-color: #808080; border: 1px solid #000; margin-left: -7px; margin-top: -7px;"></div>`;
                            marker.setIcon(L.divIcon({
                                className: 'custom-div-icon',
                                html: html,
                                iconSize: [16, 16],
                                iconAnchor: [8, 8]
                            }));
                        }
                    }

                    updateFlow();
                });

                plantsLayer.addLayer(marker);
                plantData.marker = marker;
            });

            console.log('Map rendered with all layers.');

            // Fit map to show all data points
            fitMapToData();
        }

        // Fit map bounds to show all California data
        function fitMapToData() {
            // Create a feature group with all layers
            const allLayers = L.featureGroup([
                staticLinesLayer,
                substationsLayer,
                plantsLayer
            ]);

            // Fit map to bounds with some padding
            map.fitBounds(allLayers.getBounds(), {
                padding: [50, 50],  // 50px padding on all sides
                maxZoom: 7          // Don't zoom in too much
            });

            console.log('Map fitted to data bounds');
        }

        // Updated function to show flow only on connected lines
        function updateFlow() {
            // Update counter display
            document.getElementById('activeCount').textContent = activeGenerators;

            // Clear animated layer
            animatedLinesLayer.clearLayers();

            if (activeGenerators > 0) {
                // Find all active plants
                const activePlants = networkGraph.plants.filter(p => p.isOn);

                // Collect all connected line IDs from all active plants
                const allConnectedLineIds = new Set();

                activePlants.forEach(plant => {
                    const substationId = plant.nearestSubstationId;
                    if (substationId) {
                        const connectedLines = getConnectedLines(substationId);
                        connectedLines.forEach(lineId => allConnectedLineIds.add(lineId));
                    }
                });

                console.log(`${activePlants.length} active plants, ${allConnectedLineIds.size} lines to animate`);

                // Add animated ant paths for connected lines
                allConnectedLineIds.forEach(lineId => {
                    const lineData = networkGraph.lines.find(l => l.id === lineId);
                    if (lineData && lineData.antPath) {
                        animatedLinesLayer.addLayer(lineData.antPath);
                    }
                });

                // Show animated layer, hide static layer
                if (!map.hasLayer(animatedLinesLayer)) {
                    animatedLinesLayer.addTo(map);
                }
                if (map.hasLayer(staticLinesLayer)) {
                    map.removeLayer(staticLinesLayer);
                }
            } else {
                // No active generators - show static layer
                if (map.hasLayer(animatedLinesLayer)) {
                    map.removeLayer(animatedLinesLayer);
                }
                if (!map.hasLayer(staticLinesLayer)) {
                    staticLinesLayer.addTo(map);
                }
            }
        }
    </script>
</body>
</html>

