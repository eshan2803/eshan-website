<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>California Power Grid Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/esri-leaflet@3.0.10/dist/esri-leaflet.js"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
        }
        #map {
            height: 100vh; /* Full viewport height */
            width: 100%; /* Full width */
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            max-width: 300px;
        }
        #controls p {
            margin: 5px 0;
        }
        .grayscale {
            filter: grayscale(100%);
            -webkit-filter: grayscale(100%);
        }
        #legend {
            position: absolute;
            bottom: 20px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            max-width: 220px;
        }
        .legend-item {
            margin: 3px 0;
            font-size: 13px;
        }
        #legend strong {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .legend-color {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 5px;
            vertical-align: middle;
        }
        .custom-div-icon {
            background: transparent !important;
            border: none !important;
        }
        .leaflet-tooltip {
            background-color: rgba(255, 255, 255, 0.95);
            border: 2px solid #333;
            border-radius: 6px;
            padding: 8px;
            font-size: 12px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        /* Position zoom controls at top-left */
        .leaflet-top.leaflet-left {
            top: 10px;
            left: 10px;
        }
        /* Custom home button */
        .leaflet-control-home {
            background: white;
            border: 2px solid rgba(0,0,0,0.2);
            border-radius: 4px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            margin-top: 10px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        .leaflet-control-home:hover {
            background: #f4f4f4;
            transform: scale(1.05);
        }
        .leaflet-control-home svg {
            width: 18px;
            height: 18px;
            fill: #333;
        }
        /* Basemap toggle control in bottom-right */
        #basemap-toggle {
            position: absolute;
            bottom: 20px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 5px;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .basemap-option {
            width: 45px;
            height: 45px;
            border: 2px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            text-align: center;
            padding: 3px;
            background-size: cover;
            background-position: center;
            position: relative;
            overflow: hidden;
        }
        .basemap-option:hover {
            border-color: #666;
            transform: scale(1.08);
        }
        .basemap-option.active {
            border-color: #4A90A4;
            border-width: 2.5px;
            box-shadow: 0 0 6px rgba(74, 144, 164, 0.5);
        }
        .basemap-option .label {
            position: absolute;
            bottom: 1px;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            padding: 1px 2px;
            font-weight: 600;
            font-size: 7.5px;
            letter-spacing: 0.2px;
        }
        /* Basemap preview styles - using actual map snippets */
        #basemap-grayscale {
            background-image: url('https://a.tile.openstreetmap.org/6/10/24.png');
        }
        #basemap-satellite {
            background-image: url('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/6/24/10');
        }
        #basemap-elevation {
            background-image: url('https://tile.opentopomap.org/6/10/24.png');
        }
        #basemap-population {
            background-image: url('https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/VIIRS_CityLights_2012/default/GoogleMapsCompatible_Level8/6/24/10.jpg');
        }
        #basemap-landcover {
            background-image: url('https://www.mrlc.gov/geoserver/mrlc_display/wms?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&FORMAT=image/png&TRANSPARENT=true&LAYERS=mrlc_display:NLCD_2021_Land_Cover_L48&WIDTH=256&HEIGHT=256&SRS=EPSG:3857&BBOX=-13358338.89519283,4383204.9499851465,-13210795.034662457,4530748.810515519');
        }
        #basemap-solar {
            background-image: url('https://eshan2803.github.io/basemaps/solar_tiles/6/10/24.png');
        }
        #basemap-wind {
            background-image: url('https://eshan2803.github.io/basemaps/wind_tiles/6/10/24.png');
        }
        #basemap-population-density {
            background-image: url('https://eshan2803.github.io/basemaps/population_tiles/6/10/24.png');
        }

        /* Land cover hover tooltip styling */
        .land-cover-tooltip {
            background-color: rgba(255, 255, 255, 0.95);
            border: 2px solid #333;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 13px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            pointer-events: none;
            white-space: nowrap;
        }
        .land-cover-tooltip strong {
            color: #2c5f2d;
            font-size: 12px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-ant-path@1.3.0/dist/leaflet-ant-path.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
</head>
<body>
    <div id="controls">
        <p><strong>California Power Grid Simulator</strong></p>
        <p style="margin: 5px 0; font-size: 13px;">Hover over plants to see details.</p>
        <p style="margin: 5px 0; font-size: 13px;">Click on plants to turn them ON/OFF.</p>
        <p style="margin: 5px 0; font-size: 13px;">Select Generator Type by clicking on the Legend Label.</p>
        <p style="margin: 5px 0; font-size: 13px;">Select multiple Generators by Ctrl/Cmd and clicking on Legend Labels.</p>
        <p id="status" style="margin-top: 10px; padding: 5px; background-color: #f0f0f0; border-radius: 4px; text-align: center;">
            <strong>Active Plants: <span id="activeCount">0</span></strong>
        </p>
        <button id="toggleAllBtn" style="width: 100%; margin-top: 10px; padding: 8px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
            Turn All Plants ON
        </button>
    </div>
    <div id="legend">
        <strong id="legend-plants-header" style="cursor: pointer; user-select: none;" title="Click to hide/show all plants">Power Plant:</strong>
        <div class="legend-item fuel-filter" data-fuel="SUN" style="cursor: pointer; padding: 2px; border-radius: 3px;">
            <span style="display: inline-block; width: 20px; height: 20px; margin-right: 5px; vertical-align: middle;">
                <svg width="20" height="20"><circle cx="10" cy="10" r="5" fill="#FFD700" stroke="#000" stroke-width="1"/></svg>
            </span>Solar (986)
        </div>
        <div class="legend-item fuel-filter" data-fuel="WND" style="cursor: pointer; padding: 2px; border-radius: 3px;">
            <span style="display: inline-block; width: 20px; height: 20px; margin-right: 5px; vertical-align: middle;">
                <svg width="20" height="20"><polygon points="10,5 16,15 4,15" fill="#1E90FF" stroke="#000" stroke-width="1"/></svg>
            </span>Wind (163)
        </div>
        <div class="legend-item fuel-filter" data-fuel="NG,GAS,OGW,OG" style="cursor: pointer; padding: 2px; border-radius: 3px;" title="Includes: Natural Gas (NG), Gas, Other Gas from Waste">
            <span style="display: inline-block; width: 20px; height: 20px; margin-right: 5px; vertical-align: middle;">
                <svg width="20" height="20"><rect x="5" y="5" width="10" height="10" fill="#FF4500" stroke="#000" stroke-width="1"/></svg>
            </span>Natural Gas (361)
        </div>
        <div class="legend-item fuel-filter" data-fuel="WAT" style="cursor: pointer; padding: 2px; border-radius: 3px;">
            <span style="display: inline-block; width: 20px; height: 20px; margin-right: 5px; vertical-align: middle;">
                <svg width="20" height="20"><polygon points="6.5,5 13.5,5 16,10 13.5,15 6.5,15 4,10" fill="#00CED1" stroke="#000" stroke-width="1"/></svg>
            </span>Hydro (298)
        </div>
        <div class="legend-item fuel-filter" data-fuel="GEO,WH" style="cursor: pointer; padding: 2px; border-radius: 3px;" title="Includes: Geothermal, Waste Heat">
            <span style="display: inline-block; width: 20px; height: 20px; margin-right: 5px; vertical-align: middle;">
                <svg width="20" height="20"><rect x="6" y="6" width="8" height="8" fill="#DC143C" stroke="#000" stroke-width="1" transform="rotate(45 10 10)"/></svg>
            </span>Geothermal (49)
        </div>
        <div class="legend-item fuel-filter" data-fuel="NUC" style="cursor: pointer; padding: 2px; border-radius: 3px;">
            <span style="display: inline-block; width: 20px; height: 20px; margin-right: 5px; vertical-align: middle;">
                <svg width="20" height="20"><polygon points="10,5 14,7.5 12.5,14 7.5,14 6,7.5" fill="#BA55D3" stroke="#000" stroke-width="1"/></svg>
            </span>Nuclear (2)
        </div>
        <div class="legend-item fuel-filter" data-fuel="LFG,WDS,OBG,MSW,AB,OBS" style="cursor: pointer; padding: 2px; border-radius: 3px;" title="Includes: Landfill Gas, Wood, Other Biogas, Municipal Solid Waste, Agricultural Byproduct, Other Biomass Solids">
            <span style="display: inline-block; width: 20px; height: 20px; margin-right: 5px; vertical-align: middle;">
                <svg width="20" height="20"><rect x="9" y="2" width="2" height="16" fill="#D2691E" stroke="#000" stroke-width="0.5"/><rect x="2" y="9" width="16" height="2" fill="#D2691E" stroke="#000" stroke-width="0.5"/></svg>
            </span>Biomass (173)
        </div>
        <div class="legend-item fuel-filter" data-fuel="BIT,OIL,DFO,SUB,JF,BLQ,PC" style="cursor: pointer; padding: 2px; border-radius: 3px;" title="Includes: Bituminous Coal, Oil, Distillate Fuel Oil, Sub-Bituminous Coal, Jet Fuel, Black Liquor, Petroleum Coke">
            <span style="display: inline-block; width: 20px; height: 20px; margin-right: 5px; vertical-align: middle;">
                <svg width="20" height="20">
                    <line x1="4" y1="4" x2="16" y2="16" stroke="#FF6347" stroke-width="2.5"/>
                    <line x1="16" y1="4" x2="4" y2="16" stroke="#FF6347" stroke-width="2.5"/>
                    <line x1="4" y1="4" x2="16" y2="16" stroke="#FF6347" stroke-width="2"/>
                    <line x1="16" y1="4" x2="4" y2="16" stroke="#FF6347" stroke-width="2"/>
                </svg>
            </span>Coal/Petcoke/Oil (28)
        </div>
        <div class="legend-item fuel-filter" data-fuel="BAT,OTH" style="cursor: pointer; padding: 2px; border-radius: 3px;" title="Includes: Battery Storage and Other (BAT, OTH)">
            <span style="display: inline-block; width: 20px; height: 20px; margin-right: 5px; vertical-align: middle;">
                <svg width="20" height="20"><rect x="3" y="7" width="14" height="8" fill="#FFD700" stroke="#000" stroke-width="1"/><rect x="6" y="5" width="8" height="2" fill="#FFD700" stroke="#000" stroke-width="0.5"/></svg>
            </span>Battery (13)
        </div>
        <div class="legend-item" style="margin-top: 10px;"><span class="legend-color" style="background-color: #808080;"></span>OFF</div>
        <div class="legend-item"><span class="legend-color" style="background-color: #39FF14;"></span>Active Flow</div>
        <div class="legend-item" id="legend-lines-toggle" style="cursor: pointer; user-select: none;" title="Click to hide/show transmission lines"><span class="legend-color" style="background-color: #4A90A4;"></span>Transmission Lines</div>
        <div class="legend-item" id="legend-substations-toggle" style="cursor: pointer; user-select: none;" title="Click to hide/show substations">
            <span style="display: inline-block; width: 20px; height: 20px; margin-right: 5px; vertical-align: middle;">
                <svg width="20" height="20"><circle cx="10" cy="10" r="2" fill="#39FF14" stroke="#000" stroke-width="0.5"/></svg>
            </span>Substations (4442)
        </div>
    </div>
    <div id="basemap-toggle">
        <div class="basemap-option active" id="basemap-grayscale" data-layer="grayscale" title="Grayscale Map">
            <span class="label">Street</span>
        </div>
        <div class="basemap-option" id="basemap-satellite" data-layer="satellite" title="Satellite View">
            <span class="label">Satellite</span>
        </div>
        <div class="basemap-option" id="basemap-elevation" data-layer="elevation" title="Topographic Elevation">
            <span class="label">Elevation</span>
        </div>
        <div class="basemap-option" id="basemap-population" data-layer="population" title="Population Density">
            <span class="label">Population</span>
        </div>
        <div class="basemap-option" id="basemap-landcover" data-layer="landcover" title="Land Cover (NLCD)">
            <span class="label">Land Cover</span>
        </div>
        <div class="basemap-option" id="basemap-solar" data-layer="solarMap" title="Solar Irradiance Map">
            <span class="label">Solar</span>
        </div>
        <div class="basemap-option" id="basemap-wind" data-layer="windMap" title="Wind Speed Map">
            <span class="label">Wind</span>
        </div>
        <div class="basemap-option" id="basemap-population-density" data-layer="populationMap" title="Population Density Map">
            <span class="label">Pop. Density</span>
        </div>
    </div>
    <div id="map"></div>
    <script>
        // Initialize the map centered on California with smooth zoom
        var map = L.map('map', {
            zoomSnap: 0.25,      // Allow zoom in 0.25 increments for smoother control
            zoomDelta: 0.5,      // Zoom in/out by 0.5 levels per click
            wheelPxPerZoomLevel: 120  // Smoother mouse wheel zoom
        }).setView([36.7783, -119.4179], 6);

        // Create a new pane for WMS overlays
        map.createPane('wmsOverlayPane');
        map.getPane('wmsOverlayPane').style.zIndex = 300; // Above tiles (200), below overlays (400)
        map.getPane('wmsOverlayPane').style.pointerEvents = 'none';

        // Define basemap layers
        var baseLayers = {
            grayscale: L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }),
            satellite: L.esri.basemapLayer('Imagery', {
                attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
            }),
            elevation: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a>',
                pane: 'wmsOverlayPane',
                opacity: 0.8
            }),
            population: L.tileLayer.wms('https://sedac.ciesin.columbia.edu/geoserver/wms', {
                layers: 'gpw-v4:gpw-v4-population-density_2020',
                format: 'image/png',
                transparent: true,
                attribution: 'SEDAC / CIESIN / Columbia University',
                pane: 'wmsOverlayPane',
                opacity: 0.8
            }),
            landcover: L.tileLayer.wms('https://www.mrlc.gov/geoserver/wms', {
                layers: 'mrlc_display:NLCD_2021_Land_Cover_L48',
                format: 'image/png',
                transparent: true,
                attribution: 'USGS MRLC',
                pane: 'wmsOverlayPane',
                opacity: 0.8
            }),
            solarMap: L.tileLayer('https://eshan2803.github.io/basemaps/solar_tiles/{z}/{x}/{y}.png', {
                attribution: 'Solar Data from Global Solar Atlas / World Bank Group',
                pane: 'wmsOverlayPane',
                opacity: 0.7,
                minZoom: 0,
                maxZoom: 10,
                maxNativeZoom: 10,  // Use zoom 10 tiles even when zoomed further
                errorTileUrl: '',  // Don't show broken tile images
                bounds: [[-90, -180], [90, 180]]  // World bounds
            }),
            windMap: L.tileLayer('https://eshan2803.github.io/basemaps/wind_tiles/{z}/{x}/{y}.png', {
                attribution: 'Wind Data from Global Wind Atlas / World Bank Group',
                pane: 'wmsOverlayPane',
                opacity: 0.7,
                minZoom: 0,
                maxZoom: 10,
                maxNativeZoom: 10,  // Use zoom 10 tiles even when zoomed further
                errorTileUrl: '',  // Don't show broken tile images
                bounds: [[-90, -180], [90, 180]]  // World bounds
            }),
            populationMap: L.tileLayer('https://eshan2803.github.io/basemaps/population_tiles/{z}/{x}/{y}.png', {
                attribution: 'Population Density Data',
                pane: 'wmsOverlayPane',
                opacity: 0.9,
                minZoom: 0,
                maxZoom: 12,
                maxNativeZoom: 12,  // Use zoom 10 tiles even when zoomed further
                errorTileUrl: '',  // Don't show broken tile images
                bounds: [[-90, -180], [90, 180]]  // World bounds
            })
        };

        // Population density heatmap - create a visual representation using nighttime lights
        // NASA's Black Marble (nighttime lights) as proxy for population density
        var populationOverlay = L.tileLayer('https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/VIIRS_CityLights_2012/default/GoogleMapsCompatible_Level8/{z}/{y}/{x}.jpg', {
            attribution: '&copy; <a href="https://earthdata.nasa.gov/">NASA</a>',
            maxZoom: 19,
            maxNativeZoom: 8, // Actual data only goes to zoom 8
            opacity: 0.7,
            pane: 'wmsOverlayPane' // Use custom pane for proper z-ordering
        });


        // Add default grayscale layer
        var currentBaseLayer = baseLayers.grayscale.addTo(map);
        currentBaseLayer.getContainer().classList.add('grayscale');

        // Track active overlays - now supports multiple overlays
        var activeOverlays = []; // Array of active overlay layers
        var activeBaseOptions = new Set(); // Track which basemap options are selected

        // URLs for local data
        const transmissionUrl = './transmission.geojson';
        const substationsUrl = './substations.geojson'; // No data yet
        const plantsUrl = './powerplant.geojson';

        // Layers (declared globally)
        let transmissionLayer = L.layerGroup().addTo(map);
        let substationsLayer = L.layerGroup().addTo(map);
        let plantsLayer = L.layerGroup().addTo(map);
        let customGenerators = L.layerGroup().addTo(map);
        let staticLinesLayer, animatedLinesLayer;

        // Track active generators
        let activeGenerators = 0;

        // Network graph data structures
        let networkGraph = {
            substations: [], // {id, latlng, name, voltage, connectedLines: [], marker}
            plants: [],      // {id, latlng, name, fuel, capacity, nearestSubstationId, marker, isOn}
            lines: [],       // {id, coords, startNodeId, endNodeId, feature, antPath}
            linesBySubstation: {} // Map of substationId -> [lineIds]
        };

        // Data loading promises
        let transmissionData, substationsData, plantsData;

        // Fetch transmission lines
        let transmissionPromise = fetch(transmissionUrl)
            .then(response => {
                if (!response.ok) throw new Error('Failed to fetch transmission lines');
                return response.json();
            })
            .then(data => {
                transmissionData = data;
                console.log(`Loaded ${data.features.length} transmission lines`);
            })
            .catch(error => {
                console.error('Error loading transmission lines:', error);
            });

        // Fetch substations
        let substationsPromise = fetch(substationsUrl)
            .then(response => {
                if (!response.ok) throw new Error('Failed to fetch substations');
                return response.json();
            })
            .then(data => {
                substationsData = data;
                console.log(`Loaded ${data.features.length} substations`);
            })
            .catch(error => {
                console.error('Error loading substations:', error);
            });

        // Fetch power plants
        let plantsPromise = fetch(plantsUrl)
            .then(response => {
                if (!response.ok) throw new Error('Failed to fetch power plants');
                return response.json();
            })
            .then(data => {
                plantsData = data;
                console.log(`Loaded ${data.features.length} power plants`);
            })
            .catch(error => {
                console.error('Error loading power plants:', error);
            });

        // Wait for all data to load, then build network and render
        Promise.all([transmissionPromise, substationsPromise, plantsPromise])
            .then(() => {
                console.log('All data loaded. Building network graph...');
                try {
                    buildNetworkGraph();
                    renderMap();
                    setupToggleAllButton();
                    setupLegendInteractivity();
                    setupLayerToggles();
                    setupBasemapToggle();
                    setupHomeButton();
                    setupLandCoverHover();
                    console.log('Network graph built and map rendered.');
                } catch (error) {
                    console.error('Error building network or rendering map:', error);
                }
            });

        // Setup toggle all plants button
        function setupToggleAllButton() {
            const toggleBtn = document.getElementById('toggleAllBtn');
            let allOn = false;

            toggleBtn.addEventListener('click', function() {
                allOn = !allOn;

                console.log(`Toggling all ${networkGraph.plants.length} plants ${allOn ? 'ON' : 'OFF'}...`);

                // Toggle all plants
                networkGraph.plants.forEach(plantData => {
                    if (plantData.isOn !== allOn) {
                        const color = getFuelColor(plantData.fuel);
                        const fuelType = (plantData.fuel || 'UNKNOWN').toUpperCase();
                        const marker = plantData.marker;

                        plantData.isOn = allOn;

                        if (allOn) {
                            activeGenerators++;
                            // Update marker color based on type
                            if (marker instanceof L.CircleMarker) {
                                marker.setStyle({ fillColor: color });
                            } else {
                                const isLargeMarker = ['WND', 'WIND', 'BAT', 'OTH', 'NUC'].includes(fuelType);
                                const isWind = ['WND', 'WIND'].includes(fuelType);
                                const markerSize = isWind ? 18 : (isLargeMarker ? 16 : 12);
                                const markerAnchor = isWind ? 9 : (isLargeMarker ? 8 : 6);
                                marker.setIcon(L.divIcon({
                                    className: 'custom-div-icon',
                                    html: getMarkerHTML(fuelType, color, 'large'),
                                    iconSize: [markerSize, markerSize],
                                    iconAnchor: [markerAnchor, markerAnchor]
                                }));
                            }
                        } else {
                            activeGenerators--;
                            // Reset to grey
                            if (marker instanceof L.CircleMarker) {
                                marker.setStyle({ fillColor: '#808080' });
                            } else {
                                const isLargeMarker = ['WND', 'WIND', 'BAT', 'OTH', 'NUC'].includes(fuelType);
                                const isWind = ['WND', 'WIND'].includes(fuelType);
                                const markerSize = isWind ? 18 : (isLargeMarker ? 16 : 12);
                                const markerAnchor = isWind ? 9 : (isLargeMarker ? 8 : 6);
                                marker.setIcon(L.divIcon({
                                    className: 'custom-div-icon',
                                    html: getMarkerHTML(fuelType, '#808080', 'large'),
                                    iconSize: [markerSize, markerSize],
                                    iconAnchor: [markerAnchor, markerAnchor]
                                }));
                            }
                        }
                    }
                });

                // Update button text and color
                if (allOn) {
                    toggleBtn.textContent = 'Turn All Plants OFF';
                    toggleBtn.style.backgroundColor = '#f44336'; // Red
                } else {
                    toggleBtn.textContent = 'Turn All Plants ON';
                    toggleBtn.style.backgroundColor = '#4CAF50'; // Green
                }

                // Update flow visualization
                updateFlow();

                console.log(`All plants toggled ${allOn ? 'ON' : 'OFF'}. Active: ${activeGenerators}`);
            });
        }

        // Setup interactive legend functionality
        function setupLegendInteractivity() {
            let activeFilters = new Set(); // Track active filters (for multi-select)
            let stateBeforeFilter = {}; // Track plant states before filtering

            // Get all legend filter items
            const filterItems = document.querySelectorAll('.fuel-filter');

            filterItems.forEach(item => {
                const fuelTypes = item.getAttribute('data-fuel').split(',');

                // 1. Hover highlighting - fade non-matching plants
                item.addEventListener('mouseenter', () => {
                    networkGraph.plants.forEach(plant => {
                        const plantFuel = (plant.fuel || '').toUpperCase();
                        const isMatching = fuelTypes.includes(plantFuel);

                        if (!isMatching && plant.marker) {
                            // Fade non-matching plants
                            if (plant.marker instanceof L.CircleMarker) {
                                plant.marker.setStyle({ fillOpacity: 0.2, opacity: 0.2 });
                            } else {
                                plant.marker.setOpacity(0.2);
                            }
                        }
                    });

                    // Highlight legend item
                    item.style.backgroundColor = '#f0f0f0';
                });

                item.addEventListener('mouseleave', () => {
                    networkGraph.plants.forEach(plant => {
                        if (plant.marker) {
                            // Restore full opacity
                            if (plant.marker instanceof L.CircleMarker) {
                                plant.marker.setStyle({ fillOpacity: 0.8, opacity: 1 });
                            } else {
                                plant.marker.setOpacity(1);
                            }
                        }
                    });

                    // Remove hover highlight if not actively filtered
                    if (!activeFilters.has(item)) {
                        item.style.backgroundColor = '';
                    }
                });

                // 2. Click filtering - show only selected fuel type(s)
                // Support multi-select with Ctrl/Cmd key
                item.addEventListener('click', (e) => {
                    const isMultiSelect = e.ctrlKey || e.metaKey; // Ctrl on Windows/Linux, Cmd on Mac

                    if (isMultiSelect) {
                        // Multi-select mode: toggle this filter
                        if (activeFilters.has(item)) {
                            // Remove this filter
                            activeFilters.delete(item);
                            item.style.backgroundColor = '';
                        } else {
                            // Add this filter
                            if (activeFilters.size === 0) {
                                // First filter - save state
                                saveCurrentState();
                            }
                            activeFilters.add(item);
                            item.style.backgroundColor = '#d0d0d0';
                        }

                        // Apply combined filters or restore if none selected
                        if (activeFilters.size > 0) {
                            applyCombinedFilters();
                        } else {
                            restorePreviousState();
                        }
                    } else {
                        // Single-select mode (no Ctrl/Cmd)
                        if (activeFilters.size === 1 && activeFilters.has(item)) {
                            // Clicking same single filter - restore previous state
                            restorePreviousState();
                            activeFilters.clear();
                            filterItems.forEach(i => i.style.backgroundColor = '');
                            console.log('Filter removed, restored previous state');
                        } else {
                            // Apply new single filter
                            if (activeFilters.size === 0) {
                                saveCurrentState();
                            }

                            // Clear all previous filters
                            activeFilters.clear();
                            filterItems.forEach(i => i.style.backgroundColor = '');

                            // Add this filter
                            activeFilters.add(item);
                            item.style.backgroundColor = '#d0d0d0';

                            applyCombinedFilters();
                            console.log(`Filter applied: ${fuelTypes.join(', ')}`);
                        }
                    }
                });
            });

            // Save current plant states before filtering
            function saveCurrentState() {
                stateBeforeFilter = {};
                networkGraph.plants.forEach(plant => {
                    stateBeforeFilter[plant.id] = plant.isOn;
                });
            }

            // Apply combined filters from multiple selections
            function applyCombinedFilters() {
                // Collect all fuel types from active filters
                const allFuelTypes = new Set();
                activeFilters.forEach(item => {
                    const fuelTypes = item.getAttribute('data-fuel').split(',');
                    fuelTypes.forEach(type => allFuelTypes.add(type));
                });

                applyFilter(Array.from(allFuelTypes));

                console.log(`Combined filters applied: ${Array.from(allFuelTypes).join(', ')}`);
            }

            // Apply filter to show only selected fuel types
            function applyFilter(fuelTypes) {
                let matchingPlants = 0;

                networkGraph.plants.forEach(plant => {
                    const plantFuel = (plant.fuel || '').toUpperCase();
                    const isMatching = fuelTypes.includes(plantFuel);

                    if (isMatching) {
                        matchingPlants++;

                        // Show matching plant
                        if (plant.marker) {
                            if (!map.hasLayer(plant.marker)) {
                                plantsLayer.addLayer(plant.marker);
                            }
                        }

                        // Turn ON matching plant if not already
                        if (!plant.isOn) {
                            plant.isOn = true;
                            activeGenerators++;

                            const color = getFuelColor(plant.fuel);
                            const fuelType = plantFuel;

                            if (plant.marker instanceof L.CircleMarker) {
                                plant.marker.setStyle({ fillColor: color });
                            } else {
                                const isLargeMarker = ['WND', 'WIND', 'BAT', 'OTH', 'NUC'].includes(fuelType);
                                const isWind = ['WND', 'WIND'].includes(fuelType);
                                const markerSize = isWind ? 18 : (isLargeMarker ? 16 : 12);
                                const markerAnchor = isWind ? 9 : (isLargeMarker ? 8 : 6);
                                plant.marker.setIcon(L.divIcon({
                                    className: 'custom-div-icon',
                                    html: getMarkerHTML(fuelType, color, 'large'),
                                    iconSize: [markerSize, markerSize],
                                    iconAnchor: [markerAnchor, markerAnchor]
                                }));
                            }
                        }
                    } else {
                        // Hide non-matching plant
                        if (plant.marker && map.hasLayer(plant.marker)) {
                            plantsLayer.removeLayer(plant.marker);
                        }

                        // Turn OFF non-matching plant if it was on
                        if (plant.isOn) {
                            plant.isOn = false;
                            activeGenerators--;
                        }
                    }
                });

                // Update flow visualization with filtered plants
                updateFlow();

                console.log(`${matchingPlants} plants matching filter, ${activeGenerators} active`);
            }

            // Restore plant states from before filtering
            function restorePreviousState() {
                networkGraph.plants.forEach(plant => {
                    const previousState = stateBeforeFilter[plant.id];

                    // Restore marker visibility
                    if (plant.marker && !map.hasLayer(plant.marker)) {
                        plantsLayer.addLayer(plant.marker);
                    }

                    // Restore ON/OFF state
                    if (previousState !== undefined && plant.isOn !== previousState) {
                        const color = getFuelColor(plant.fuel);
                        const fuelType = (plant.fuel || 'UNKNOWN').toUpperCase();

                        plant.isOn = previousState;

                        if (previousState) {
                            activeGenerators++;

                            // Turn ON
                            if (plant.marker instanceof L.CircleMarker) {
                                plant.marker.setStyle({ fillColor: color });
                            } else {
                                const isLargeMarker = ['WND', 'WIND', 'BAT', 'OTH', 'NUC'].includes(fuelType);
                                const isWind = ['WND', 'WIND'].includes(fuelType);
                                const markerSize = isWind ? 18 : (isLargeMarker ? 16 : 12);
                                const markerAnchor = isWind ? 9 : (isLargeMarker ? 8 : 6);
                                plant.marker.setIcon(L.divIcon({
                                    className: 'custom-div-icon',
                                    html: getMarkerHTML(fuelType, color, 'large'),
                                    iconSize: [markerSize, markerSize],
                                    iconAnchor: [markerAnchor, markerAnchor]
                                }));
                            }
                        } else {
                            activeGenerators--;

                            // Turn OFF
                            if (plant.marker instanceof L.CircleMarker) {
                                plant.marker.setStyle({ fillColor: '#808080' });
                            } else {
                                const isLargeMarker = ['WND', 'WIND', 'BAT', 'OTH', 'NUC'].includes(fuelType);
                                const isWind = ['WND', 'WIND'].includes(fuelType);
                                const markerSize = isWind ? 18 : (isLargeMarker ? 16 : 12);
                                const markerAnchor = isWind ? 9 : (isLargeMarker ? 8 : 6);
                                plant.marker.setIcon(L.divIcon({
                                    className: 'custom-div-icon',
                                    html: getMarkerHTML(fuelType, '#808080', 'large'),
                                    iconSize: [markerSize, markerSize],
                                    iconAnchor: [markerAnchor, markerAnchor]
                                }));
                            }
                        }
                    }
                });

                // Update flow visualization
                updateFlow();

                // Clear saved state
                stateBeforeFilter = {};
            }

            // Setup click handler for Power Plant header to toggle all plants visibility
            const plantsHeader = document.getElementById('legend-plants-header');
            let plantsVisible = true;

            plantsHeader.addEventListener('click', () => {
                plantsVisible = !plantsVisible;

                networkGraph.plants.forEach(plant => {
                    if (plant.marker) {
                        if (plantsVisible) {
                            if (!map.hasLayer(plant.marker)) {
                                plantsLayer.addLayer(plant.marker);
                            }
                        } else {
                            if (map.hasLayer(plant.marker)) {
                                plantsLayer.removeLayer(plant.marker);
                            }
                        }
                    }
                });

                // Update header styling to indicate state
                plantsHeader.style.opacity = plantsVisible ? '1' : '0.5';
                plantsHeader.style.textDecoration = plantsVisible ? 'none' : 'line-through';

                console.log(`Plants ${plantsVisible ? 'shown' : 'hidden'}`);
            });
        }

        // Setup click handlers for transmission lines and substations toggles
        function setupLayerToggles() {
            // Track visibility state
            let linesVisible = true;
            let substationsVisible = true;

            // Transmission Lines toggle
            const linesToggle = document.getElementById('legend-lines-toggle');
            linesToggle.addEventListener('click', () => {
                linesVisible = !linesVisible;

                if (linesVisible) {
                    if (!map.hasLayer(staticLinesLayer)) {
                        map.addLayer(staticLinesLayer);
                    }
                    if (!map.hasLayer(animatedLinesLayer) && activeGenerators > 0) {
                        map.addLayer(animatedLinesLayer);
                    }
                } else {
                    if (map.hasLayer(staticLinesLayer)) {
                        map.removeLayer(staticLinesLayer);
                    }
                    if (map.hasLayer(animatedLinesLayer)) {
                        map.removeLayer(animatedLinesLayer);
                    }
                }

                // Update styling to indicate state
                linesToggle.style.opacity = linesVisible ? '1' : '0.5';
                linesToggle.style.textDecoration = linesVisible ? 'none' : 'line-through';

                console.log(`Transmission lines ${linesVisible ? 'shown' : 'hidden'}`);
            });

            // Substations toggle
            const substationsToggle = document.getElementById('legend-substations-toggle');
            substationsToggle.addEventListener('click', () => {
                substationsVisible = !substationsVisible;

                if (substationsVisible) {
                    if (!map.hasLayer(substationsLayer)) {
                        map.addLayer(substationsLayer);
                    }
                } else {
                    if (map.hasLayer(substationsLayer)) {
                        map.removeLayer(substationsLayer);
                    }
                }

                // Update styling to indicate state
                substationsToggle.style.opacity = substationsVisible ? '1' : '0.5';
                substationsToggle.style.textDecoration = substationsVisible ? 'none' : 'line-through';

                console.log(`Substations ${substationsVisible ? 'shown' : 'hidden'}`);
            });
        }

        // Setup basemap toggle functionality with multi-select support
        function setupBasemapToggle() {
            const basemapOptions = document.querySelectorAll('.basemap-option');

            basemapOptions.forEach(option => {
                option.addEventListener('click', (e) => {
                    const layerType = option.getAttribute('data-layer');
                    const isMultiSelect = e.ctrlKey || e.metaKey; // Ctrl on Windows/Linux, Cmd on Mac

                    // Determine if this is an overlay basemap (not a base layer)
                    const overlayTypes = ['elevation', 'population', 'landcover', 'solarMap', 'windMap', 'populationMap'];
                    const isOverlayType = overlayTypes.includes(layerType);

                    if (isMultiSelect && isOverlayType) {
                        // Multi-select mode for overlay basemaps
                        if (activeBaseOptions.has(layerType)) {
                            // Remove this overlay
                            activeBaseOptions.delete(layerType);
                            option.classList.remove('active');
                            removeOverlayByType(layerType);
                        } else {
                            // Add this overlay
                            activeBaseOptions.add(layerType);
                            option.classList.add('active');
                            addOverlayByType(layerType);
                        }

                        console.log(`Multi-select: ${Array.from(activeBaseOptions).join(', ')}`);
                    } else {
                        // Single-select mode - clear everything and start fresh
                        // 1. Clear all previous selections
                        basemapOptions.forEach(opt => opt.classList.remove('active'));
                        if (currentBaseLayer && map.hasLayer(currentBaseLayer)) {
                            map.removeLayer(currentBaseLayer);
                            // Remove grayscale filter if present
                            if (currentBaseLayer.getContainer && typeof currentBaseLayer.getContainer === 'function') {
                                const container = currentBaseLayer.getContainer();
                                if (container) {
                                    container.classList.remove('grayscale');
                                }
                            }
                        }

                        // Remove all active overlays
                        activeOverlays.forEach(overlay => {
                            if (map.hasLayer(overlay)) {
                                map.removeLayer(overlay);
                            }
                        });
                        activeOverlays = [];
                        activeBaseOptions.clear();
                        isLandCoverActive = false;

                        // 2. Add the new selection
                        option.classList.add('active');
                        activeBaseOptions.add(layerType);

                        switch (layerType) {
                            case 'grayscale':
                                currentBaseLayer = baseLayers.grayscale.addTo(map);
                                if (currentBaseLayer.getContainer && typeof currentBaseLayer.getContainer === 'function') {
                                    const container = currentBaseLayer.getContainer();
                                    if (container) {
                                        container.classList.add('grayscale');
                                    }
                                }
                                console.log('Switched to grayscale basemap');
                                break;
                            case 'satellite':
                                currentBaseLayer = baseLayers.satellite.addTo(map);
                                currentBaseLayer.on('load', () => console.log('Satellite basemap loaded'));
                                currentBaseLayer.on('requesterror', (e) => console.error('Satellite error:', e));
                                console.log('Switched to satellite basemap');
                                break;
                            default:
                                // For overlay types, use satellite as base
                                currentBaseLayer = baseLayers.satellite.addTo(map);
                                addOverlayByType(layerType);
                                break;
                        }

                        console.log(`Switched to ${layerType} basemap`);
                    }

                });
            });
        }

        // Helper function to add an overlay by type
        function addOverlayByType(layerType) {
            let overlay = null;

            switch (layerType) {
                case 'elevation':
                    overlay = baseLayers.elevation.addTo(map);
                    console.log('Added elevation overlay');
                    break;
                case 'population':
                    overlay = populationOverlay.addTo(map);
                    console.log('Added population overlay');
                    break;
                case 'landcover':
                    overlay = baseLayers.landcover.addTo(map);
                    isLandCoverActive = true;
                    console.log('Added land cover overlay');
                    break;
                case 'solarMap':
                    overlay = baseLayers.solarMap.addTo(map);
                    overlay.on('tileload', function(e) {
                        console.log('Solar tile loaded:', e.url);
                    });
                    overlay.on('tileerror', function(e) {
                        console.error('Solar tile error:', e.url);
                    });
                    console.log('Added solar overlay');
                    break;
                case 'windMap':
                    overlay = baseLayers.windMap.addTo(map);
                    overlay.on('tileload', function(e) {
                        console.log('Wind tile loaded:', e.url);
                    });
                    overlay.on('tileerror', function(e) {
                        console.error('Wind tile error:', e.url);
                    });
                    console.log('Added wind overlay');
                    break;
                case 'populationMap':
                    overlay = baseLayers.populationMap.addTo(map);
                    overlay.on('tileload', function(e) {
                        console.log('Population tile loaded:', e.url);
                    });
                    overlay.on('tileerror', function(e) {
                        console.error('Population tile error:', e.url);
                    });
                    console.log('Added population density overlay');
                    break;
            }

            if (overlay) {
                activeOverlays.push(overlay);
                // Adjust opacity of all overlays based on count
                updateOverlayOpacity();
            }
        }

        // Helper function to update opacity of all active overlays based on count
        function updateOverlayOpacity() {
            const overlayCount = activeOverlays.length;

            if (overlayCount === 0) {
                return;
            }

            // Calculate opacity based on number of overlays
            // With 1 overlay: keep original opacity (0.7-0.9)
            // With 2 overlays: reduce to 0.5 each for better blending
            // With 3+ overlays: reduce further to prevent complete occlusion
            let targetOpacity;

            if (overlayCount === 1) {
                targetOpacity = 0.8; // Single layer - keep it visible
            } else if (overlayCount === 2) {
                targetOpacity = 0.5; // Two layers - 50% each for blending
            } else if (overlayCount === 3) {
                targetOpacity = 0.4; // Three layers - reduce more
            } else {
                targetOpacity = 0.35; // Four or more - even more transparent
            }

            // Apply the calculated opacity to all active overlays
            activeOverlays.forEach(overlay => {
                if (overlay && overlay.setOpacity) {
                    overlay.setOpacity(targetOpacity);
                }
            });

            console.log(`Updated ${overlayCount} overlay(s) to opacity: ${targetOpacity}`);
        }

        // Helper function to remove an overlay by type
        function removeOverlayByType(layerType) {
            // Find and remove the overlay from the map
            activeOverlays = activeOverlays.filter(overlay => {
                // Check if this overlay corresponds to the layer type we want to remove
                let shouldRemove = false;

                switch (layerType) {
                    case 'elevation':
                        shouldRemove = (overlay === baseLayers.elevation);
                        break;
                    case 'population':
                        shouldRemove = (overlay === populationOverlay);
                        break;
                    case 'landcover':
                        shouldRemove = (overlay === baseLayers.landcover);
                        if (shouldRemove) isLandCoverActive = false;
                        break;
                    case 'solarMap':
                        shouldRemove = (overlay === baseLayers.solarMap);
                        break;
                    case 'windMap':
                        shouldRemove = (overlay === baseLayers.windMap);
                        break;
                    case 'populationMap':
                        shouldRemove = (overlay === baseLayers.populationMap);
                        break;
                }

                if (shouldRemove && map.hasLayer(overlay)) {
                    map.removeLayer(overlay);
                    console.log(`Removed ${layerType} overlay`);
                }

                return !shouldRemove; // Keep overlays that don't match
            });

            // Adjust opacity of remaining overlays
            updateOverlayOpacity();
        }

        // NLCD Land Cover color mapping from the legend
        const nlcdColorMap = {
            '11': { color: [70, 107, 159], name: 'Open Water' },
            '12': { color: [209, 222, 248], name: 'Perennial Ice/Snow' },
            '21': { color: [222, 197, 197], name: 'Developed, Open Space' },
            '22': { color: [217, 146, 130], name: 'Developed, Low Intensity' },
            '23': { color: [235, 0, 0], name: 'Developed, Medium Intensity' },
            '24': { color: [171, 0, 0], name: 'Developed, High Intensity' },
            '31': { color: [179, 172, 159], name: 'Barren Land (Rock/Sand/Clay)' },
            '41': { color: [104, 171, 95], name: 'Deciduous Forest' },
            '42': { color: [28, 95, 44], name: 'Evergreen Forest' },
            '43': { color: [181, 197, 143], name: 'Mixed Forest' },
            '52': { color: [204, 184, 121], name: 'Shrub/Scrub' },
            '71': { color: [223, 223, 194], name: 'Grassland/Herbaceous' },
            '81': { color: [220, 217, 57], name: 'Pasture/Hay' },
            '82': { color: [171, 108, 40], name: 'Cultivated Crops' },
            '90': { color: [184, 217, 235], name: 'Woody Wetlands' },
            '95': { color: [108, 159, 184], name: 'Emergent Herbaceous Wetlands' }
        };

        // Function to find closest NLCD class from RGB color
        function getNLCDClass(r, g, b) {
            let minDistance = Infinity;
            let closestClass = null;

            for (const [code, data] of Object.entries(nlcdColorMap)) {
                const [cr, cg, cb] = data.color;
                // Calculate Euclidean distance in RGB space
                const distance = Math.sqrt(
                    Math.pow(r - cr, 2) +
                    Math.pow(g - cg, 2) +
                    Math.pow(b - cb, 2)
                );

                if (distance < minDistance) {
                    minDistance = distance;
                    closestClass = data.name;
                }
            }

            // Only return if color is reasonably close (threshold to avoid noise)
            return minDistance < 50 ? closestClass : null;
        }

        // Create land cover hover tooltip
        var landCoverTooltip = L.tooltip({
            permanent: false,
            direction: 'top',
            className: 'land-cover-tooltip',
            offset: [0, -10]
        });

        // Variable to track if land cover layer is active
        var isLandCoverActive = false;

        // Debounce function to limit GetFeatureInfo requests
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Variable to track if mouse is over a map feature
        var isOverMapFeature = false;

        // Setup land cover hover functionality using WMS GetFeatureInfo
        function setupLandCoverHover() {
            // Debounced function to query WMS for feature info
            const queryLandCover = debounce(function(latlng) {
                // Don't show land cover tooltip if:
                // 1. Land cover layer is not active
                // 2. Mouse is over a power plant or other map feature
                // 3. Land cover overlay is not in the active overlays array
                const hasLandCoverActive = activeOverlays.includes(baseLayers.landcover);
                if (!isLandCoverActive || !hasLandCoverActive || isOverMapFeature) {
                    if (map.hasLayer(landCoverTooltip)) {
                        map.closeTooltip(landCoverTooltip);
                    }
                    return;
                }

                // Get map parameters for GetFeatureInfo request
                const size = map.getSize();
                const bounds = map.getBounds();
                const point = map.latLngToContainerPoint(latlng);

                // Build GetFeatureInfo URL
                const url = 'https://www.mrlc.gov/geoserver/wms?' +
                    'SERVICE=WMS&' +
                    'VERSION=1.1.1&' +
                    'REQUEST=GetFeatureInfo&' +
                    'LAYERS=mrlc_display:NLCD_2021_Land_Cover_L48&' +
                    'QUERY_LAYERS=mrlc_display:NLCD_2021_Land_Cover_L48&' +
                    'STYLES=&' +
                    'BBOX=' + bounds.toBBoxString() + '&' +
                    'WIDTH=' + size.x + '&' +
                    'HEIGHT=' + size.y + '&' +
                    'FORMAT=image/png&' +
                    'INFO_FORMAT=application/json&' +
                    'TRANSPARENT=true&' +
                    'X=' + Math.floor(point.x) + '&' +
                    'Y=' + Math.floor(point.y) + '&' +
                    'SRS=EPSG:4326&' +
                    'FEATURE_COUNT=1';

                // Fetch feature info
                fetch(url)
                    .then(response => response.json())
                    .then(data => {
                        // Check again if mouse moved over a feature while we were fetching
                        if (isOverMapFeature) {
                            if (map.hasLayer(landCoverTooltip)) {
                                map.closeTooltip(landCoverTooltip);
                            }
                            return;
                        }

                        if (data.features && data.features.length > 0) {
                            const feature = data.features[0];
                            const properties = feature.properties;

                            // Get NLCD value from PALETTE_INDEX
                            let nlcdValue = properties.PALETTE_INDEX ||
                                          properties.NLCD_Land_Cover_Class ||
                                          properties.land_cover ||
                                          properties.value ||
                                          properties.GRAY_INDEX ||
                                          properties.grid_code;

                            if (nlcdValue) {
                                // Convert to string and pad with zero if needed
                                const nlcdCode = String(nlcdValue).padStart(2, '0');
                                const landCoverData = nlcdColorMap[nlcdCode];

                                if (landCoverData) {
                                    landCoverTooltip.setLatLng(latlng)
                                        .setContent(`<strong>Land Cover:</strong><br>${landCoverData.name}`)
                                        .addTo(map);
                                } else {
                                    // Show raw value if not in our map
                                    landCoverTooltip.setLatLng(latlng)
                                        .setContent(`<strong>Land Cover:</strong><br>Class ${nlcdCode}`)
                                        .addTo(map);
                                }
                            } else {
                                if (map.hasLayer(landCoverTooltip)) {
                                    map.closeTooltip(landCoverTooltip);
                                }
                            }
                        } else {
                            if (map.hasLayer(landCoverTooltip)) {
                                map.closeTooltip(landCoverTooltip);
                            }
                        }
                    })
                    .catch(error => {
                        if (map.hasLayer(landCoverTooltip)) {
                            map.closeTooltip(landCoverTooltip);
                        }
                    });
            }, 150); // Wait 150ms after mouse stops moving

            // Listen to mouse movement
            map.on('mousemove', function(e) {
                queryLandCover(e.latlng);
            });

            // Track when mouse enters/leaves map features (power plants, substations, lines)
            map.on('mouseover', function(e) {
                if (e.layer && (e.layer.feature || e.layer instanceof L.Marker || e.layer instanceof L.CircleMarker || e.layer instanceof L.Polyline)) {
                    isOverMapFeature = true;
                    if (map.hasLayer(landCoverTooltip)) {
                        map.closeTooltip(landCoverTooltip);
                    }
                }
            });

            map.on('mouseout', function(e) {
                if (e.layer && (e.layer.feature || e.layer instanceof L.Marker || e.layer instanceof L.CircleMarker || e.layer instanceof L.Polyline)) {
                    isOverMapFeature = false;
                }
            });
        }

        // Setup home button to reset view to default California bounds
        function setupHomeButton() {
            // Create custom control for home button
            L.Control.Home = L.Control.extend({
                onAdd: function(map) {
                    var container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-home');
                    container.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>';
                    container.title = 'Reset to default view';

                    L.DomEvent.disableClickPropagation(container);
                    L.DomEvent.on(container, 'click', function() {
                        fitMapToData();
                    });

                    return container;
                },
                onRemove: function(map) {
                    // Nothing to do here
                }
            });

            L.control.home = function(opts) {
                return new L.Control.Home(opts);
            }

            // Add the home button to the map
            L.control.home({ position: 'topleft' }).addTo(map);
        }

        // Removed custom generator functionality - we're using real power plant data

        // Custom triangle marker
        L.TriangleMarker = L.CircleMarker.extend({
            options: { rotation: 0 }
        });
        L.triangleMarker = function (latlng, options) {
            return new L.TriangleMarker(latlng, options);
        };

        // Build network graph from loaded data
        function buildNetworkGraph() {
            const TOLERANCE = 0.01; // ~1km tolerance for matching line endpoints to substations

            // 1. Build substations nodes
            substationsData.features.forEach((feature, idx) => {
                const props = feature.properties;
                const coords = feature.geometry.coordinates;

                // Validate coordinates
                if (!coords || coords.length < 2 ||
                    typeof coords[0] !== 'number' || typeof coords[1] !== 'number' ||
                    isNaN(coords[0]) || isNaN(coords[1])) {
                    console.warn(`Invalid substation coordinates at index ${idx}:`, coords);
                    return;
                }

                networkGraph.substations.push({
                    id: `sub_${idx}`,
                    latlng: [coords[1], coords[0]], // Leaflet uses [lat, lng]
                    name: props.Name || 'Unknown',
                    voltage: props.Max_Voltage || 0,
                    connectedLines: [],
                    feature: feature
                });
            });

            // Create substation points collection once (outside the loop for efficiency)
            const substationPoints = turf.featureCollection(
                networkGraph.substations.map(sub =>
                    turf.point([sub.latlng[1], sub.latlng[0]], {id: sub.id})
                )
            );

            if (substationPoints.features.length === 0) {
                console.error('No valid substations found!');
                return;
            }

            // 2. Build transmission lines and connect to substations
            transmissionData.features.forEach((feature, idx) => {
                const coords = feature.geometry.coordinates;
                if (!coords || coords.length < 2) return;

                // Handle MultiLineString (nested arrays) - flatten to first linestring
                let actualCoords = coords;
                if (Array.isArray(coords[0][0])) {
                    // This is a MultiLineString - use the first line
                    actualCoords = coords[0];
                    if (!actualCoords || actualCoords.length < 2) return;
                }

                // Validate start and end coordinates
                const startCoord = actualCoords[0];
                const endCoord = actualCoords[actualCoords.length - 1];

                if (!startCoord || startCoord.length < 2 ||
                    typeof startCoord[0] !== 'number' || typeof startCoord[1] !== 'number' ||
                    isNaN(startCoord[0]) || isNaN(startCoord[1])) {
                    console.warn(`Invalid start coord for line ${idx}:`, startCoord);
                    return;
                }

                if (!endCoord || endCoord.length < 2 ||
                    typeof endCoord[0] !== 'number' || typeof endCoord[1] !== 'number' ||
                    isNaN(endCoord[0]) || isNaN(endCoord[1])) {
                    console.warn(`Invalid end coord for line ${idx}:`, endCoord);
                    return;
                }

                // Get start and end points
                const startPoint = turf.point(startCoord);
                const endPoint = turf.point(endCoord);

                // Find nearest substations to start and end
                const nearestStart = turf.nearestPoint(startPoint, substationPoints);
                const nearestEnd = turf.nearestPoint(endPoint, substationPoints);

                // Only connect if within tolerance
                const distStart = turf.distance(startPoint, nearestStart, {units: 'kilometers'});
                const distEnd = turf.distance(endPoint, nearestEnd, {units: 'kilometers'});

                let startNodeId = null, endNodeId = null;

                if (distStart < TOLERANCE) {
                    startNodeId = nearestStart.properties.id;
                }
                if (distEnd < TOLERANCE) {
                    endNodeId = nearestEnd.properties.id;
                }

                const lineId = `line_${idx}`;
                networkGraph.lines.push({
                    id: lineId,
                    coords: actualCoords, // Use actualCoords instead of coords
                    startNodeId: startNodeId,
                    endNodeId: endNodeId,
                    feature: feature
                });

                // Add line to substations' connected lines
                if (startNodeId) {
                    const sub = networkGraph.substations.find(s => s.id === startNodeId);
                    if (sub) sub.connectedLines.push(lineId);
                    if (!networkGraph.linesBySubstation[startNodeId]) {
                        networkGraph.linesBySubstation[startNodeId] = [];
                    }
                    networkGraph.linesBySubstation[startNodeId].push(lineId);
                }
                if (endNodeId && endNodeId !== startNodeId) {
                    const sub = networkGraph.substations.find(s => s.id === endNodeId);
                    if (sub) sub.connectedLines.push(lineId);
                    if (!networkGraph.linesBySubstation[endNodeId]) {
                        networkGraph.linesBySubstation[endNodeId] = [];
                    }
                    networkGraph.linesBySubstation[endNodeId].push(lineId);
                }
            });

            // 3. Connect plants to nearest substations
            plantsData.features.forEach((feature, idx) => {
                const props = feature.properties;
                const coords = feature.geometry.coordinates;

                // Validate coordinates
                if (!coords || coords.length < 2 ||
                    typeof coords[0] !== 'number' || typeof coords[1] !== 'number' ||
                    isNaN(coords[0]) || isNaN(coords[1])) {
                    console.warn(`Invalid plant coordinates at index ${idx}:`, coords);
                    return;
                }

                const plantPoint = turf.point(coords);

                // Reuse substationPoints already created above
                const nearest = turf.nearestPoint(plantPoint, substationPoints);

                networkGraph.plants.push({
                    id: `plant_${idx}`,
                    latlng: [coords[1], coords[0]],
                    name: props.PlantName || 'Unknown',
                    fuel: props.PriEnergySource || 'UNKNOWN',
                    capacity: props.Capacity_Latest || 0,
                    nearestSubstationId: nearest.properties.id,
                    feature: feature,
                    isOn: false
                });
            });

            console.log(`Network graph built: ${networkGraph.substations.length} substations, ${networkGraph.plants.length} plants, ${networkGraph.lines.length} lines`);

            // Log connectivity stats
            const connectedLines = networkGraph.lines.filter(l => l.startNodeId || l.endNodeId).length;
            console.log(`${connectedLines} lines connected to substations (${(connectedLines/networkGraph.lines.length*100).toFixed(1)}%)`);
        }

        // BFS to find all lines connected to a substation
        function getConnectedLines(startSubstationId) {
            const visited = new Set();
            const connectedLineIds = new Set();
            const queue = [startSubstationId];

            while (queue.length > 0) {
                const currentSubId = queue.shift();

                if (visited.has(currentSubId)) continue;
                visited.add(currentSubId);

                // Get all lines connected to this substation
                const lines = networkGraph.linesBySubstation[currentSubId] || [];

                lines.forEach(lineId => {
                    connectedLineIds.add(lineId);

                    // Find the line and get the other end substation
                    const line = networkGraph.lines.find(l => l.id === lineId);
                    if (!line) return;

                    // Add the other end to the queue
                    if (line.startNodeId === currentSubId && line.endNodeId) {
                        if (!visited.has(line.endNodeId)) {
                            queue.push(line.endNodeId);
                        }
                    } else if (line.endNodeId === currentSubId && line.startNodeId) {
                        if (!visited.has(line.startNodeId)) {
                            queue.push(line.startNodeId);
                        }
                    }
                });
            }

            return Array.from(connectedLineIds);
        }

        // Generate HTML for plant marker based on fuel type and color
        // Optional size parameter: 'normal' (12px default) or 'large' (18px for wind, 16px for battery/nuclear)
        function getMarkerHTML(fuelType, color, size = 'normal') {
            const isLarge = size === 'large';
            const windSize = isLarge ? 18 : 12;
            const windHalfSize = isLarge ? 9 : 6;
            const batterySize = isLarge ? 16 : 12;
            const batteryHalfSize = isLarge ? 8 : 6;
            const nuclearSize = isLarge ? 16 : 12;
            const nuclearHalfSize = isLarge ? 8 : 6;

            switch (fuelType.toUpperCase()) {
                case 'WND':
                case 'WIND':
                    return `<svg width="${windSize}" height="${windSize}" style="margin-left: -${windHalfSize}px; margin-top: -${windHalfSize}px;"><polygon points="${windHalfSize},${isLarge ? 3 : 2} ${isLarge ? 16 : 11},${isLarge ? 15 : 10} ${isLarge ? 2 : 1},${isLarge ? 15 : 10}" fill="${color}" stroke="#000" stroke-width="1"/></svg>`;

                case 'NG':
                case 'GAS':
                case 'OGW':
                case 'OG':
                    return `<div style="width: 10px; height: 10px; background-color: ${color}; border: 1px solid #000; margin-left: -5px; margin-top: -5px;"></div>`;

                case 'WAT':
                    return `<svg width="12" height="12" style="margin-left: -6px; margin-top: -6px;"><polygon points="3,1 9,1 11.5,6 9,11 3,11 0.5,6" fill="${color}" stroke="#000" stroke-width="1"/></svg>`;

                case 'GEO':
                case 'WH':
                    return `<div style="width: 8px; height: 8px; background-color: ${color}; border: 1px solid #000; transform: rotate(45deg); margin-left: -4px; margin-top: -4px;"></div>`;

                case 'NUC':
                    return `<svg width="${nuclearSize}" height="${nuclearSize}" style="margin-left: -${nuclearHalfSize}px; margin-top: -${nuclearHalfSize}px;"><polygon points="${nuclearHalfSize},${isLarge ? 1.5 : 1} ${isLarge ? 14 : 11},${isLarge ? 5 : 4} ${isLarge ? 12 : 9},${isLarge ? 13 : 10} ${isLarge ? 4 : 3},${isLarge ? 13 : 10} ${isLarge ? 2 : 1},${isLarge ? 5 : 4}" fill="${color}" stroke="#000" stroke-width="1"/></svg>`;

                case 'LFG':
                case 'WDS':
                case 'OBG':
                case 'MSW':
                case 'AB':
                case 'OBS':
                    return `<svg width="12" height="12" style="margin-left: -6px; margin-top: -6px;"><rect x="5" y="1" width="2" height="10" fill="${color}" stroke="#000" stroke-width="0.5"/><rect x="1" y="5" width="10" height="2" fill="${color}" stroke="#000" stroke-width="0.5"/></svg>`;

                case 'BIT':
                case 'OIL':
                case 'DFO':
                case 'SUB':
                case 'JF':
                case 'BLQ':
                case 'PC': // Petroleum Coke - grouped with Coal/Oil
                    return `<svg width="12" height="12" style="margin-left: -6px; margin-top: -6px;"><line x1="2" y1="2" x2="10" y2="10" stroke="#000" stroke-width="2"/><line x1="10" y1="2" x2="2" y2="10" stroke="#000" stroke-width="2"/><line x1="2" y1="2" x2="10" y2="10" stroke="${color}" stroke-width="1.5"/><line x1="10" y1="2" x2="2" y2="10" stroke="${color}" stroke-width="1.5"/></svg>`;

                case 'BAT':
                case 'OTH': // Vaca Dixon Battery Storage is marked as OTH
                    return `<svg width="${batterySize}" height="${batterySize}" style="margin-left: -${batteryHalfSize}px; margin-top: -${batteryHalfSize}px;"><rect x="${isLarge ? 3 : 2}" y="${isLarge ? 5 : 4}" width="${isLarge ? 10 : 8}" height="${isLarge ? 6 : 5}" fill="${color}" stroke="#000" stroke-width="1"/><rect x="${isLarge ? 5 : 4}" y="${isLarge ? 4 : 3}" width="${isLarge ? 6 : 4}" height="1" fill="${color}" stroke="#000" stroke-width="0.5"/></svg>`;

                default:
                    return `<svg width="12" height="12" style="margin-left: -6px; margin-top: -6px;"><polygon points="4,1 8,1 11,4 11,8 8,11 4,11 1,8 1,4" fill="${color}" stroke="#000" stroke-width="1"/></svg>`;
            }
        }

        // Get fuel color for plant
        function getFuelColor(fuel) {
            switch ((fuel || 'UNKNOWN').toUpperCase()) {
                case 'SUN': return '#FFD700'; // Solar - Gold
                case 'WND': return '#1E90FF'; // Wind - Dodger Blue
                case 'WIND': return '#1E90FF'; // Wind alternate
                case 'NG': return '#FF4500'; // Natural Gas - Orange-Red
                case 'GAS': return '#FF4500'; // Natural Gas alternate
                case 'WAT': return '#00CED1'; // Water/Hydro - Dark Turquoise
                case 'LFG': return '#D2691E'; // Landfill Gas - Chocolate (brighter brown)
                case 'GEO': return '#DC143C'; // Geothermal - Crimson
                case 'WDS': return '#D2691E'; // Wood/Biomass - Chocolate (brighter brown)
                case 'OBG': return '#D2691E'; // Other Biogas - Chocolate (brighter brown)
                case 'BAT': return '#FFD700'; // Battery Storage - Gold (energy storage)
                case 'OTH': return '#FFD700'; // Other (Vaca Dixon Battery) - Gold
                case 'BIT': return '#FF6347'; // Bituminous Coal - Tomato (bright red-orange)
                case 'PC': return '#FF6347'; // Petroleum Coke - Tomato (bright red-orange)
                case 'OGW': return '#FF4500'; // Other Gas - Orange-Red
                case 'OIL': return '#FF6347'; // Oil - Tomato (bright red-orange)
                case 'DFO': return '#FF6347'; // Distillate Fuel Oil - Tomato (bright red-orange)
                case 'MSW': return '#D2691E'; // Municipal Solid Waste - Chocolate (brighter brown)
                case 'WH': return '#DC143C'; // Waste Heat - Crimson
                case 'NUC': return '#BA55D3'; // Nuclear - Medium Orchid (brighter purple)
                case 'AB': return '#D2691E'; // Agricultural Byproduct - Chocolate (brighter brown)
                case 'SUB': return '#FF6347'; // Sub-Bituminous Coal - Tomato (bright red-orange)
                case 'JF': return '#FF6347'; // Jet Fuel - Tomato (bright red-orange)
                case 'BLQ': return '#FF6347'; // Black Liquor - Tomato (bright red-orange)
                case 'OBS': return '#D2691E'; // Other Biomass Solids - Chocolate (brighter brown)
                case 'OG': return '#FF4500'; // Other Gas - Orange-Red
                default: return '#FF1493'; // Unknown - Deep Pink
            }
        }

        // Render map with all layers
        function renderMap() {
            // Initialize layers
            staticLinesLayer = L.layerGroup().addTo(map);
            animatedLinesLayer = L.layerGroup();

            // Render transmission lines (visible but subtle initially)
            networkGraph.lines.forEach(lineData => {
                const coords = lineData.coords.map(c => [c[1], c[0]]); // Convert to [lat, lng]

                // Static line in subtle cyan/teal color (visible on greyscale)
                const staticLine = L.polyline(coords, {
                    color: '#4A90A4',  // Muted teal-blue that shows on greyscale
                    weight: 2,
                    opacity: 0.6
                });
                staticLine.lineId = lineData.id;
                staticLinesLayer.addLayer(staticLine);

                // Pre-create animated line (hidden initially)
                const antPath = L.polyline.antPath(coords, {
                    color: '#39FF14', // Neon green flow
                    weight: 3,
                    opacity: 0.8,
                    delay: 500,
                    dashArray: [10, 20],
                    pulseColor: '#FFFFFF',
                    hardwareAccelerated: true
                });
                antPath.lineId = lineData.id;
                lineData.antPath = antPath;
            });

            // Render substations (smaller neon green circles)
            networkGraph.substations.forEach(subData => {
                const marker = L.circleMarker(subData.latlng, {
                    radius: 2,  // Reduced from 4 to 2
                    fillColor: '#39FF14', // Neon green
                    color: '#000',
                    weight: 0.5,  // Thinner border
                    opacity: 0.8,
                    fillOpacity: 0.7
                });

                const props = subData.feature.properties;
                const name = props.Name || 'Unknown Substation';
                const voltage = props.Max_Voltage || 'Unknown';
                const county = props.COUNTY || 'Unknown';

                // Only bind tooltip (shows on hover) - no popup needed
                marker.bindTooltip(`<b>${name}</b> Substation<br>${voltage} kV<br>${county}`, {
                    direction: 'top',
                    offset: [0, -5],
                    opacity: 0.9
                });

                substationsLayer.addLayer(marker);
                subData.marker = marker;
            });

            // Render power plants with different shapes based on fuel type (all same small size)
            networkGraph.plants.forEach(plantData => {
                const color = getFuelColor(plantData.fuel);
                const fuelType = (plantData.fuel || 'UNKNOWN').toUpperCase();

                let marker;

                // Create different shapes based on fuel type (all size 12px)
                switch(fuelType) {
                    case 'SUN': // Solar - Circle
                        marker = L.circleMarker(plantData.latlng, {
                            radius: 6,
                            fillColor: '#808080',
                            color: '#000',
                            weight: 1,
                            opacity: 1,
                            fillOpacity: 0.8
                        });
                        break;

                    case 'WND': // Wind - Triangle pointing up (SVG for consistent border) - LARGER SIZE (18px)
                    case 'WIND':
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: getMarkerHTML(fuelType, '#808080', 'large'),
                                iconSize: [18, 18],
                                iconAnchor: [9, 9]
                            })
                        });
                        break;

                    case 'NG': // Natural Gas - Square
                    case 'GAS':
                    case 'OGW':
                    case 'OG':
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<div style="width: 10px; height: 10px; background-color: #808080; border: 1px solid #000; margin-left: -5px; margin-top: -5px;"></div>`,
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        });
                        break;

                    case 'WAT': // Hydro - Hexagon with border
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<svg width="12" height="12" style="margin-left: -6px; margin-top: -6px;"><polygon points="3,1 9,1 11.5,6 9,11 3,11 0.5,6" fill="#808080" stroke="#000" stroke-width="1"/></svg>`,
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        });
                        break;

                    case 'GEO': // Geothermal - Diamond with border
                    case 'WH':
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<div style="width: 8px; height: 8px; background-color: #808080; border: 1px solid #000; transform: rotate(45deg); margin-left: -4px; margin-top: -4px;"></div>`,
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        });
                        break;

                    case 'PC': // Petroleum Coke - Pentagon with border
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<svg width="12" height="12" style="margin-left: -6px; margin-top: -6px;"><polygon points="6,1 11,4 9,10 3,10 1,4" fill="#808080" stroke="#000" stroke-width="1"/></svg>`,
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        });
                        break;

                    case 'NUC': // Nuclear - Pentagon with border - LARGER SIZE
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: getMarkerHTML(fuelType, '#808080', 'large'),
                                iconSize: [16, 16],
                                iconAnchor: [8, 8]
                            })
                        });
                        break;

                    case 'LFG': // Landfill Gas - Plus sign
                    case 'WDS':
                    case 'OBG':
                    case 'MSW':
                    case 'AB':
                    case 'OBS':
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<svg width="12" height="12" style="margin-left: -6px; margin-top: -6px;"><rect x="5" y="1" width="2" height="10" fill="#808080" stroke="#000" stroke-width="0.5"/><rect x="1" y="5" width="10" height="2" fill="#808080" stroke="#000" stroke-width="0.5"/></svg>`,
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        });
                        break;

                    case 'BIT': // Coal/Oil - X shape
                    case 'OIL':
                    case 'DFO':
                    case 'SUB':
                    case 'JF':
                    case 'BLQ':
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<svg width="12" height="12" style="margin-left: -6px; margin-top: -6px;"><line x1="2" y1="2" x2="10" y2="10" stroke="#000" stroke-width="2"/><line x1="10" y1="2" x2="2" y2="10" stroke="#000" stroke-width="2"/><line x1="2" y1="2" x2="10" y2="10" stroke="#808080" stroke-width="1.5"/><line x1="10" y1="2" x2="2" y2="10" stroke="#808080" stroke-width="1.5"/></svg>`,
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        });
                        break;

                    case 'BAT': // Battery - Rectangle with border - LARGER SIZE
                    case 'OTH': // Other (often battery storage)
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: getMarkerHTML(fuelType, '#808080', 'large'),
                                iconSize: [16, 16],
                                iconAnchor: [8, 8]
                            })
                        });
                        break;

                    default: // Other - Octagon with border
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<svg width="12" height="12" style="margin-left: -6px; margin-top: -6px;"><polygon points="4,1 8,1 11,4 11,8 8,11 4,11 1,8 1,4" fill="#808080" stroke="#000" stroke-width="1"/></svg>`,
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        });
                }

                const name = plantData.name;
                const fuel = plantData.fuel;
                const capacity = plantData.capacity;

                // Only bind tooltip (shows on hover) - no popup needed
                marker.bindTooltip(`<b>${name}</b><br>Type: ${fuel}<br>Capacity: ${capacity} MW<br><i>Click to turn ON/OFF</i>`, {
                    direction: 'top',
                    offset: [0, -10],
                    opacity: 0.9
                });

                // Click handler to toggle plant on/off
                marker.on('click', function(e) {
                    L.DomEvent.stopPropagation(e); // Prevent map click

                    // Close any open tooltips to prevent lingering
                    marker.closeTooltip();

                    plantData.isOn = !plantData.isOn;

                    if (plantData.isOn) {
                        activeGenerators++;

                        // Update marker color based on type
                        if (marker instanceof L.CircleMarker) {
                            marker.setStyle({ fillColor: color });
                        } else {
                            const isLargeMarker = ['WND', 'WIND', 'BAT', 'OTH', 'NUC'].includes(fuelType);
                            const isWind = ['WND', 'WIND'].includes(fuelType);
                            const markerSize = isWind ? 18 : (isLargeMarker ? 16 : 12);
                            const markerAnchor = isWind ? 9 : (isLargeMarker ? 8 : 6);
                            marker.setIcon(L.divIcon({
                                className: 'custom-div-icon',
                                html: getMarkerHTML(fuelType, color, 'large'),
                                iconSize: [markerSize, markerSize],
                                iconAnchor: [markerAnchor, markerAnchor]
                            }));
                        }
                    } else {
                        activeGenerators--;

                        // Reset to grey
                        if (marker instanceof L.CircleMarker) {
                            marker.setStyle({ fillColor: '#808080' });
                        } else {
                            const isLargeMarker = ['WND', 'WIND', 'BAT', 'OTH', 'NUC'].includes(fuelType);
                            const isWind = ['WND', 'WIND'].includes(fuelType);
                            const markerSize = isWind ? 18 : (isLargeMarker ? 16 : 12);
                            const markerAnchor = isWind ? 9 : (isLargeMarker ? 8 : 6);
                            marker.setIcon(L.divIcon({
                                className: 'custom-div-icon',
                                html: getMarkerHTML(fuelType, '#808080', 'large'),
                                iconSize: [markerSize, markerSize],
                                iconAnchor: [markerAnchor, markerAnchor]
                            }));
                        }
                    }

                    updateFlow();
                });

                plantsLayer.addLayer(marker);
                plantData.marker = marker;
            });

            console.log('Map rendered with all layers.');

            // Fit map to show all data points
            fitMapToData();
        }

        // Fit map bounds to show all California data
        function fitMapToData() {
            try {
                // Calculate bounds manually from all coordinates
                let minLat = Infinity, maxLat = -Infinity;
                let minLng = Infinity, maxLng = -Infinity;

                // Get bounds from substations
                networkGraph.substations.forEach(sub => {
                    const lat = sub.latlng[0];
                    const lng = sub.latlng[1];
                    if (lat < minLat) minLat = lat;
                    if (lat > maxLat) maxLat = lat;
                    if (lng < minLng) minLng = lng;
                    if (lng > maxLng) maxLng = lng;
                });

                // Get bounds from plants
                networkGraph.plants.forEach(plant => {
                    const lat = plant.latlng[0];
                    const lng = plant.latlng[1];
                    if (lat < minLat) minLat = lat;
                    if (lat > maxLat) maxLat = lat;
                    if (lng < minLng) minLng = lng;
                    if (lng > maxLng) maxLng = lng;
                });

                // Create bounds
                const bounds = [[minLat, minLng], [maxLat, maxLng]];

                // Fit map to bounds with some padding
                map.fitBounds(bounds, {
                    padding: [50, 50],  // 50px padding on all sides
                    maxZoom: 7          // Don't zoom in too much
                });

                console.log('Map fitted to data bounds:', bounds);
            } catch (error) {
                console.error('Error fitting map to bounds:', error);
                // Fallback to California center
                map.setView([36.7783, -119.4179], 6);
            }
        }

        // Updated function to show flow only on connected lines
        function updateFlow() {
            // Update counter display
            document.getElementById('activeCount').textContent = activeGenerators;

            // Clear animated layer
            animatedLinesLayer.clearLayers();

            if (activeGenerators > 0) {
                // Find all active plants
                const activePlants = networkGraph.plants.filter(p => p.isOn);

                // Collect all connected line IDs from all active plants
                const allConnectedLineIds = new Set();

                activePlants.forEach(plant => {
                    const substationId = plant.nearestSubstationId;
                    if (substationId) {
                        const connectedLines = getConnectedLines(substationId);
                        connectedLines.forEach(lineId => allConnectedLineIds.add(lineId));
                    }
                });

                console.log(`${activePlants.length} active plants, ${allConnectedLineIds.size} lines to animate`);

                // Update static lines: hide animated ones, show others in teal-blue
                staticLinesLayer.eachLayer(function(layer) {
                    if (allConnectedLineIds.has(layer.lineId)) {
                        // Hide this static line (will be replaced by animated version)
                        layer.setStyle({ opacity: 0 });
                    } else {
                        // Show this static line in teal-blue
                        layer.setStyle({
                            color: '#4A90A4',
                            opacity: 0.6
                        });
                    }
                });

                // Add animated ant paths for connected lines
                allConnectedLineIds.forEach(lineId => {
                    const lineData = networkGraph.lines.find(l => l.id === lineId);
                    if (lineData && lineData.antPath) {
                        animatedLinesLayer.addLayer(lineData.antPath);
                    }
                });

                // Show animated layer (static layer stays visible)
                if (!map.hasLayer(animatedLinesLayer)) {
                    animatedLinesLayer.addTo(map);
                }
            } else {
                // No active generators - restore all static lines to teal-blue
                staticLinesLayer.eachLayer(function(layer) {
                    layer.setStyle({
                        color: '#4A90A4',
                        opacity: 0.6
                    });
                });

                // Remove animated layer
                if (map.hasLayer(animatedLinesLayer)) {
                    map.removeLayer(animatedLinesLayer);
                }
            }
        }
    </script>
</body>
</html>

