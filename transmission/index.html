<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>California Power Grid Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/esri-leaflet@3.0.10/dist/esri-leaflet.js"></script>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
        }

        #map {
            height: 100vh;
            /* Full viewport height */
            width: 100%;
            /* Full width */
        }

        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            max-width: 300px;
        }

        #controls p {
            margin: 5px 0;
        }

        .grayscale {
            filter: grayscale(100%);
            -webkit-filter: grayscale(100%);
        }

        #legend {
            position: absolute;
            bottom: 20px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            display: flex;
            gap: 10px;
            align-items: stretch;
        }

        #legend-items {
            display: flex;
            flex-direction: column;
        }

        #capacity-slider-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 5px 0 5px 10px;
            border-left: 1px solid #eee;
            min-width: 50px;
        }

        #capacitySlider {
            writing-mode: bt-lr;
            /* IE */
            -webkit-appearance: slider-vertical;
            /* WebKit */
            appearance: slider-vertical;
            width: 6px;
            flex-grow: 1;
            outline: none;
            margin: 5px 0;
            cursor: pointer;
            /* Gradient background */
            background: linear-gradient(to top, #4CAF50, #F44336);
            border-radius: 3px;
            /* Default thumb color, will be overridden by JS */
            --thumb-color: #4CAF50;
        }

        /* WebKit specific styling for the thumb to support dynamic color */
        #capacitySlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--thumb-color);
            border: 1px solid #fff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            margin-left: -4px;
            /* Adjust centering if needed */
        }

        .slider-label {
            font-size: 10px;
            color: #666;
            font-weight: bold;
            white-space: nowrap;
        }

        .legend-item {
            margin: 2px 0;
            font-size: 11px;
        }

        #legend strong {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .legend-color {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 5px;
            vertical-align: middle;
        }

        .custom-div-icon {
            background: transparent !important;
            border: none !important;
        }

        .leaflet-tooltip {
            background-color: rgba(255, 255, 255, 0.95);
            border: 2px solid #333;
            border-radius: 6px;
            padding: 8px;
            font-size: 12px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        /* Position zoom controls at top-left */
        .leaflet-top.leaflet-left {
            top: 10px;
            left: 10px;
        }

        /* Custom home button */
        .leaflet-control-home {
            background: white;
            border: 2px solid rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            margin-top: 10px;
            box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2);
            transition: all 0.2s;
        }

        .leaflet-control-home:hover {
            background: #f4f4f4;
            transform: scale(1.05);
        }

        .leaflet-control-home svg {
            width: 18px;
            height: 18px;
            fill: #333;
        }

        /* Documentation button */
        .leaflet-control-doc {
            background: white;
            border: 2px solid rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            margin-top: 5px;
            /* Spacing between buttons */
            box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2);
            transition: all 0.2s;
        }

        .leaflet-control-doc:hover {
            background: #f4f4f4;
            transform: scale(1.05);
        }

        .leaflet-control-doc svg {
            width: 18px;
            height: 18px;
            fill: #333;
        }

        /* Basemap toggle control in bottom-right */
        #basemap-toggle {
            position: absolute;
            bottom: 20px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 5px;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .basemap-option {
            width: 45px;
            height: 45px;
            border: 2px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            text-align: center;
            padding: 3px;
            background-size: cover;
            background-position: center;
            position: relative;
            overflow: hidden;
        }

        .basemap-option:hover {
            border-color: #666;
            transform: scale(1.08);
        }

        .basemap-option.active {
            border-color: #4A90A4;
            border-width: 2.5px;
            box-shadow: 0 0 6px rgba(74, 144, 164, 0.5);
        }

        .basemap-option .label {
            position: absolute;
            bottom: 1px;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            padding: 1px 2px;
            font-weight: 600;
            font-size: 7.5px;
            letter-spacing: 0.2px;
        }

        /* Basemap preview styles - using actual map snippets */
        #basemap-grayscale {
            background-image: url('https://a.tile.openstreetmap.org/6/10/24.png');
        }

        #basemap-satellite {
            background-image: url('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/6/24/10');
        }

        #basemap-elevation {
            background-image: url('https://tile.opentopomap.org/6/10/24.png');
        }

        #basemap-population {
            background-image: url('https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/VIIRS_CityLights_2012/default/GoogleMapsCompatible_Level8/6/24/10.jpg');
        }

        #basemap-landcover {
            background-image: url('https://www.mrlc.gov/geoserver/mrlc_display/wms?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&FORMAT=image/png&TRANSPARENT=true&LAYERS=mrlc_display:NLCD_2021_Land_Cover_L48&WIDTH=256&HEIGHT=256&SRS=EPSG:3857&BBOX=-13358338.89519283,4383204.9499851465,-13210795.034662457,4530748.810515519');
        }



        #basemap-solar {
            background-image: url('https://eshan2803.github.io/basemaps/solar_tiles/6/10/24.png');
        }

        #basemap-wind {
            background-image: url('https://eshan2803.github.io/basemaps/wind_tiles/6/10/24.png');
        }

        #basemap-population-density {
            background-image: url('https://eshan2803.github.io/basemaps/population_tiles/6/10/24.png');
        }

        #basemap-ccus {
            background-image: url('https://eshan2803.github.io/basemaps/ccus_west_tiles/6/10/24.png');
        }

        #basemap-burn-probability {
            background: linear-gradient(135deg, #ff4500 0%, #ffa500 50%, #ffff00 100%);
        }

        /* Land cover hover tooltip styling */
        .land-cover-tooltip {
            background-color: rgba(255, 255, 255, 0.95);
            border: 2px solid #333;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 13px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            white-space: nowrap;
        }

        .land-cover-tooltip strong {
            color: #2c5f2d;
            font-size: 12px;
        }

        /* Minimalist Time Control (Bottom Center) */
        #time-control-panel {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            background: rgba(255, 255, 255, 0.75);
            backdrop-filter: blur(4px);
            padding: 12px 25px;
            border-radius: 30px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            transition: all 0.3s ease;
        }

        #time-control-panel:hover {
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .slider-row {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            gap: 12px;
        }

        #timeBasedToggle {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #4A90A4;
        }

        .checkbox-label {
            font-size: 12px;
            color: #555;
            white-space: nowrap;
            cursor: pointer;
            user-select: none;
        }

        #timeSlider {
            flex-grow: 1;
            height: 4px;
            border-radius: 2px;
            background: #ccc;
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
            /* Override default look */
            opacity: 0.5;
            /* Start disabled */
        }

        /* Custom Slider Thumb */
        #timeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4A90A4;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            transition: transform 0.1s;
        }

        #timeSlider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        /* Tooltip for time slider hover */
        #timeSliderTooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: bold;
            pointer-events: none;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transform: translateX(-50%);
        }

        #timeSliderTooltip.visible {
            opacity: 1;
        }

        #timeDisplay {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: -2px;
        }

        #timeText {
            font-size: 13px;
            font-weight: 600;
            color: #333;
            font-family: monospace;
            min-width: 65px;
            text-align: center;
        }

        .edit-icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #555;
            transition: all 0.2s;
        }

        .edit-icon-btn:hover {
            background-color: rgba(0, 0, 0, 0.05);
            color: #4A90A4;
        }

        .edit-icon-btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        /* Collapsible Basemap Menu (Bottom Right) */
        #basemap-container {
            position: absolute;
            bottom: 30px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
        }

        #basemap-trigger {
            width: 40px;
            height: 40px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid rgba(0, 0, 0, 0.1);
        }

        #basemap-trigger:hover {
            background: #f4f4f4;
            transform: scale(1.05);
        }

        #basemap-trigger.active {
            background: #4A90A4;
            color: white;
            border-color: #4A90A4;
        }

        #basemap-trigger svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

        #lmp-trigger {
            width: 40px;
            height: 40px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid rgba(0, 0, 0, 0.1);
            color: #333;
            /* Standard Black/Dark Grey */
        }

        #lmp-trigger:hover {
            background: #f4f4f4;
            transform: scale(1.05);
        }

        #lmp-trigger.active {
            background: #4A90A4;
            color: white;
            border-color: #4A90A4;
        }

        #lmp-trigger svg {
            width: 24px;
            height: 24px;
            /* fill: currentColor; - Removed since SVG has stroke/fill attributes inline */
        }

        /* The list of basemaps */
        #basemap-list {
            background: white;
            padding: 5px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            display: none;
            /* Hidden by default */
            flex-direction: column;
            gap: 4px;
            max-height: 400px;
            overflow-y: auto;
            /* Scroll if too tall */
        }

        #basemap-list.show {
            display: flex;
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Reuse existing basemap-option styles but ensure they work in the list */
        .basemap-option {
            /* Existing styles should work, just ensuring flex containment */
            flex-shrink: 0;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
            display: flex;
            align-items: center;
        }

        .basemap-option:hover {
            background-color: #f0f0f0;
        }

        .basemap-option.active {
            background-color: #e3f2fd;
            color: #1976D2;
            font-weight: 600;
        }

        /* LMP List styles mimicking basemap-list */
        #lmp-list {
            background: white;
            padding: 4px;
            border-radius: 6px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.3);
            display: none;
            /* Hidden by default */
            flex-direction: column;
            gap: 2px;
            position: absolute;
            bottom: 60px;
            /* Above the buttons */
            right: 0;
            /* Align to right so it doesn't get cut off */
            left: auto;
            z-index: 1000;
            min-width: 140px;
            /* Wider to accommodate text */
            align-items: stretch;
        }

        #lmp-list.show {
            display: flex;
            animation: fadeIn 0.2s ease-out;
        }

        /* Checkbox Layout Styles */
        /* Changed to .lmp-option to avoid conflict with basemap logic */
        .lmp-option {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: flex-start;
            /* Force Left Alignment */
            gap: 8px;
            /* Space between checkbox and label */
            padding: 6px 10px;
            /* Compact padding */
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
            position: relative;
            background: transparent;
            /* Reset tile properties */
            width: auto;
            height: auto;
            border: none;
        }

        .lmp-option:hover {
            background-color: #f0f0f0;
        }

        .lmp-option label {
            cursor: pointer;
            font-weight: 500;
            font-size: 13px;
            color: #333;
        }

        .lmp-option input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
            margin: 0;
            accent-color: #4A90A4;
        }

        /* Profile Editor Modal - Keep existing styles */
        #profile-editor-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        #profile-editor-content {
            background-color: #fefefe;
            padding: 25px;
            border-radius: 12px;
            width: 80%;
            max-width: 900px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            position: relative;
        }

        .close-modal {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-modal:hover {
            color: black;
        }

        .tab-container {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }

        .tab-btn {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 16px;
            font-weight: 500;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
        }

        .tab-btn.active {
            color: #4A90A4;
            border-bottom: 3px solid #4A90A4;
        }

        .profile-sliders-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            height: 250px;
            padding: 20px 10px;
            background: #f9f9f9;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .hour-slider-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 3%;
            height: 100%;
        }

        .vertical-slider {
            writing-mode: bt-lr;
            /* IE */
            -webkit-appearance: slider-vertical;
            /* WebKit */
            width: 8px;
            height: 85%;
            /* Leave space for label */
            outline: none;
        }

        .hour-label {
            font-size: 9px;
            color: #666;
            margin-top: 5px;
            transform: rotate(-45deg);
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        /* Loading Overlay */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #ffffff;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s ease-out;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #4A90A4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .loading-text {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 18px;
            color: #333;
            font-weight: 600;
            text-align: center;
        }

        .loading-subtext {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            color: #666;
            margin-top: 10px;
            font-style: italic;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .btn {
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            border: none;
            font-weight: 600;
        }

        .btn-secondary {
            background-color: #e0e0e0;
            color: #333;
        }

        .btn-primary {
            background-color: #4CAF50;
            color: white;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-ant-path@1.3.0/dist/leaflet-ant-path.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
</head>

<body>
    <div id="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text">Energizing the Grid...</div>
        <div class="loading-subtext">Please wait while we spin up the turbines.</div>
    </div>
    <div id="controls">
        <p><strong>California Power Grid Map</strong></p>
        <p style="margin: 5px 0; font-size: 13px;">Hover over plants to see details.</p>
        <p style="margin: 5px 0; font-size: 13px;">Click on plants to turn them ON/OFF.</p>
        <p style="margin: 5px 0; font-size: 13px;">Select Generator Type by clicking on the Legend Label.</p>
        <p style="margin: 5px 0; font-size: 13px;">Select multiple Generators by Ctrl/Cmd and clicking on Legend Labels.
        </p>
        <p style="margin: 5px 0; font-size: 13px;">Select multiple Basemaps by Ctrl/Cmd and clicking on Basemap Toggles.
        </p>
        <p id="status"
            style="margin-top: 10px; padding: 5px; background-color: #f0f0f0; border-radius: 4px; text-align: center;">
            <strong>Active Plants: <span id="activeCount">0</span></strong>
        </p>
        <button id="toggleAllBtn"
            style="width: 100%; margin-top: 10px; padding: 8px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
            Turn All Plants ON
        </button>
    </div>
    <div id="legend">
        <div id="legend-items">
            <strong id="legend-plants-header" style="cursor: pointer; user-select: none;"
                title="Click to hide/show all plants">Power Plant:</strong>
            <div class="legend-item fuel-filter" data-fuel="SUN"
                style="cursor: pointer; padding: 2px; border-radius: 3px;">
                <span
                    style="display: inline-block; width: 14px; height: 14px; margin-right: 5px; vertical-align: middle;">
                    <svg width="14" height="14">
                        <circle cx="7" cy="7" r="4" fill="#FFD700" stroke="#000" stroke-width="1" />
                    </svg>
                </span>Solar (986)
            </div>
            <div class="legend-item fuel-filter" data-fuel="WND"
                style="cursor: pointer; padding: 2px; border-radius: 3px;">
                <span
                    style="display: inline-block; width: 14px; height: 14px; margin-right: 5px; vertical-align: middle;">
                    <svg width="14" height="14">
                        <polygon points="7,3 11,11 3,11" fill="#1E90FF" stroke="#000" stroke-width="1" />
                    </svg>
                </span>Wind (163)
            </div>
            <div class="legend-item fuel-filter" data-fuel="NG,GAS,OGW,OG"
                style="cursor: pointer; padding: 2px; border-radius: 3px;"
                title="Includes: Natural Gas (NG), Gas, Other Gas from Waste">
                <span
                    style="display: inline-block; width: 14px; height: 14px; margin-right: 5px; vertical-align: middle;">
                    <svg width="14" height="14">
                        <rect x="3" y="3" width="8" height="8" fill="#FF4500" stroke="#000" stroke-width="1" />
                    </svg>
                </span>Natural Gas (361)
            </div>
            <div class="legend-item fuel-filter" data-fuel="WAT"
                style="cursor: pointer; padding: 2px; border-radius: 3px;">
                <span
                    style="display: inline-block; width: 14px; height: 14px; margin-right: 5px; vertical-align: middle;">
                    <svg width="14" height="14">
                        <polygon points="4.5,3 9.5,3 11.5,7 9.5,11 4.5,11 2.5,7" fill="#00CED1" stroke="#000"
                            stroke-width="1" />
                    </svg>
                </span>Hydro (298)
            </div>
            <div class="legend-item fuel-filter" data-fuel="GEO,WH"
                style="cursor: pointer; padding: 2px; border-radius: 3px;" title="Includes: Geothermal, Waste Heat">
                <span
                    style="display: inline-block; width: 14px; height: 14px; margin-right: 5px; vertical-align: middle;">
                    <svg width="14" height="14">
                        <rect x="4" y="4" width="6" height="6" fill="#DC143C" stroke="#000" stroke-width="1"
                            transform="rotate(45 7 7)" />
                    </svg>
                </span>Geothermal (49)
            </div>
            <div class="legend-item fuel-filter" data-fuel="NUC"
                style="cursor: pointer; padding: 2px; border-radius: 3px;">
                <span
                    style="display: inline-block; width: 14px; height: 14px; margin-right: 5px; vertical-align: middle;">
                    <svg width="14" height="14">
                        <polygon points="7,3 10,5 9,10 5,10 4,5" fill="#BA55D3" stroke="#000" stroke-width="1" />
                    </svg>
                </span>Nuclear (2)
            </div>
            <div class="legend-item fuel-filter" data-fuel="LFG,WDS,OBG,MSW,AB,OBS"
                style="cursor: pointer; padding: 2px; border-radius: 3px;"
                title="Includes: Landfill Gas, Wood, Other Biogas, Municipal Solid Waste, Agricultural Byproduct, Other Biomass Solids">
                <span
                    style="display: inline-block; width: 14px; height: 14px; margin-right: 5px; vertical-align: middle;">
                    <svg width="14" height="14">
                        <rect x="6" y="2" width="2" height="10" fill="#D2691E" stroke="#000" stroke-width="0.5" />
                        <rect x="2" y="6" width="10" height="2" fill="#D2691E" stroke="#000" stroke-width="0.5" />
                    </svg>
                </span>Biomass (173)
            </div>
            <div class="legend-item fuel-filter" data-fuel="BIT,OIL,DFO,SUB,JF,BLQ,PC"
                style="cursor: pointer; padding: 2px; border-radius: 3px;"
                title="Includes: Bituminous Coal, Oil, Distillate Fuel Oil, Sub-Bituminous Coal, Jet Fuel, Black Liquor, Petroleum Coke">
                <span
                    style="display: inline-block; width: 14px; height: 14px; margin-right: 5px; vertical-align: middle;">
                    <svg width="14" height="14">
                        <line x1="3" y1="3" x2="11" y2="11" stroke="#FF6347" stroke-width="2" />
                        <line x1="11" y1="3" x2="3" y2="11" stroke="#FF6347" stroke-width="2" />
                    </svg>
                </span>Coal/Petcoke/Oil (28)
            </div>
            <div class="legend-item fuel-filter" data-fuel="BAT,OTH"
                style="cursor: pointer; padding: 2px; border-radius: 3px;"
                title="Includes: Battery Storage and Other (BAT, OTH)">
                <span
                    style="display: inline-block; width: 14px; height: 14px; margin-right: 5px; vertical-align: middle;">
                    <svg width="14" height="14">
                        <rect x="2" y="5" width="10" height="6" fill="#FFD700" stroke="#000" stroke-width="1" />
                        <rect x="4" y="3" width="6" height="2" fill="#FFD700" stroke="#000" stroke-width="0.5" />
                    </svg>
                </span>Battery (13)
            </div>
            <div class="legend-item" style="margin-top: 5px;"><span class="legend-color"
                    style="background-color: #808080; width: 14px; height: 14px;"></span>OFF</div>
            <div class="legend-item"><span class="legend-color"
                    style="background-color: #39FF14; width: 14px; height: 14px;"></span>Active Flow
            </div>
            <div class="legend-item" id="legend-lines-toggle" style="cursor: pointer; user-select: none;"
                title="Click to hide/show transmission lines"><span class="legend-color"
                    style="background-color: #4A90A4; width: 14px; height: 14px;"></span>Transmission Lines</div>
            <div class="legend-item" id="legend-substations-toggle" style="cursor: pointer; user-select: none;"
                title="Click to hide/show substations">
                <span
                    style="display: inline-block; width: 14px; height: 14px; margin-right: 5px; vertical-align: middle;">
                    <svg width="14" height="14">
                        <circle cx="7" cy="7" r="2" fill="#39FF14" stroke="#000" stroke-width="0.5" />
                    </svg>
                </span>Substations (4442)
            </div>
        </div>
        <div id="capacity-slider-container">
            <div style="font-size: 10px; color: #666; text-align: center; margin-bottom: 5px; white-space: nowrap;">Min.
                MW</div>
            <input type="range" id="capacitySlider" min="0" max="1000" value="0" step="10"
                title="Filter by Minimum Capacity">
            <div id="capacityValue" style="font-size: 10px; color: #4CAF50; font-weight: bold; margin-top: 5px;">0 MW
            </div>
        </div>
    </div>
    <div id="basemap-container">
        <!-- LMP Price Mode List -->
        <div id="lmp-list">
            <div class="lmp-option" title="Color by Total LMP">
                <input type="checkbox" id="lmp-total" data-mode="LMP_Total" checked>
                <label for="lmp-total">Total LMP</label>
            </div>
            <div class="lmp-option" title="Color by Energy Component">
                <input type="checkbox" id="lmp-energy" data-mode="LMP_Energy">
                <label for="lmp-energy">Energy</label>
            </div>
            <div class="lmp-option" title="Color by Congestion Cost">
                <input type="checkbox" id="lmp-congestion" data-mode="LMP_Congestion">
                <label for="lmp-congestion">Congestion</label>
            </div>
            <div class="lmp-option" title="Color by Marginal Loss">
                <input type="checkbox" id="lmp-loss" data-mode="LMP_Loss">
                <label for="lmp-loss">Loss</label>
            </div>
            <div class="lmp-option" title="Color by GHG Cost">
                <input type="checkbox" id="lmp-ghg" data-mode="LMP_GHG">
                <label for="lmp-ghg">GHG</label>
            </div>
            <div style="border-top: 1px solid #eee; margin: 4px 0;"></div>
            <div class="lmp-option" id="lmp-turn-off" style="color: #d32f2f;">
                <span class="label">Hide Layer</span>
            </div>
        </div>

        <div id="basemap-list">
            <div class="basemap-option active" id="basemap-grayscale" data-layer="grayscale" title="Grayscale Map">
                <span class="label">Street</span>
            </div>
            <div class="basemap-option" id="basemap-satellite" data-layer="satellite" title="Satellite View">
                <span class="label">Satellite</span>
            </div>
            <div class="basemap-option" id="basemap-elevation" data-layer="elevation" title="Topographic Elevation">
                <span class="label">Elevation</span>
            </div>
            <div class="basemap-option" id="basemap-population" data-layer="population" title="Population Density">
                <span class="label">Population</span>
            </div>
            <div class="basemap-option" id="basemap-landcover" data-layer="landcover" title="Land Cover (NLCD)">
                <span class="label">Land Cover</span>
            </div>
            <div class="basemap-option" id="basemap-solar" data-layer="solarMap" title="Solar Irradiance Map">
                <span class="label">Solar</span>
            </div>
            <div class="basemap-option" id="basemap-wind" data-layer="windMap" title="Wind Speed Map">
                <span class="label">Wind</span>
            </div>
            <div class="basemap-option" id="basemap-population-density" data-layer="populationMap"
                title="Population Density Map">
                <span class="label">Pop. Density</span>
            </div>
            <div class="basemap-option" id="basemap-ccus" data-layer="ccusWest" title="CO2 Storage Sites (West)">
                <span class="label">CO<sub>2</sub> Storage</span>
            </div>
            <div class="basemap-option" id="basemap-burn-probability" data-layer="burnProbability"
                title="Wildfire Burn Probability">
                <span class="label">Fire Risk</span>
            </div>
        </div>
        <div class="button-row" style="display: flex; gap: 10px; align-items: center;">
            <div id="lmp-trigger" title="Show Day-Ahead Market Prices ($)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <!-- Removed circle, keeping just the $ symbol parts -->
                    <path d="M12 2v20" />
                    <path
                        d="M15 9.5A2.5 2.5 0 0 0 12.5 7h-1A2.5 2.5 0 0 0 9 9.5v0A2.5 2.5 0 0 0 11.5 12h1A2.5 2.5 0 0 1 15 14.5v0A2.5 2.5 0 0 1 12.5 17h-1A2.5 2.5 0 0 1 9 14.5" />
                </svg>
            </div>
            <div id="basemap-trigger" title="Show Map Layers">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M11.99 18.54l-7.37-5.73L3 14.07l9 7 9-7-1.63-1.27-7.38 5.74zM12 16l7.36-5.73L21 9l-9-7-9 7 1.63 1.27L12 16z" />
                </svg>
            </div>
        </div>
    </div>
    <div id="map"></div>
    <div id="time-control-panel">
        <div class="slider-row">
            <input type="checkbox" id="timeBasedToggle">
            <label for="timeBasedToggle" class="checkbox-label">Time-Based</label>
            <input type="range" id="timeSlider" min="0" max="23" value="0" step="1" disabled>
            <div id="timeSliderTooltip"></div>
            <button id="openProfileEditorBtn" class="edit-icon-btn" title="Edit Profiles">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z" />
                </svg>
            </button>
        </div>
        <div id="timeDisplay">
            <button id="prevHourBtn" class="edit-icon-btn" title="Previous Hour">
                <svg viewBox="0 0 24 24">
                    <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z" />
                </svg>
            </button>
            <span id="timeText">12:00 AM</span>
            <button id="nextHourBtn" class="edit-icon-btn" title="Next Hour">
                <svg viewBox="0 0 24 24">
                    <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z" />
                </svg>
            </button>
        </div>
        <!-- Hidden status text for logic access -->
        <div id="simStatus" style="display: none;"></div>
    </div>

    <!-- Profile Editor Modal -->
    <div id="profile-editor-modal">
        <div id="profile-editor-content">
            <span class="close-modal">&times;</span>
            <h2>Edit Daily Profiles</h2>
            <p style="color: #666; font-size: 13px; margin-bottom: 15px;">Adjust the hourly capacity factors for each
                resource type.</p>

            <div class="tab-container">
                <button class="tab-btn active" data-tab="solar">Solar</button>
                <button class="tab-btn" data-tab="wind">Wind</button>
                <button class="tab-btn" data-tab="load">Load Demand</button>
            </div>

            <div id="profile-label-container"
                style="margin-bottom: 10px; font-size: 12px; font-weight: bold; color: #555;">
                <!-- Label updated by JS -->
            </div>

            <div id="sliders-wrapper" class="profile-sliders-container">
                <!-- Sliders will be generated by JS -->
            </div>

            <div class="modal-actions">
                <button id="resetProfilesBtn" class="btn btn-secondary">Reset to Defaults</button>
                <button id="saveProfilesBtn" class="btn btn-primary">Apply Changes</button>
            </div>
        </div>
    </div>

    <script>
        // Initialize the map centered on California with smooth zoom
        var map = L.map('map', {
            zoomSnap: 0.25,      // Allow zoom in 0.25 increments for smoother control
            zoomDelta: 0.5,      // Zoom in/out by 0.5 levels per click
            wheelPxPerZoomLevel: 120  // Smoother mouse wheel zoom
        }).setView([36.7783, -119.4179], 6);

        // Create a new pane for WMS overlays
        map.createPane('wmsOverlayPane');
        map.getPane('wmsOverlayPane').style.zIndex = 300; // Above tiles (200), below overlays (400)
        map.getPane('wmsOverlayPane').style.pointerEvents = 'none';

        // Define basemap layers
        var baseLayers = {
            grayscale: L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }),
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
                maxZoom: 19
            }),
            elevation: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a>',
                pane: 'wmsOverlayPane',
                opacity: 0.8
            }),
            population: L.tileLayer.wms('https://sedac.ciesin.columbia.edu/geoserver/wms', {
                layers: 'gpw-v4:gpw-v4-population-density_2020',
                format: 'image/png',
                transparent: true,
                attribution: 'SEDAC / CIESIN / Columbia University',
                pane: 'wmsOverlayPane',
                opacity: 0.8
            }),
            landcover: L.tileLayer.wms('https://www.mrlc.gov/geoserver/wms', {
                layers: 'mrlc_display:NLCD_2021_Land_Cover_L48',
                format: 'image/png',
                transparent: true,
                attribution: 'USGS MRLC',
                pane: 'wmsOverlayPane',
                opacity: 0.8
            }),
            solarMap: L.tileLayer('https://eshan2803.github.io/basemaps/solar_tiles/{z}/{x}/{y}.png', {
                attribution: 'Solar Data from Global Solar Atlas / World Bank Group',
                pane: 'wmsOverlayPane',
                opacity: 0.7,
                minZoom: 0,
                maxZoom: 12,
                maxNativeZoom: 12,  // Use zoom 10 tiles even when zoomed further
                errorTileUrl: '',  // Don't show broken tile images
                bounds: [[-90, -180], [90, 180]]  // World bounds
            }),
            windMap: L.tileLayer('https://eshan2803.github.io/basemaps/wind_tiles/{z}/{x}/{y}.png', {
                attribution: 'Wind Data from Global Wind Atlas / World Bank Group',
                pane: 'wmsOverlayPane',
                opacity: 0.7,
                minZoom: 0,
                maxZoom: 10,
                maxNativeZoom: 10,  // Use zoom 10 tiles even when zoomed further
                errorTileUrl: '',  // Don't show broken tile images
                bounds: [[-90, -180], [90, 180]]  // World bounds
            }),
            populationMap: L.tileLayer('https://eshan2803.github.io/basemaps/population_tiles/{z}/{x}/{y}.png', {
                attribution: 'Population Density Data',
                pane: 'wmsOverlayPane',
                opacity: 0.9,
                minZoom: 0,
                maxZoom: 12,
                maxNativeZoom: 12,  // Use zoom 10 tiles even when zoomed further
                errorTileUrl: '',  // Don't show broken tile images
                bounds: [[-90, -180], [90, 180]]  // World bounds
            }),
            ccusWest: L.tileLayer('https://eshan2803.github.io/basemaps/ccus_west_tiles/{z}/{x}/{y}.png', {
                attribution: 'NATCARB v1502 â€“ DOE',
                pane: 'wmsOverlayPane',
                opacity: 0.7,
                minZoom: 0,
                maxZoom: 12,
                maxNativeZoom: 12,
                errorTileUrl: '',
                bounds: [[-90, -180], [90, 180]]
            }),
            burnProbability: L.esri.imageMapLayer({
                url: 'https://apps.fs.usda.gov/fsgisx01/rest/services/RDW_Wildfire/RMRS_WRC_BurnProbability/ImageServer',
                attribution: 'USDA Forest Service',
                pane: 'wmsOverlayPane',
                opacity: 0.7
            })
        };

        // Population density heatmap - create a visual representation using nighttime lights
        // NASA's Black Marble (nighttime lights) as proxy for population density
        var populationOverlay = L.tileLayer('https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/VIIRS_CityLights_2012/default/GoogleMapsCompatible_Level8/{z}/{y}/{x}.jpg', {
            attribution: '&copy; <a href="https://earthdata.nasa.gov/">NASA</a>',
            maxZoom: 19,
            maxNativeZoom: 8, // Actual data only goes to zoom 8
            opacity: 0.7,
            pane: 'wmsOverlayPane' // Use custom pane for proper z-ordering
        });


        // Add default grayscale layer
        var currentBaseLayer = baseLayers.grayscale.addTo(map);
        currentBaseLayer.getContainer().classList.add('grayscale');

        // Track active overlays - now supports multiple overlays
        var activeOverlays = []; // Array of active overlay layers
        var activeBaseOptions = new Set(); // Track which basemap options are selected

        // URLs for local data
        const transmissionUrl = './transmission.geojson';
        const substationsUrl = './substations_with_prices.geojson'; // Loaded with LMP Prices
        const plantsUrl = './powerplant.geojson';

        // Layers (declared globally)
        let transmissionLayer = L.layerGroup().addTo(map);
        let substationsLayer = L.layerGroup().addTo(map);
        let plantsLayer = L.layerGroup().addTo(map);
        let customGenerators = L.layerGroup().addTo(map);
        let staticLinesLayer, animatedLinesLayer;

        // Track active generators
        let activeGenerators = 0;
        let minCapacity = 0; // Minimum capacity filter in MW

        // Global state for System Capacities
        let sysCap = {
            GAS: 0,
            HYDRO: 0,
            SOLAR: 0,
            WIND: 0,
            BASELOAD: 0,
            BATTERY: 0,
            TOTAL: 0
        };

        // Network graph data structures
        let networkGraph = {
            substations: [], // {id, latlng, name, voltage, connectedLines: [], marker, islandId}
            plants: [],      // {id, latlng, name, fuel, capacity, nearestSubstationId, marker, isOn, islandId}
            lines: [],       // {id, coords, startNodeId, endNodeId, feature, antPath, islandId}
            linesBySubstation: {}, // Map of substationId -> [lineIds]
            islands: {}      // Map of islandId -> { lines: [lineIds], substations: [subIds] }
        };

        // Data loading promises
        let transmissionData, substationsData, plantsData;

        // Fetch transmission lines
        let transmissionPromise = fetch(transmissionUrl)
            .then(response => {
                if (!response.ok) throw new Error('Failed to fetch transmission lines');
                return response.json();
            })
            .then(data => {
                transmissionData = data;
                console.log(`Loaded ${data.features.length} transmission lines`);
            })
            .catch(error => {
                console.error('Error loading transmission lines:', error);
            });

        // Fetch substations
        let substationsPromise = fetch(substationsUrl)
            .then(response => {
                if (!response.ok) throw new Error('Failed to fetch substations');
                return response.json();
            })
            .then(data => {
                substationsData = data;
                console.log(`Loaded ${data.features.length} substations`);
            })
            .catch(error => {
                console.error('Error loading substations:', error);
            });

        // Fetch power plants
        let plantsPromise = fetch(plantsUrl)
            .then(response => {
                if (!response.ok) throw new Error('Failed to fetch power plants');
                return response.json();
            })
            .then(data => {
                plantsData = data;
                console.log(`Loaded ${data.features.length} power plants`);
            })
            .catch(error => {
                console.error('Error loading power plants:', error);
            });

        // Wait for all data to load, then build network and render
        Promise.all([transmissionPromise, substationsPromise, plantsPromise])
            .then(() => {
                console.log('All data loaded. Building network graph...');
                try {
                    buildNetworkGraph();
                    renderMap();
                    setupToggleAllButton();
                    setupLegendInteractivity();
                    setupCapacitySlider();
                    setupLayerToggles();
                    setupBasemapToggle();
                    setupLMPToggle();
                    setupHomeButton();
                    setupDocButton();
                    setupLandCoverHover();
                    setupCCSHover();
                    setupTimeSimulation();

                    // Hide loading overlay
                    const overlay = document.getElementById('loading-overlay');
                    overlay.style.opacity = '0';
                    setTimeout(() => {
                        overlay.style.display = 'none';
                    }, 500);

                    console.log('Network graph built and map rendered.');
                } catch (error) {
                    console.error('Error building network or rendering map:', error);
                }
            });

        // Setup toggle all plants button
        function setupToggleAllButton() {
            const toggleBtn = document.getElementById('toggleAllBtn');
            let allOn = false;

            toggleBtn.addEventListener('click', function () {
                allOn = !allOn;

                console.log(`Toggling all ${networkGraph.plants.length} plants ${allOn ? 'ON' : 'OFF'}...`);

                // Toggle all plants
                networkGraph.plants.forEach(plantData => {
                    // Skip plants below capacity cutoff or without markers (retired plants)
                    if (plantData.capacity < minCapacity || !plantData.marker) return;

                    if (plantData.isOn !== allOn) {
                        const color = getFuelColor(plantData.fuel);
                        const fuelType = (plantData.fuel || 'UNKNOWN').toUpperCase();
                        const marker = plantData.marker;

                        plantData.isOn = allOn;

                        if (allOn) {
                            activeGenerators++;
                            // Update marker color based on type
                            if (marker instanceof L.CircleMarker) {
                                marker.setStyle({ fillColor: color });
                            } else {
                                const isLargeMarker = ['WND', 'WIND', 'BAT', 'OTH', 'NUC'].includes(fuelType);
                                const isWind = ['WND', 'WIND'].includes(fuelType);
                                const markerSize = isWind ? 18 : (isLargeMarker ? 16 : 12);
                                const markerAnchor = isWind ? 9 : (isLargeMarker ? 8 : 6);
                                marker.setIcon(L.divIcon({
                                    className: 'custom-div-icon',
                                    html: getMarkerHTML(fuelType, color, 'large'),
                                    iconSize: [markerSize, markerSize],
                                    iconAnchor: [markerAnchor, markerAnchor]
                                }));
                            }
                        } else {
                            activeGenerators--;
                            // Reset to grey
                            if (marker instanceof L.CircleMarker) {
                                marker.setStyle({ fillColor: '#808080' });
                            } else {
                                const isLargeMarker = ['WND', 'WIND', 'BAT', 'OTH', 'NUC'].includes(fuelType);
                                const isWind = ['WND', 'WIND'].includes(fuelType);
                                const markerSize = isWind ? 18 : (isLargeMarker ? 16 : 12);
                                const markerAnchor = isWind ? 9 : (isLargeMarker ? 8 : 6);
                                marker.setIcon(L.divIcon({
                                    className: 'custom-div-icon',
                                    html: getMarkerHTML(fuelType, '#808080', 'large'),
                                    iconSize: [markerSize, markerSize],
                                    iconAnchor: [markerAnchor, markerAnchor]
                                }));
                            }
                        }
                    }
                });

                // Update button text and color
                if (allOn) {
                    toggleBtn.textContent = 'Turn All Plants OFF';
                    toggleBtn.style.backgroundColor = '#f44336'; // Red
                } else {
                    toggleBtn.textContent = 'Turn All Plants ON';
                    toggleBtn.style.backgroundColor = '#4CAF50'; // Green
                }

                // Update flow visualization
                updateFlow();

                console.log(`All plants toggled ${allOn ? 'ON' : 'OFF'}. Active: ${activeGenerators}`);
            });
        }

        // Setup interactive legend functionality
        function setupLegendInteractivity() {
            let activeFilters = new Set(); // Track active filters (for multi-select)
            let stateBeforeFilter = {}; // Track plant states before filtering

            // Get all legend filter items
            const filterItems = document.querySelectorAll('.fuel-filter');

            filterItems.forEach(item => {
                const fuelTypes = item.getAttribute('data-fuel').split(',');

                // 1. Hover highlighting - fade non-matching plants
                item.addEventListener('mouseenter', () => {
                    networkGraph.plants.forEach(plant => {
                        const plantFuel = (plant.fuel || '').toUpperCase();
                        const isMatching = fuelTypes.includes(plantFuel);

                        if (!isMatching && plant.marker) {
                            // Fade non-matching plants
                            if (plant.marker instanceof L.CircleMarker) {
                                plant.marker.setStyle({ fillOpacity: 0.2, opacity: 0.2 });
                            } else {
                                plant.marker.setOpacity(0.2);
                            }
                        }
                    });

                    // Highlight legend item
                    item.style.backgroundColor = '#f0f0f0';
                });

                item.addEventListener('mouseleave', () => {
                    networkGraph.plants.forEach(plant => {
                        if (plant.marker) {
                            // Restore full opacity
                            if (plant.marker instanceof L.CircleMarker) {
                                plant.marker.setStyle({ fillOpacity: 0.8, opacity: 1 });
                            } else {
                                plant.marker.setOpacity(1);
                            }
                        }
                    });

                    // Remove hover highlight if not actively filtered
                    if (!activeFilters.has(item)) {
                        item.style.backgroundColor = '';
                    }
                });

                // 2. Click filtering - show only selected fuel type(s)
                // Support multi-select with Ctrl/Cmd key
                item.addEventListener('click', (e) => {
                    const isMultiSelect = e.ctrlKey || e.metaKey; // Ctrl on Windows/Linux, Cmd on Mac

                    if (isMultiSelect) {
                        // Multi-select mode: toggle this filter
                        if (activeFilters.has(item)) {
                            // Remove this filter
                            activeFilters.delete(item);
                            item.style.backgroundColor = '';
                        } else {
                            // Add this filter
                            if (activeFilters.size === 0) {
                                // First filter - save state
                                saveCurrentState();
                            }
                            activeFilters.add(item);
                            item.style.backgroundColor = '#d0d0d0';
                        }

                        // Apply combined filters or restore if none selected
                        if (activeFilters.size > 0) {
                            applyCombinedFilters();
                        } else {
                            restorePreviousState();
                        }
                    } else {
                        // Single-select mode (no Ctrl/Cmd)
                        if (activeFilters.size === 1 && activeFilters.has(item)) {
                            // Clicking same single filter - restore previous state
                            restorePreviousState();
                            activeFilters.clear();
                            filterItems.forEach(i => i.style.backgroundColor = '');
                            console.log('Filter removed, restored previous state');
                        } else {
                            // Apply new single filter
                            if (activeFilters.size === 0) {
                                saveCurrentState();
                            }

                            // Clear all previous filters
                            activeFilters.clear();
                            filterItems.forEach(i => i.style.backgroundColor = '');

                            // Add this filter
                            activeFilters.add(item);
                            item.style.backgroundColor = '#d0d0d0';

                            applyCombinedFilters();
                            console.log(`Filter applied: ${fuelTypes.join(', ')}`);
                        }
                    }
                });
            });

            // Save current plant states before filtering
            function saveCurrentState() {
                stateBeforeFilter = {};
                networkGraph.plants.forEach(plant => {
                    stateBeforeFilter[plant.id] = plant.isOn;
                });
            }

            // Apply combined filters from multiple selections
            function applyCombinedFilters() {
                // Collect all fuel types from active filters
                const allFuelTypes = new Set();
                activeFilters.forEach(item => {
                    const fuelTypes = item.getAttribute('data-fuel').split(',');
                    fuelTypes.forEach(type => allFuelTypes.add(type));
                });

                applyFilter(Array.from(allFuelTypes));

                console.log(`Combined filters applied: ${Array.from(allFuelTypes).join(', ')}`);
            }

            // Apply filter to show only selected fuel types
            function applyFilter(fuelTypes) {
                let matchingPlants = 0;

                networkGraph.plants.forEach(plant => {
                    // Skip retired plants (no marker)
                    if (!plant.marker) return;

                    const plantFuel = (plant.fuel || '').toUpperCase();
                    const isMatching = fuelTypes.includes(plantFuel);

                    if (isMatching) {
                        // Only count if meets capacity requirement
                        if (plant.capacity >= minCapacity) {
                            matchingPlants++;
                        }

                        // Show matching plant only if meets capacity requirement
                        if (plant.capacity >= minCapacity) {
                            if (!map.hasLayer(plant.marker)) {
                                plantsLayer.addLayer(plant.marker);
                            }
                        }

                        // Turn ON matching plant if meets capacity requirement and not already ON
                        if (plant.capacity >= minCapacity && !plant.isOn) {
                            plant.isOn = true;
                            activeGenerators++;

                            const color = getFuelColor(plant.fuel);
                            const fuelType = plantFuel;

                            if (plant.marker instanceof L.CircleMarker) {
                                plant.marker.setStyle({ fillColor: color });
                            } else {
                                const isLargeMarker = ['WND', 'WIND', 'BAT', 'OTH', 'NUC'].includes(fuelType);
                                const isWind = ['WND', 'WIND'].includes(fuelType);
                                const markerSize = isWind ? 18 : (isLargeMarker ? 16 : 12);
                                const markerAnchor = isWind ? 9 : (isLargeMarker ? 8 : 6);
                                plant.marker.setIcon(L.divIcon({
                                    className: 'custom-div-icon',
                                    html: getMarkerHTML(fuelType, color, 'large'),
                                    iconSize: [markerSize, markerSize],
                                    iconAnchor: [markerAnchor, markerAnchor]
                                }));
                            }
                        }
                    } else {
                        // Hide non-matching plant
                        if (plant.marker && map.hasLayer(plant.marker)) {
                            plantsLayer.removeLayer(plant.marker);
                        }

                        // Turn OFF non-matching plant if it was on
                        if (plant.isOn) {
                            plant.isOn = false;
                            activeGenerators--;
                        }
                    }
                });

                // Update flow visualization with filtered plants
                updateFlow();

                console.log(`${matchingPlants} plants matching filter, ${activeGenerators} active`);
            }

            // Restore plant states from before filtering
            function restorePreviousState() {
                networkGraph.plants.forEach(plant => {
                    const previousState = stateBeforeFilter[plant.id];

                    // Restore marker visibility
                    if (plant.marker && !map.hasLayer(plant.marker)) {
                        plantsLayer.addLayer(plant.marker);
                    }

                    // Restore ON/OFF state
                    if (previousState !== undefined && plant.isOn !== previousState) {
                        const color = getFuelColor(plant.fuel);
                        const fuelType = (plant.fuel || 'UNKNOWN').toUpperCase();

                        plant.isOn = previousState;

                        if (previousState) {
                            activeGenerators++;

                            // Turn ON
                            if (plant.marker instanceof L.CircleMarker) {
                                plant.marker.setStyle({ fillColor: color });
                            } else {
                                const isLargeMarker = ['WND', 'WIND', 'BAT', 'OTH', 'NUC'].includes(fuelType);
                                const isWind = ['WND', 'WIND'].includes(fuelType);
                                const markerSize = isWind ? 18 : (isLargeMarker ? 16 : 12);
                                const markerAnchor = isWind ? 9 : (isLargeMarker ? 8 : 6);
                                plant.marker.setIcon(L.divIcon({
                                    className: 'custom-div-icon',
                                    html: getMarkerHTML(fuelType, color, 'large'),
                                    iconSize: [markerSize, markerSize],
                                    iconAnchor: [markerAnchor, markerAnchor]
                                }));
                            }
                        } else {
                            activeGenerators--;

                            // Turn OFF
                            if (plant.marker instanceof L.CircleMarker) {
                                plant.marker.setStyle({ fillColor: '#808080' });
                            } else {
                                const isLargeMarker = ['WND', 'WIND', 'BAT', 'OTH', 'NUC'].includes(fuelType);
                                const isWind = ['WND', 'WIND'].includes(fuelType);
                                const markerSize = isWind ? 18 : (isLargeMarker ? 16 : 12);
                                const markerAnchor = isWind ? 9 : (isLargeMarker ? 8 : 6);
                                plant.marker.setIcon(L.divIcon({
                                    className: 'custom-div-icon',
                                    html: getMarkerHTML(fuelType, '#808080', 'large'),
                                    iconSize: [markerSize, markerSize],
                                    iconAnchor: [markerAnchor, markerAnchor]
                                }));
                            }
                        }
                    }
                });

                // Update flow visualization
                updateFlow();

                // Clear saved state
                stateBeforeFilter = {};
            }

            // Setup click handler for Power Plant header to toggle all plants visibility
            const plantsHeader = document.getElementById('legend-plants-header');
            let plantsVisible = true;

            plantsHeader.addEventListener('click', () => {
                plantsVisible = !plantsVisible;

                networkGraph.plants.forEach(plant => {
                    if (plant.marker) {
                        if (plantsVisible) {
                            if (!map.hasLayer(plant.marker)) {
                                plantsLayer.addLayer(plant.marker);
                            }
                        } else {
                            if (map.hasLayer(plant.marker)) {
                                plantsLayer.removeLayer(plant.marker);
                            }
                        }
                    }
                });

                // Update header styling to indicate state
                plantsHeader.style.opacity = plantsVisible ? '1' : '0.5';
                plantsHeader.style.textDecoration = plantsVisible ? 'none' : 'line-through';

                console.log(`Plants ${plantsVisible ? 'shown' : 'hidden'}`);
            });
        }

        // Setup click handlers for transmission lines and substations toggles
        function setupLayerToggles() {
            // Track visibility state
            let linesVisible = true;
            let substationsVisible = true;

            // Transmission Lines toggle
            const linesToggle = document.getElementById('legend-lines-toggle');
            linesToggle.addEventListener('click', () => {
                linesVisible = !linesVisible;

                if (linesVisible) {
                    if (!map.hasLayer(staticLinesLayer)) {
                        map.addLayer(staticLinesLayer);
                    }
                    if (!map.hasLayer(animatedLinesLayer) && activeGenerators > 0) {
                        map.addLayer(animatedLinesLayer);
                    }
                } else {
                    if (map.hasLayer(staticLinesLayer)) {
                        map.removeLayer(staticLinesLayer);
                    }
                    if (map.hasLayer(animatedLinesLayer)) {
                        map.removeLayer(animatedLinesLayer);
                    }
                }

                // Update styling to indicate state
                linesToggle.style.opacity = linesVisible ? '1' : '0.5';
                linesToggle.style.textDecoration = linesVisible ? 'none' : 'line-through';

                console.log(`Transmission lines ${linesVisible ? 'shown' : 'hidden'}`);
            });

            // Substations toggle
            const substationsToggle = document.getElementById('legend-substations-toggle');
            substationsToggle.addEventListener('click', () => {
                substationsVisible = !substationsVisible;

                if (substationsVisible) {
                    if (!map.hasLayer(substationsLayer)) {
                        map.addLayer(substationsLayer);
                    }
                } else {
                    if (map.hasLayer(substationsLayer)) {
                        map.removeLayer(substationsLayer);
                    }
                }

                // Update styling to indicate state
                substationsToggle.style.opacity = substationsVisible ? '1' : '0.5';
                substationsToggle.style.textDecoration = substationsVisible ? 'none' : 'line-through';

                console.log(`Substations ${substationsVisible ? 'shown' : 'hidden'}`);
            });
        }

        // Setup capacity slider functionality
        function setupCapacitySlider() {
            const slider = document.getElementById('capacitySlider');
            const valueDisplay = document.getElementById('capacityValue');

            // Helper to interpolate colors: Green -> Red
            function getColor(value) {
                // value 0 to 1000
                const percent = value / 1000;
                // Green: #4CAF50 (76, 175, 80)
                // Red: #F44336 (244, 67, 54)
                const r = Math.round(76 + (244 - 76) * percent);
                const g = Math.round(175 + (67 - 175) * percent);
                const b = Math.round(80 + (54 - 80) * percent);
                return `rgb(${r}, ${g}, ${b})`;
            }

            function updateSliderVisuals() {
                const val = parseInt(slider.value);
                const color = getColor(val);

                valueDisplay.textContent = val + ' MW';
                valueDisplay.style.color = color;
                slider.style.setProperty('--thumb-color', color);
            }

            slider.addEventListener('input', function () {
                minCapacity = parseInt(this.value);
                updateSliderVisuals();

                // Update visibility of all plants based on new capacity
                updatePlantVisibilityByCapacity();
            });

            // Initialize visuals
            updateSliderVisuals();
        }

        // Update plant visibility based on capacity filter
        function updatePlantVisibilityByCapacity() {
            let activeCount = 0;

            networkGraph.plants.forEach(plant => {
                // If plant is below capacity, hide it and turn it off
                if (plant.capacity < minCapacity) {
                    // Remove from map if present
                    if (plant.marker && map.hasLayer(plant.marker)) {
                        plantsLayer.removeLayer(plant.marker);
                    }

                    // Turn off if it was on
                    if (plant.isOn) {
                        plant.isOn = false;
                        // Reset marker style to OFF state (grey) just in case it's re-added later
                        if (plant.marker) {
                            if (plant.marker instanceof L.CircleMarker) {
                                plant.marker.setStyle({ fillColor: '#808080' });
                            } else {
                                const fuelType = (plant.fuel || 'UNKNOWN').toUpperCase();
                                const isLargeMarker = ['WND', 'WIND', 'BAT', 'OTH', 'NUC'].includes(fuelType);
                                const isWind = ['WND', 'WIND'].includes(fuelType);
                                const markerSize = isWind ? 18 : (isLargeMarker ? 16 : 12);
                                const markerAnchor = isWind ? 9 : (isLargeMarker ? 8 : 6);
                                plant.marker.setIcon(L.divIcon({
                                    className: 'custom-div-icon',
                                    html: getMarkerHTML(fuelType, '#808080', 'large'),
                                    iconSize: [markerSize, markerSize],
                                    iconAnchor: [markerAnchor, markerAnchor]
                                }));
                            }
                        }
                    }
                } else {
                    // Plant meets capacity requirement
                    // Check if it should be visible based on current legend filters
                    // For simplicity, we'll just re-apply the current legend state logic
                    // But since we don't easily have access to "current legend state" here without refactoring,
                    // we'll assume if it was previously ON, it stays ON.
                    // If it was OFF, it stays OFF but becomes visible if "Show All" is active.

                    // Better approach: Trigger a re-evaluation of filters if possible, 
                    // or just ensure it's added to map if "Plants Visible" is true.

                    const plantsHeader = document.getElementById('legend-plants-header');
                    const plantsVisible = plantsHeader.style.textDecoration !== 'line-through';

                    if (plantsVisible && plant.marker && !map.hasLayer(plant.marker)) {
                        // We also need to check if specific fuel filters are active that would exclude this.
                        // This is getting complicated. 
                        // Let's simplify: Just make it visible (grey) if it meets capacity.
                        // The user can then interact with it.
                        plantsLayer.addLayer(plant.marker);
                    }
                }

                if (plant.isOn) activeCount++;
            });

            activeGenerators = activeCount;
            document.getElementById('activeCount').textContent = activeGenerators;

            // Update flow visualization
            updateFlow();
        }

        // Setup basemap toggle functionality with multi-select support
        function setupBasemapToggle() {
            // Toggle Menu Logic
            const trigger = document.getElementById('basemap-trigger');
            const list = document.getElementById('basemap-list');

            trigger.addEventListener('click', (e) => {
                e.stopPropagation();
                list.classList.toggle('show');
                trigger.classList.toggle('active');
            });

            // Close menu when clicking outside
            document.addEventListener('click', (e) => {
                if (!document.getElementById('basemap-container').contains(e.target)) {
                    list.classList.remove('show');
                    trigger.classList.remove('active');
                }
            });

            const basemapOptions = document.querySelectorAll('.basemap-option');

            basemapOptions.forEach(option => {
                option.addEventListener('click', (e) => {
                    const layerType = option.getAttribute('data-layer');
                    const isMultiSelect = e.ctrlKey || e.metaKey; // Ctrl on Windows/Linux, Cmd on Mac

                    // Determine if this is an overlay basemap (not a base layer)
                    const overlayTypes = ['elevation', 'population', 'landcover', 'solarMap', 'windMap', 'populationMap', 'ccusWest', 'burnProbability'];
                    const isOverlayType = overlayTypes.includes(layerType);

                    if (isMultiSelect && isOverlayType) {
                        // Multi-select mode for overlay basemaps
                        if (activeBaseOptions.has(layerType)) {
                            // Remove this overlay
                            activeBaseOptions.delete(layerType);
                            option.classList.remove('active');
                            removeOverlayByType(layerType);
                        } else {
                            // Add this overlay
                            activeBaseOptions.add(layerType);
                            option.classList.add('active');
                            addOverlayByType(layerType);
                        }

                        console.log(`Multi-select: ${Array.from(activeBaseOptions).join(', ')}`);
                    } else {
                        // Single-select mode - clear everything and start fresh
                        // 1. Clear all previous selections
                        basemapOptions.forEach(opt => opt.classList.remove('active'));
                        if (currentBaseLayer && map.hasLayer(currentBaseLayer)) {
                            map.removeLayer(currentBaseLayer);
                            // Remove grayscale filter if present
                            if (currentBaseLayer.getContainer && typeof currentBaseLayer.getContainer === 'function') {
                                const container = currentBaseLayer.getContainer();
                                if (container) {
                                    container.classList.remove('grayscale');
                                }
                            }
                        }

                        // Remove all active overlays
                        activeOverlays.forEach(overlay => {
                            if (map.hasLayer(overlay)) {
                                map.removeLayer(overlay);
                            }
                        });
                        activeOverlays = [];
                        activeBaseOptions.clear();
                        isLandCoverActive = false;

                        // 2. Add the new selection
                        option.classList.add('active');
                        activeBaseOptions.add(layerType);

                        switch (layerType) {
                            case 'grayscale':
                                currentBaseLayer = baseLayers.grayscale.addTo(map);
                                if (currentBaseLayer.getContainer && typeof currentBaseLayer.getContainer === 'function') {
                                    const container = currentBaseLayer.getContainer();
                                    if (container) {
                                        container.classList.add('grayscale');
                                    }
                                }
                                console.log('Switched to grayscale basemap');
                                break;
                            case 'satellite':
                                currentBaseLayer = baseLayers.satellite.addTo(map);
                                currentBaseLayer.on('load', () => console.log('Satellite basemap loaded'));
                                currentBaseLayer.on('requesterror', (e) => console.error('Satellite error:', e));
                                console.log('Switched to satellite basemap');
                                break;
                            default:
                                // For overlay types, use appropriate base layer
                                // Use street/grayscale for CCS Storage, satellite for others
                                if (layerType === 'ccusWest') {
                                    currentBaseLayer = baseLayers.grayscale.addTo(map);
                                    if (currentBaseLayer.getContainer && typeof currentBaseLayer.getContainer === 'function') {
                                        const container = currentBaseLayer.getContainer();
                                        if (container) {
                                            container.classList.add('grayscale');
                                        }
                                    }
                                } else {
                                    currentBaseLayer = baseLayers.satellite.addTo(map);
                                }
                                addOverlayByType(layerType);
                                break;
                        }

                        console.log(`Switched to ${layerType} basemap`);
                    }

                });
            });
        }

        // Helper function to add an overlay by type
        function addOverlayByType(layerType) {
            let overlay = null;

            switch (layerType) {
                case 'elevation':
                    overlay = baseLayers.elevation.addTo(map);
                    console.log('Added elevation overlay');
                    break;
                case 'population':
                    overlay = populationOverlay.addTo(map);
                    console.log('Added population overlay');
                    break;
                case 'landcover':
                    overlay = baseLayers.landcover.addTo(map);
                    isLandCoverActive = true;
                    console.log('Added land cover overlay');
                    break;
                case 'solarMap':
                    overlay = baseLayers.solarMap.addTo(map);
                    overlay.on('tileload', function (e) {
                        console.log('Solar tile loaded:', e.url);
                    });
                    overlay.on('tileerror', function (e) {
                        console.error('Solar tile error:', e.url);
                    });
                    console.log('Added solar overlay');
                    break;
                case 'windMap':
                    overlay = baseLayers.windMap.addTo(map);
                    overlay.on('tileload', function (e) {
                        console.log('Wind tile loaded:', e.url);
                    });
                    overlay.on('tileerror', function (e) {
                        console.error('Wind tile error:', e.url);
                    });
                    console.log('Added wind overlay');
                    break;
                case 'populationMap':
                    overlay = baseLayers.populationMap.addTo(map);
                    overlay.on('tileload', function (e) {
                        console.log('Population tile loaded:', e.url);
                    });
                    overlay.on('tileerror', function (e) {
                        console.error('Population tile error:', e.url);
                    });
                    console.log('Added population density overlay');
                    break;
                case 'ccusWest':
                    overlay = baseLayers.ccusWest.addTo(map);
                    isCCSActive = true;
                    overlay.on('tileload', function (e) {
                        console.log('CCS Storage tile loaded:', e.url);
                    });
                    overlay.on('tileerror', function (e) {
                        console.error('CCS Storage tile error:', e.url);
                    });
                    console.log('Added CCS Storage overlay');
                    break;
                case 'burnProbability':
                    overlay = baseLayers.burnProbability.addTo(map);
                    console.log('Added Burn Probability overlay');
                    break;
            }

            if (overlay) {
                activeOverlays.push(overlay);
                // Adjust opacity of all overlays based on count
                updateOverlayOpacity();
            }
        }

        // Helper function to update opacity of all active overlays based on count
        function updateOverlayOpacity() {
            const overlayCount = activeOverlays.length;

            if (overlayCount === 0) {
                return;
            }

            // Calculate opacity based on number of overlays
            // With 1 overlay: keep original opacity (0.7-0.9)
            // With 2 overlays: reduce to 0.5 each for better blending
            // With 3+ overlays: reduce further to prevent complete occlusion
            let targetOpacity;

            if (overlayCount === 1) {
                targetOpacity = 0.8; // Single layer - keep it visible
            } else if (overlayCount === 2) {
                targetOpacity = 0.5; // Two layers - 50% each for blending
            } else if (overlayCount === 3) {
                targetOpacity = 0.4; // Three layers - reduce more
            } else {
                targetOpacity = 0.35; // Four or more - even more transparent
            }

            // Apply the calculated opacity to all active overlays
            activeOverlays.forEach(overlay => {
                if (overlay && overlay.setOpacity) {
                    overlay.setOpacity(targetOpacity);
                }
            });

            console.log(`Updated ${overlayCount} overlay(s) to opacity: ${targetOpacity}`);
        }

        // Helper function to remove an overlay by type
        function removeOverlayByType(layerType) {
            // Find and remove the overlay from the map
            activeOverlays = activeOverlays.filter(overlay => {
                // Check if this overlay corresponds to the layer type we want to remove
                let shouldRemove = false;

                switch (layerType) {
                    case 'elevation':
                        shouldRemove = (overlay === baseLayers.elevation);
                        break;
                    case 'population':
                        shouldRemove = (overlay === populationOverlay);
                        break;
                    case 'landcover':
                        shouldRemove = (overlay === baseLayers.landcover);
                        if (shouldRemove) isLandCoverActive = false;
                        break;
                    case 'solarMap':
                        shouldRemove = (overlay === baseLayers.solarMap);
                        break;
                    case 'windMap':
                        shouldRemove = (overlay === baseLayers.windMap);
                        break;
                    case 'populationMap':
                        shouldRemove = (overlay === baseLayers.populationMap);
                        break;
                    case 'ccusWest':
                        shouldRemove = (overlay === baseLayers.ccusWest);
                        if (shouldRemove) isCCSActive = false;
                        break;
                    case 'burnProbability':
                        shouldRemove = (overlay === baseLayers.burnProbability);
                        break;
                }

                if (shouldRemove && map.hasLayer(overlay)) {
                    map.removeLayer(overlay);
                    console.log(`Removed ${layerType} overlay`);
                }

                return !shouldRemove; // Keep overlays that don't match
            });

            // Adjust opacity of remaining overlays
            updateOverlayOpacity();
        }

        // CCS Storage color mapping (RGB values from tile colors)
        const ccsColorMap = {
            'coal': { color: [139, 69, 19], name: 'Coal Mine Storage' },
            'oilgas': { color: [255, 140, 0], name: 'Oil-Gas Well Storage' },
            'saline': { color: [30, 144, 255], name: 'Saline Storage' }
        };

        // Function to identify CCS storage type from RGB color
        function getCCSStorageType(r, g, b) {
            let minDistance = Infinity;
            let closestType = null;

            for (const [key, data] of Object.entries(ccsColorMap)) {
                const [cr, cg, cb] = data.color;
                // Calculate Euclidean distance in RGB space
                const distance = Math.sqrt(
                    Math.pow(r - cr, 2) +
                    Math.pow(g - cg, 2) +
                    Math.pow(b - cb, 2)
                );

                if (distance < minDistance) {
                    minDistance = distance;
                    closestType = data.name;
                }
            }

            // Only return if color is reasonably close (threshold to avoid noise)
            return minDistance < 50 ? closestType : null;
        }

        // NLCD Land Cover color mapping from the legend
        const nlcdColorMap = {
            '11': { color: [70, 107, 159], name: 'Open Water' },
            '12': { color: [209, 222, 248], name: 'Perennial Ice/Snow' },
            '21': { color: [222, 197, 197], name: 'Developed, Open Space' },
            '22': { color: [217, 146, 130], name: 'Developed, Low Intensity' },
            '23': { color: [235, 0, 0], name: 'Developed, Medium Intensity' },
            '24': { color: [171, 0, 0], name: 'Developed, High Intensity' },
            '31': { color: [179, 172, 159], name: 'Barren Land (Rock/Sand/Clay)' },
            '41': { color: [104, 171, 95], name: 'Deciduous Forest' },
            '42': { color: [28, 95, 44], name: 'Evergreen Forest' },
            '43': { color: [181, 197, 143], name: 'Mixed Forest' },
            '52': { color: [204, 184, 121], name: 'Shrub/Scrub' },
            '71': { color: [223, 223, 194], name: 'Grassland/Herbaceous' },
            '81': { color: [220, 217, 57], name: 'Pasture/Hay' },
            '82': { color: [171, 108, 40], name: 'Cultivated Crops' },
            '90': { color: [184, 217, 235], name: 'Woody Wetlands' },
            '95': { color: [108, 159, 184], name: 'Emergent Herbaceous Wetlands' }
        };

        // Function to find closest NLCD class from RGB color
        function getNLCDClass(r, g, b) {
            let minDistance = Infinity;
            let closestClass = null;

            for (const [code, data] of Object.entries(nlcdColorMap)) {
                const [cr, cg, cb] = data.color;
                // Calculate Euclidean distance in RGB space
                const distance = Math.sqrt(
                    Math.pow(r - cr, 2) +
                    Math.pow(g - cg, 2) +
                    Math.pow(b - cb, 2)
                );

                if (distance < minDistance) {
                    minDistance = distance;
                    closestClass = data.name;
                }
            }

            // Only return if color is reasonably close (threshold to avoid noise)
            return minDistance < 50 ? closestClass : null;
        }

        // Create land cover hover tooltip
        var landCoverTooltip = L.tooltip({
            permanent: false,
            direction: 'top',
            className: 'land-cover-tooltip',
            offset: [0, -10]
        });

        // Create CCS storage hover tooltip
        var ccsTooltip = L.tooltip({
            permanent: false,
            direction: 'top',
            className: 'land-cover-tooltip',
            offset: [0, -10]
        });

        // Variable to track if land cover layer is active
        var isLandCoverActive = false;
        // Variable to track if CCS storage layer is active
        var isCCSActive = false;

        // Debounce function to limit GetFeatureInfo requests
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Variable to track if mouse is over a map feature
        var isOverMapFeature = false;

        // Setup land cover hover functionality using WMS GetFeatureInfo
        function setupLandCoverHover() {
            // Debounced function to query WMS for feature info
            const queryLandCover = debounce(function (latlng) {
                // Don't show land cover tooltip if:
                // 1. Land cover layer is not active
                // 2. Mouse is over a power plant or other map feature
                // 3. Land cover overlay is not in the active overlays array
                // 4. Multiple overlays are active (colors blend, making detection inaccurate)
                const hasLandCoverActive = activeOverlays.includes(baseLayers.landcover);
                const hasMultipleOverlays = activeOverlays.length > 1;
                if (!isLandCoverActive || !hasLandCoverActive || isOverMapFeature || hasMultipleOverlays) {
                    if (map.hasLayer(landCoverTooltip)) {
                        map.closeTooltip(landCoverTooltip);
                    }
                    return;
                }

                // Get map parameters for GetFeatureInfo request
                const size = map.getSize();
                const bounds = map.getBounds();
                const point = map.latLngToContainerPoint(latlng);

                // Build GetFeatureInfo URL
                const url = 'https://www.mrlc.gov/geoserver/wms?' +
                    'SERVICE=WMS&' +
                    'VERSION=1.1.1&' +
                    'REQUEST=GetFeatureInfo&' +
                    'LAYERS=mrlc_display:NLCD_2021_Land_Cover_L48&' +
                    'QUERY_LAYERS=mrlc_display:NLCD_2021_Land_Cover_L48&' +
                    'STYLES=&' +
                    'BBOX=' + bounds.toBBoxString() + '&' +
                    'WIDTH=' + size.x + '&' +
                    'HEIGHT=' + size.y + '&' +
                    'FORMAT=image/png&' +
                    'INFO_FORMAT=application/json&' +
                    'TRANSPARENT=true&' +
                    'X=' + Math.floor(point.x) + '&' +
                    'Y=' + Math.floor(point.y) + '&' +
                    'SRS=EPSG:4326&' +
                    'FEATURE_COUNT=1';

                // Fetch feature info
                fetch(url)
                    .then(response => response.json())
                    .then(data => {
                        // Check again if mouse moved over a feature while we were fetching
                        if (isOverMapFeature) {
                            if (map.hasLayer(landCoverTooltip)) {
                                map.closeTooltip(landCoverTooltip);
                            }
                            return;
                        }

                        if (data.features && data.features.length > 0) {
                            const feature = data.features[0];
                            const properties = feature.properties;

                            // Get NLCD value from PALETTE_INDEX
                            let nlcdValue = properties.PALETTE_INDEX ||
                                properties.NLCD_Land_Cover_Class ||
                                properties.land_cover ||
                                properties.value ||
                                properties.GRAY_INDEX ||
                                properties.grid_code;

                            if (nlcdValue) {
                                // Convert to string and pad with zero if needed
                                const nlcdCode = String(nlcdValue).padStart(2, '0');
                                const landCoverData = nlcdColorMap[nlcdCode];

                                if (landCoverData) {
                                    landCoverTooltip.setLatLng(latlng)
                                        .setContent(`<strong>Land Cover:</strong><br>${landCoverData.name}`)
                                        .addTo(map);
                                } else {
                                    // Show raw value if not in our map
                                    landCoverTooltip.setLatLng(latlng)
                                        .setContent(`<strong>Land Cover:</strong><br>Class ${nlcdCode}`)
                                        .addTo(map);
                                }
                            } else {
                                if (map.hasLayer(landCoverTooltip)) {
                                    map.closeTooltip(landCoverTooltip);
                                }
                            }
                        } else {
                            if (map.hasLayer(landCoverTooltip)) {
                                map.closeTooltip(landCoverTooltip);
                            }
                        }
                    })
                    .catch(error => {
                        if (map.hasLayer(landCoverTooltip)) {
                            map.closeTooltip(landCoverTooltip);
                        }
                    });
            }, 150); // Wait 150ms after mouse stops moving

            // Listen to mouse movement
            map.on('mousemove', function (e) {
                queryLandCover(e.latlng);
            });

            // Track when mouse enters/leaves map features (power plants, substations, lines)
            map.on('mouseover', function (e) {
                if (e.layer && (e.layer.feature || e.layer instanceof L.Marker || e.layer instanceof L.CircleMarker || e.layer instanceof L.Polyline)) {
                    isOverMapFeature = true;
                    if (map.hasLayer(landCoverTooltip)) {
                        map.closeTooltip(landCoverTooltip);
                    }
                }
            });

            map.on('mouseout', function (e) {
                if (e.layer && (e.layer.feature || e.layer instanceof L.Marker || e.layer instanceof L.CircleMarker || e.layer instanceof L.Polyline)) {
                    isOverMapFeature = false;
                }
            });
        }

        // Setup CCS Storage hover functionality
        function setupCCSHover() {
            // Create a canvas to sample pixel colors
            let canvas = document.createElement('canvas');
            let ctx = canvas.getContext('2d');

            // Debounced function to query CCS layer for storage type
            const queryCCS = debounce(function (latlng) {
                // Don't show CCS tooltip if:
                // 1. CCS layer is not active
                // 2. Mouse is over a power plant or other map feature
                // 3. CCS overlay is not in the active overlays array
                // 4. Multiple overlays are active (colors blend, making detection inaccurate)
                const hasCCSActive = activeOverlays.includes(baseLayers.ccusWest);
                const hasMultipleOverlays = activeOverlays.length > 1;
                if (!isCCSActive || !hasCCSActive || isOverMapFeature || hasMultipleOverlays) {
                    if (map.hasLayer(ccsTooltip)) {
                        map.closeTooltip(ccsTooltip);
                    }
                    return;
                }

                // Get the pixel at the mouse position from the CCS tile layer
                const point = map.latLngToContainerPoint(latlng);
                const zoom = map.getZoom();
                const tilePoint = map.project(latlng, zoom).divideBy(256).floor();

                // Build URL for the CCS tile
                const tileUrl = `https://eshan2803.github.io/basemaps/ccus_west_tiles/${zoom}/${tilePoint.x}/${tilePoint.y}.png`;

                // Load the tile image and sample the color
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = function () {
                    try {
                        canvas.width = 256;
                        canvas.height = 256;
                        ctx.drawImage(img, 0, 0);

                        // Get pixel position within the tile
                        const tilePixel = map.project(latlng, zoom).subtract(tilePoint.multiplyBy(256));
                        const pixelData = ctx.getImageData(tilePixel.x, tilePixel.y, 1, 1).data;

                        const r = pixelData[0];
                        const g = pixelData[1];
                        const b = pixelData[2];
                        const a = pixelData[3];

                        // Only process if not transparent
                        if (a > 0) {
                            const storageType = getCCSStorageType(r, g, b);

                            if (storageType) {
                                ccsTooltip.setLatLng(latlng)
                                    .setContent(`<strong>CO2 Storage:</strong><br>${storageType}`)
                                    .addTo(map);
                            } else {
                                if (map.hasLayer(ccsTooltip)) {
                                    map.closeTooltip(ccsTooltip);
                                }
                            }
                        } else {
                            if (map.hasLayer(ccsTooltip)) {
                                map.closeTooltip(ccsTooltip);
                            }
                        }
                    } catch (error) {
                        // Handle CORS or other errors silently
                        if (map.hasLayer(ccsTooltip)) {
                            map.closeTooltip(ccsTooltip);
                        }
                    }
                };
                img.onerror = function () {
                    // Tile doesn't exist or failed to load
                    if (map.hasLayer(ccsTooltip)) {
                        map.closeTooltip(ccsTooltip);
                    }
                };
                img.src = tileUrl;
            }, 150);


            // Listen to mouse movement
            map.on('mousemove', function (e) {
                queryCCS(e.latlng);
            });
        }

        // Setup home button to reset view to default California bounds
        function setupHomeButton() {
            // Create custom control for home button
            L.Control.Home = L.Control.extend({
                onAdd: function (map) {
                    var container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-home');
                    container.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>';
                    container.title = 'Reset to default view';

                    L.DomEvent.disableClickPropagation(container);
                    L.DomEvent.on(container, 'click', function () {
                        fitMapToData();
                    });

                    return container;
                },
                onRemove: function (map) {
                    // Nothing to do here
                }
            });

            L.control.home = function (opts) {
                return new L.Control.Home(opts);
            }

            // Add the home button to the map
            L.control.home({ position: 'topleft' }).addTo(map);
        }

        // Setup documentation button linking to documentation page
        function setupDocButton() {
            L.Control.Doc = L.Control.extend({
                onAdd: function (map) {
                    var container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-doc');
                    // Open book icon
                    container.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"/></svg>';
                    container.title = 'View Documentation';

                    L.DomEvent.disableClickPropagation(container);
                    L.DomEvent.on(container, 'click', function () {
                        window.open('./documentation.html', '_blank');
                    });

                    return container;
                },
                onRemove: function (map) { }
            });

            L.control.doc = function (opts) {
                return new L.Control.Doc(opts);
            }

            L.control.doc({ position: 'topleft' }).addTo(map);
        }

        // Removed custom generator functionality - we're using real power plant data

        // Custom triangle marker
        L.TriangleMarker = L.CircleMarker.extend({
            options: { rotation: 0 }
        });
        L.triangleMarker = function (latlng, options) {
            return new L.TriangleMarker(latlng, options);
        };

        // Coordinate conversion for EPSG:3857 (Web Mercator) to EPSG:4326/4269 (Lon/Lat)
        function project3857to4326(coords) {
            const x = coords[0];
            const y = coords[1];
            const lon = (x / 20037508.34) * 180;
            let lat = (y / 20037508.34) * 180;
            lat = (180 / Math.PI) * (2 * Math.atan(Math.exp(lat * Math.PI / 180)) - Math.PI / 2);
            return [lon, lat];
        }

        // Build network graph from loaded data
        function buildNetworkGraph() {
            // Check for EPSG:3857 coordinates in transmission data and convert if necessary
            if (transmissionData && transmissionData.features && transmissionData.features.length > 0) {
                let firstFeature = transmissionData.features[0];
                let checkCoords = firstFeature.geometry.coordinates;
                // Handle MultiLineString (nested arrays)
                if (checkCoords && Array.isArray(checkCoords[0]) && Array.isArray(checkCoords[0][0])) {
                    checkCoords = checkCoords[0];
                }

                if (checkCoords && checkCoords.length > 0 && Array.isArray(checkCoords[0])) {
                    const x = checkCoords[0][0];
                    const y = checkCoords[0][1];
                    // EPSG:3857 bounds are huge. WGS84 is -180 to 180.
                    if (Math.abs(x) > 180 || Math.abs(y) > 90) {
                        console.warn("Detected EPSG:3857 coordinates in transmission.geojson. Converting to WGS84...");
                        // Use turf to convert the entire FeatureCollection
                        transmissionData = turf.toWgs84(transmissionData);
                    }
                }
            }

            const TOLERANCE = 0.01; // ~1km tolerance for matching line endpoints to substations

            // 1. Build substations nodes
            substationsData.features.forEach((feature, idx) => {
                const props = feature.properties;
                const coords = feature.geometry.coordinates;

                // Validate coordinates
                if (!coords || coords.length < 2 ||
                    typeof coords[0] !== 'number' || typeof coords[1] !== 'number' ||
                    isNaN(coords[0]) || isNaN(coords[1])) {
                    console.warn(`Invalid substation coordinates at index ${idx}:`, coords);
                    return;
                }

                networkGraph.substations.push({
                    id: `sub_${idx}`,
                    latlng: [coords[1], coords[0]], // Leaflet uses [lat, lng]
                    name: props.Name || 'Unknown',
                    voltage: props.Max_Voltage || 0,
                    connectedLines: [],
                    feature: feature
                });
            });

            // Create substation points collection once (outside the loop for efficiency)
            const substationPoints = turf.featureCollection(
                networkGraph.substations.map(sub =>
                    turf.point([sub.latlng[1], sub.latlng[0]], { id: sub.id })
                )
            );

            if (substationPoints.features.length === 0) {
                console.error('No valid substations found!');
                return;
            }

            // 2. Build transmission lines and connect to substations
            transmissionData.features.forEach((feature, idx) => {
                const coords = feature.geometry.coordinates;
                if (!coords || coords.length < 2) return;

                // Handle MultiLineString (nested arrays) - flatten to first linestring
                let actualCoords = coords;
                if (Array.isArray(coords[0][0])) {
                    // This is a MultiLineString - use the first line
                    actualCoords = coords[0];
                    if (!actualCoords || actualCoords.length < 2) return;
                }

                // NOTE: transmission.geojson may contain EPSG:3857 (Web Mercator) coordinates
                // These are automatically converted to WGS84 (lat/lng) at the start of buildNetworkGraph if detected.

                // Validate start and end coordinates
                const startCoord = actualCoords[0];
                const endCoord = actualCoords[actualCoords.length - 1];

                if (!startCoord || startCoord.length < 2 ||
                    typeof startCoord[0] !== 'number' || typeof startCoord[1] !== 'number' ||
                    isNaN(startCoord[0]) || isNaN(startCoord[1])) {
                    console.warn(`Invalid start coord for line ${idx}:`, startCoord);
                    return;
                }

                if (!endCoord || endCoord.length < 2 ||
                    typeof endCoord[0] !== 'number' || typeof endCoord[1] !== 'number' ||
                    isNaN(endCoord[0]) || isNaN(endCoord[1])) {
                    console.warn(`Invalid end coord for line ${idx}:`, endCoord);
                    return;
                }

                // Get start and end points
                const startPoint = turf.point(startCoord);
                const endPoint = turf.point(endCoord);

                // Find nearest substations to start and end
                const nearestStart = turf.nearestPoint(startPoint, substationPoints);
                const nearestEnd = turf.nearestPoint(endPoint, substationPoints);

                // Only connect if within tolerance
                const distStart = turf.distance(startPoint, nearestStart, { units: 'kilometers' });
                const distEnd = turf.distance(endPoint, nearestEnd, { units: 'kilometers' });

                let startNodeId = null, endNodeId = null;

                if (distStart < TOLERANCE) {
                    startNodeId = nearestStart.properties.id;
                }
                if (distEnd < TOLERANCE) {
                    endNodeId = nearestEnd.properties.id;
                }

                const lineId = `line_${idx}`;
                networkGraph.lines.push({
                    id: lineId,
                    coords: actualCoords, // Use actualCoords instead of coords
                    startNodeId: startNodeId,
                    endNodeId: endNodeId,
                    feature: feature
                });

                // Add line to substations' connected lines
                if (startNodeId) {
                    const sub = networkGraph.substations.find(s => s.id === startNodeId);
                    if (sub) sub.connectedLines.push(lineId);
                    if (!networkGraph.linesBySubstation[startNodeId]) {
                        networkGraph.linesBySubstation[startNodeId] = [];
                    }
                    networkGraph.linesBySubstation[startNodeId].push(lineId);
                }
                if (endNodeId && endNodeId !== startNodeId) {
                    const sub = networkGraph.substations.find(s => s.id === endNodeId);
                    if (sub) sub.connectedLines.push(lineId);
                    if (!networkGraph.linesBySubstation[endNodeId]) {
                        networkGraph.linesBySubstation[endNodeId] = [];
                    }
                    networkGraph.linesBySubstation[endNodeId].push(lineId);
                }
            });

            // 4. Identify Electrical Islands (Connected Components)
            console.log('Calculating electrical islands...');
            let islandCounter = 0;
            const visitedSubstations = new Set();

            networkGraph.substations.forEach(substation => {
                if (!visitedSubstations.has(substation.id)) {
                    islandCounter++;
                    const islandId = `island_${islandCounter}`;

                    networkGraph.islands[islandId] = {
                        lines: [],
                        substations: []
                    };

                    // BFS to find all connected components
                    const queue = [substation.id];
                    visitedSubstations.add(substation.id);

                    // Assign island to starting substation
                    substation.islandId = islandId;
                    networkGraph.islands[islandId].substations.push(substation.id);

                    while (queue.length > 0) {
                        const currentSubId = queue.shift();

                        // Get connected lines
                        const connectedLineIds = networkGraph.linesBySubstation[currentSubId] || [];

                        connectedLineIds.forEach(lineId => {
                            const line = networkGraph.lines.find(l => l.id === lineId);
                            if (!line) return;

                            // Assign island to line (if not already assigned)
                            if (!line.islandId) {
                                line.islandId = islandId;
                                networkGraph.islands[islandId].lines.push(lineId);
                            }

                            // Check other end of the line
                            let otherSubId = null;
                            if (line.startNodeId === currentSubId) otherSubId = line.endNodeId;
                            else if (line.endNodeId === currentSubId) otherSubId = line.startNodeId;

                            if (otherSubId && !visitedSubstations.has(otherSubId)) {
                                visitedSubstations.add(otherSubId);
                                queue.push(otherSubId);

                                // Assign island to other substation
                                const otherSub = networkGraph.substations.find(s => s.id === otherSubId);
                                if (otherSub) {
                                    otherSub.islandId = islandId;
                                    networkGraph.islands[islandId].substations.push(otherSubId);
                                }
                            }
                        });
                    }
                }
            });
            console.log(`Identified ${islandCounter} electrical islands.`);

            // 3. Connect plants to nearest substations
            plantsData.features.forEach((feature, idx) => {
                const props = feature.properties;
                const coords = feature.geometry.coordinates;

                // Validate coordinates
                if (!coords || coords.length < 2 ||
                    typeof coords[0] !== 'number' || typeof coords[1] !== 'number' ||
                    isNaN(coords[0]) || isNaN(coords[1])) {
                    console.warn(`Invalid plant coordinates at index ${idx}:`, coords);
                    return;
                }

                const plantPoint = turf.point(coords);

                // Reuse substationPoints already created above
                const nearest = turf.nearestPoint(plantPoint, substationPoints);
                const nearestSubId = nearest.properties.id;

                // Find the substation to get its island ID
                const nearestSub = networkGraph.substations.find(s => s.id === nearestSubId);
                const islandId = nearestSub ? nearestSub.islandId : null;

                networkGraph.plants.push({
                    id: `plant_${idx}`,
                    latlng: [coords[1], coords[0]],
                    name: props.PlantName || 'Unknown',
                    fuel: props.PriEnergySource || 'UNKNOWN',
                    capacity: parseFloat(props.Capacity_Latest) || 0,
                    nearestSubstationId: nearestSubId,
                    feature: feature,
                    isOn: false,
                    islandId: islandId // Assign island ID
                });
            });

            console.log(`Network graph built: ${networkGraph.substations.length} substations, ${networkGraph.plants.length} plants, ${networkGraph.lines.length} lines`);

            // Log connectivity stats
            const connectedLines = networkGraph.lines.filter(l => l.startNodeId || l.endNodeId).length;
            console.log(`${connectedLines} lines connected to substations (${(connectedLines / networkGraph.lines.length * 100).toFixed(1)}%)`);
            // 5. Update legend counts based on actual data
            updateLegendCounts();

            // 6. Calculate System Capacities
            sysCap = { GAS: 0, HYDRO: 0, SOLAR: 0, WIND: 0, BASELOAD: 0, BATTERY: 0, TOTAL: 0 };
            networkGraph.plants.forEach(p => {
                const cap = p.capacity;
                if (cap <= 0) return;

                const f = (p.fuel || 'UNKNOWN').toUpperCase();

                if (['NG', 'GAS', 'OGW', 'OG', 'BIT', 'OIL', 'DFO'].includes(f)) sysCap.GAS += cap;
                else if (['WAT', 'HYD'].includes(f)) sysCap.HYDRO += cap;
                else if (f === 'SUN') sysCap.SOLAR += cap;
                else if (['WND', 'WIND'].includes(f)) sysCap.WIND += cap;
                else if (['NUC', 'GEO', 'BIO', 'WH', 'LFG', 'WDS', 'OBG', 'MSW', 'AB', 'OBS'].includes(f)) sysCap.BASELOAD += cap;
                else if (['BAT', 'OTH'].includes(f)) sysCap.BATTERY += cap;

                sysCap.TOTAL += cap;
            });
            console.log('Calculated system capacities from data:', sysCap);
        }

        // Function to update legend counts dynamically
        function updateLegendCounts() {
            // Initialize counters
            const counts = {};

            // Count plants by fuel type
            networkGraph.plants.forEach(plant => {
                // Skip if capacity is 0 (likely retired)
                if (plant.capacity <= 0) return;

                const fuel = (plant.fuel || 'UNKNOWN').toUpperCase();
                counts[fuel] = (counts[fuel] || 0) + 1;
            });

            // Update legend items
            const legendItems = document.querySelectorAll('.legend-item.fuel-filter');
            legendItems.forEach(item => {
                const fuels = item.getAttribute('data-fuel').split(',');
                let total = 0;

                fuels.forEach(fuel => {
                    total += (counts[fuel] || 0);
                });

                // Update text content, preserving the label name
                // Text structure is usually "Label (Count)" inside the div, but often with an SVG span first
                // We need to carefully update just the text node or reconstruct the innerHTML

                // Get the label name (nodeValue of the text node, or derived from current text)
                // The HTML structure is: <span>SVG</span> Label (Count)

                // Safer approach: Get the label part by removing the numeric part
                // Or hardcode the mapping based on data-fuel if needed, but parsing current text is better generic way

                let labelText = item.textContent.trim();
                const parenIndex = labelText.lastIndexOf('(');
                if (parenIndex > -1) {
                    labelText = labelText.substring(0, parenIndex).trim();
                }

                // Reconstruct HTML
                const iconSpan = item.querySelector('span');
                if (iconSpan) {
                    item.innerHTML = '';
                    item.appendChild(iconSpan);
                    item.append(` ${labelText} (${total})`);
                }
            });

            console.log('Legend counts updated');
        }

        // BFS to find all lines connected to a substation - REMOVED (Optimized with Island pre-calculation)
        // function getConnectedLines(startSubstationId) { ... }

        // Generate HTML for plant marker based on fuel type and color
        // Optional size parameter: 'normal' (12px default) or 'large' (18px for wind, 16px for battery/nuclear)
        function getMarkerHTML(fuelType, color, size = 'normal') {
            const isLarge = size === 'large';
            const windSize = isLarge ? 18 : 12;
            const windHalfSize = isLarge ? 9 : 6;
            const batterySize = isLarge ? 16 : 12;
            const batteryHalfSize = isLarge ? 8 : 6;
            const nuclearSize = isLarge ? 16 : 12;
            const nuclearHalfSize = isLarge ? 8 : 6;

            switch (fuelType.toUpperCase()) {
                case 'WND':
                case 'WIND':
                    return `<svg width="${windSize}" height="${windSize}" style="margin-left: -${windHalfSize}px; margin-top: -${windHalfSize}px;"><polygon points="${windHalfSize},${isLarge ? 3 : 2} ${isLarge ? 16 : 11},${isLarge ? 15 : 10} ${isLarge ? 2 : 1},${isLarge ? 15 : 10}" fill="${color}" stroke="#000" stroke-width="1"/></svg>`;

                case 'NG':
                case 'GAS':
                case 'OGW':
                case 'OG':
                    return `<div style="width: 10px; height: 10px; background-color: ${color}; border: 1px solid #000; margin-left: -5px; margin-top: -5px;"></div>`;

                case 'WAT':
                    return `<svg width="12" height="12" style="margin-left: -6px; margin-top: -6px;"><polygon points="3,1 9,1 11.5,6 9,11 3,11 0.5,6" fill="${color}" stroke="#000" stroke-width="1"/></svg>`;

                case 'GEO':
                case 'WH':
                    return `<div style="width: 8px; height: 8px; background-color: ${color}; border: 1px solid #000; transform: rotate(45deg); margin-left: -4px; margin-top: -4px;"></div>`;

                case 'NUC':
                    return `<svg width="${nuclearSize}" height="${nuclearSize}" style="margin-left: -${nuclearHalfSize}px; margin-top: -${nuclearHalfSize}px;"><polygon points="${nuclearHalfSize},${isLarge ? 1.5 : 1} ${isLarge ? 14 : 11},${isLarge ? 5 : 4} ${isLarge ? 12 : 9},${isLarge ? 13 : 10} ${isLarge ? 4 : 3},${isLarge ? 13 : 10} ${isLarge ? 2 : 1},${isLarge ? 5 : 4}" fill="${color}" stroke="#000" stroke-width="1"/></svg>`;

                case 'LFG':
                case 'WDS':
                case 'OBG':
                case 'MSW':
                case 'AB':
                case 'OBS':
                    return `<svg width="12" height="12" style="margin-left: -6px; margin-top: -6px;"><rect x="5" y="1" width="2" height="10" fill="${color}" stroke="#000" stroke-width="0.5"/><rect x="1" y="5" width="10" height="2" fill="${color}" stroke="#000" stroke-width="0.5"/></svg>`;

                case 'BIT':
                case 'OIL':
                case 'DFO':
                case 'SUB':
                case 'JF':
                case 'BLQ':
                case 'PC': // Petroleum Coke - grouped with Coal/Oil
                    return `<svg width="12" height="12" style="margin-left: -6px; margin-top: -6px;"><line x1="2" y1="2" x2="10" y2="10" stroke="#000" stroke-width="2"/><line x1="10" y1="2" x2="2" y2="10" stroke="#000" stroke-width="2"/><line x1="2" y1="2" x2="10" y2="10" stroke="${color}" stroke-width="1.5"/><line x1="10" y1="2" x2="2" y2="10" stroke="${color}" stroke-width="1.5"/></svg>`;

                case 'BAT':
                case 'OTH': // Vaca Dixon Battery Storage is marked as OTH
                    return `<svg width="${batterySize}" height="${batterySize}" style="margin-left: -${batteryHalfSize}px; margin-top: -${batteryHalfSize}px;"><rect x="${isLarge ? 3 : 2}" y="${isLarge ? 5 : 4}" width="${isLarge ? 10 : 8}" height="${isLarge ? 6 : 5}" fill="${color}" stroke="#000" stroke-width="1"/><rect x="${isLarge ? 5 : 4}" y="${isLarge ? 4 : 3}" width="${isLarge ? 6 : 4}" height="1" fill="${color}" stroke="#000" stroke-width="0.5"/></svg>`;

                default:
                    return `<svg width="12" height="12" style="margin-left: -6px; margin-top: -6px;"><polygon points="4,1 8,1 11,4 11,8 8,11 4,11 1,8 1,4" fill="${color}" stroke="#000" stroke-width="1"/></svg>`;
            }
        }

        // Get fuel color for plant
        function getFuelColor(fuel) {
            switch ((fuel || 'UNKNOWN').toUpperCase()) {
                case 'SUN': return '#FFD700'; // Solar - Gold
                case 'WND': return '#1E90FF'; // Wind - Dodger Blue
                case 'WIND': return '#1E90FF'; // Wind alternate
                case 'NG': return '#FF4500'; // Natural Gas - Orange-Red
                case 'GAS': return '#FF4500'; // Natural Gas alternate
                case 'WAT': return '#00CED1'; // Water/Hydro - Dark Turquoise
                case 'LFG': return '#D2691E'; // Landfill Gas - Chocolate (brighter brown)
                case 'GEO': return '#DC143C'; // Geothermal - Crimson
                case 'WDS': return '#D2691E'; // Wood/Biomass - Chocolate (brighter brown)
                case 'OBG': return '#D2691E'; // Other Biogas - Chocolate (brighter brown)
                case 'BAT': return '#FFD700'; // Battery Storage - Gold (energy storage)
                case 'OTH': return '#FFD700'; // Other (Vaca Dixon Battery) - Gold
                case 'BIT': return '#FF6347'; // Bituminous Coal - Tomato (bright red-orange)
                case 'PC': return '#FF6347'; // Petroleum Coke - Tomato (bright red-orange)
                case 'OGW': return '#FF4500'; // Other Gas - Orange-Red
                case 'OIL': return '#FF6347'; // Oil - Tomato (bright red-orange)
                case 'DFO': return '#FF6347'; // Distillate Fuel Oil - Tomato (bright red-orange)
                case 'MSW': return '#D2691E'; // Municipal Solid Waste - Chocolate (brighter brown)
                case 'WH': return '#DC143C'; // Waste Heat - Crimson
                case 'NUC': return '#BA55D3'; // Nuclear - Medium Orchid (brighter purple)
                case 'AB': return '#D2691E'; // Agricultural Byproduct - Chocolate (brighter brown)
                case 'SUB': return '#FF6347'; // Sub-Bituminous Coal - Tomato (bright red-orange)
                case 'JF': return '#FF6347'; // Jet Fuel - Tomato (bright red-orange)
                case 'BLQ': return '#FF6347'; // Black Liquor - Tomato (bright red-orange)
                case 'OBS': return '#D2691E'; // Other Biomass Solids - Chocolate (brighter brown)
                case 'OG': return '#FF4500'; // Other Gas - Orange-Red
                default: return '#FF1493'; // Unknown - Deep Pink
            }
        }

        // Render map with all layers
        function renderMap() {
            // Initialize layers
            staticLinesLayer = L.layerGroup().addTo(map);
            animatedLinesLayer = L.layerGroup();

            // Render transmission lines (visible but subtle initially)
            networkGraph.lines.forEach((lineData, idx) => {
                const coords = lineData.coords.map(c => [c[1], c[0]]); // Convert to [lat, lng]

                // Static line in subtle cyan/teal color (visible on greyscale)
                const staticLine = L.polyline(coords, {
                    color: '#4A90A4',  // Muted teal-blue that shows on greyscale
                    weight: 2,
                    opacity: 0.6
                });
                staticLine.lineId = lineData.id;
                staticLinesLayer.addLayer(staticLine);

                // Pre-create animated line (hidden initially)
                const antPath = L.polyline.antPath(coords, {
                    color: '#39FF14', // Neon green flow
                    weight: 3,
                    opacity: 0.8,
                    delay: 500,
                    dashArray: [10, 20],
                    pulseColor: '#FFFFFF',
                    hardwareAccelerated: true
                });
                antPath.lineId = lineData.id;
                lineData.antPath = antPath;
            });

            // Render substations (smaller neon green circles)
            networkGraph.substations.forEach(subData => {
                const marker = L.circleMarker(subData.latlng, {
                    radius: 2,  // Reduced from 4 to 2
                    fillColor: '#39FF14', // Neon green
                    color: '#000',
                    weight: 0.5,  // Thinner border
                    opacity: 0.8,
                    fillOpacity: 0.7
                });

                const props = subData.feature.properties;
                const name = props.Name || 'Unknown Substation';
                const voltage = props.Max_Voltage || 'Unknown';
                const county = props.COUNTY || 'Unknown';

                // Only bind tooltip (shows on hover) - no popup needed
                marker.bindTooltip(`<b>${name}</b> Substation<br>${voltage} kV<br>${county}`, {
                    direction: 'top',
                    offset: [0, -5],
                    opacity: 0.9
                });

                substationsLayer.addLayer(marker);
                subData.marker = marker;
            });

            // Render power plants with different shapes based on fuel type (all same small size)
            networkGraph.plants.forEach(plantData => {
                // Skip retired plants (capacity <= 0)
                if (plantData.capacity <= 0) {
                    return;
                }

                const color = getFuelColor(plantData.fuel);
                const fuelType = (plantData.fuel || 'UNKNOWN').toUpperCase();

                let marker;

                // Create different shapes based on fuel type (all size 12px)
                switch (fuelType) {
                    case 'SUN': // Solar - Circle
                        marker = L.circleMarker(plantData.latlng, {
                            radius: 6,
                            fillColor: '#808080',
                            color: '#000',
                            weight: 1,
                            opacity: 1,
                            fillOpacity: 0.8
                        });
                        break;

                    case 'WND': // Wind - Triangle pointing up (SVG for consistent border) - LARGER SIZE (18px)
                    case 'WIND':
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: getMarkerHTML(fuelType, '#808080', 'large'),
                                iconSize: [18, 18],
                                iconAnchor: [9, 9]
                            })
                        });
                        break;

                    case 'NG': // Natural Gas - Square
                    case 'GAS':
                    case 'OGW':
                    case 'OG':
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<div style="width: 10px; height: 10px; background-color: #808080; border: 1px solid #000; margin-left: -5px; margin-top: -5px;"></div>`,
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        });
                        break;

                    case 'WAT': // Hydro - Hexagon with border
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<svg width="12" height="12" style="margin-left: -6px; margin-top: -6px;"><polygon points="3,1 9,1 11.5,6 9,11 3,11 0.5,6" fill="#808080" stroke="#000" stroke-width="1"/></svg>`,
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        });
                        break;

                    case 'GEO': // Geothermal - Diamond with border
                    case 'WH':
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<div style="width: 8px; height: 8px; background-color: #808080; border: 1px solid #000; transform: rotate(45deg); margin-left: -4px; margin-top: -4px;"></div>`,
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        });
                        break;

                    case 'PC': // Petroleum Coke - Pentagon with border
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<svg width="12" height="12" style="margin-left: -6px; margin-top: -6px;"><polygon points="6,1 11,4 9,10 3,10 1,4" fill="#808080" stroke="#000" stroke-width="1"/></svg>`,
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        });
                        break;

                    case 'NUC': // Nuclear - Pentagon with border - LARGER SIZE
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: getMarkerHTML(fuelType, '#808080', 'large'),
                                iconSize: [16, 16],
                                iconAnchor: [8, 8]
                            })
                        });
                        break;

                    case 'LFG': // Landfill Gas - Plus sign
                    case 'WDS':
                    case 'OBG':
                    case 'MSW':
                    case 'AB':
                    case 'OBS':
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<svg width="12" height="12" style="margin-left: -6px; margin-top: -6px;"><rect x="5" y="1" width="2" height="10" fill="#808080" stroke="#000" stroke-width="0.5"/><rect x="1" y="5" width="10" height="2" fill="#808080" stroke="#000" stroke-width="0.5"/></svg>`,
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        });
                        break;

                    case 'BIT': // Coal/Oil - X shape
                    case 'OIL':
                    case 'DFO':
                    case 'SUB':
                    case 'JF':
                    case 'BLQ':
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<svg width="12" height="12" style="margin-left: -6px; margin-top: -6px;"><line x1="2" y1="2" x2="10" y2="10" stroke="#000" stroke-width="2"/><line x1="10" y1="2" x2="2" y2="10" stroke="#000" stroke-width="2"/><line x1="2" y1="2" x2="10" y2="10" stroke="#808080" stroke-width="1.5"/><line x1="10" y1="2" x2="2" y2="10" stroke="#808080" stroke-width="1.5"/></svg>`,
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        });
                        break;

                    case 'BAT': // Battery - Rectangle with border - LARGER SIZE
                    case 'OTH': // Other (often battery storage)
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: getMarkerHTML(fuelType, '#808080', 'large'),
                                iconSize: [16, 16],
                                iconAnchor: [8, 8]
                            })
                        });
                        break;

                    default: // Other - Octagon with border
                        marker = L.marker(plantData.latlng, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<svg width="12" height="12" style="margin-left: -6px; margin-top: -6px;"><polygon points="4,1 8,1 11,4 11,8 8,11 4,11 1,8 1,4" fill="#808080" stroke="#000" stroke-width="1"/></svg>`,
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        });
                }

                const name = plantData.name;
                const fuel = plantData.fuel;
                const capacity = plantData.capacity;

                // Only bind tooltip (shows on hover) - no popup needed
                marker.bindTooltip(`<b>${name}</b><br>Type: ${fuel}<br>Capacity: ${capacity} MW<br><i>Click to turn ON/OFF</i>`, {
                    direction: 'top',
                    offset: [0, -10],
                    opacity: 0.9
                });

                // Click handler to toggle plant on/off
                marker.on('click', function (e) {
                    L.DomEvent.stopPropagation(e); // Prevent map click

                    // Close any open tooltips to prevent lingering
                    marker.closeTooltip();

                    plantData.isOn = !plantData.isOn;

                    if (plantData.isOn) {
                        activeGenerators++;

                        // Update marker color based on type
                        if (marker instanceof L.CircleMarker) {
                            marker.setStyle({ fillColor: color });
                        } else {
                            const isLargeMarker = ['WND', 'WIND', 'BAT', 'OTH', 'NUC'].includes(fuelType);
                            const isWind = ['WND', 'WIND'].includes(fuelType);
                            const markerSize = isWind ? 18 : (isLargeMarker ? 16 : 12);
                            const markerAnchor = isWind ? 9 : (isLargeMarker ? 8 : 6);
                            marker.setIcon(L.divIcon({
                                className: 'custom-div-icon',
                                html: getMarkerHTML(fuelType, color, 'large'),
                                iconSize: [markerSize, markerSize],
                                iconAnchor: [markerAnchor, markerAnchor]
                            }));
                        }
                    } else {
                        activeGenerators--;

                        // Reset to grey
                        if (marker instanceof L.CircleMarker) {
                            marker.setStyle({ fillColor: '#808080' });
                        } else {
                            const isLargeMarker = ['WND', 'WIND', 'BAT', 'OTH', 'NUC'].includes(fuelType);
                            const isWind = ['WND', 'WIND'].includes(fuelType);
                            const markerSize = isWind ? 18 : (isLargeMarker ? 16 : 12);
                            const markerAnchor = isWind ? 9 : (isLargeMarker ? 8 : 6);
                            marker.setIcon(L.divIcon({
                                className: 'custom-div-icon',
                                html: getMarkerHTML(fuelType, '#808080', 'large'),
                                iconSize: [markerSize, markerSize],
                                iconAnchor: [markerAnchor, markerAnchor]
                            }));
                        }
                    }

                    updateFlow();
                });

                plantsLayer.addLayer(marker);
                plantData.marker = marker;
            });

            console.log('Map rendered with all layers.');

            // Fit map to show all data points
            fitMapToData();
        }

        // Fit map bounds to show all California data
        function fitMapToData() {
            try {
                // Calculate bounds manually from all coordinates
                let minLat = Infinity, maxLat = -Infinity;
                let minLng = Infinity, maxLng = -Infinity;

                // Get bounds from substations
                networkGraph.substations.forEach(sub => {
                    const lat = sub.latlng[0];
                    const lng = sub.latlng[1];
                    if (lat < minLat) minLat = lat;
                    if (lat > maxLat) maxLat = lat;
                    if (lng < minLng) minLng = lng;
                    if (lng > maxLng) maxLng = lng;
                });

                // Get bounds from plants
                networkGraph.plants.forEach(plant => {
                    const lat = plant.latlng[0];
                    const lng = plant.latlng[1];
                    if (lat < minLat) minLat = lat;
                    if (lat > maxLat) maxLat = lat;
                    if (lng < minLng) minLng = lng;
                    if (lng > maxLng) maxLng = lng;
                });

                // Create bounds
                const bounds = [[minLat, minLng], [maxLat, maxLng]];

                // Fit map to bounds with some padding
                map.fitBounds(bounds, {
                    padding: [50, 50],  // 50px padding on all sides
                    maxZoom: 7          // Don't zoom in too much
                });

                console.log('Map fitted to data bounds:', bounds);
            } catch (error) {
                console.error('Error fitting map to bounds:', error);
                // Fallback to California center
                map.setView([36.7783, -119.4179], 6);
            }
        }

        // Updated function to show flow only on connected lines using pre-calculated Islands
        function updateFlow() {
            // Update counter display
            document.getElementById('activeCount').textContent = activeGenerators;

            // Clear animated layer
            animatedLinesLayer.clearLayers();

            if (activeGenerators > 0) {
                // Set of active island IDs
                const activeIslandIds = new Set();

                // Find all active plants and collect their island IDs
                networkGraph.plants.forEach(plant => {
                    if (plant.isOn && plant.islandId) {
                        activeIslandIds.add(plant.islandId);
                    }
                });

                // Collect all line IDs from active islands
                const allConnectedLineIds = new Set();
                activeIslandIds.forEach(islandId => {
                    if (networkGraph.islands[islandId]) {
                        networkGraph.islands[islandId].lines.forEach(lineId => {
                            allConnectedLineIds.add(lineId);
                        });
                    }
                });

                console.log(`${activeGenerators} active plants, ${activeIslandIds.size} active islands, ${allConnectedLineIds.size} lines to animate`);

                // Update static lines: hide animated ones, show others in teal-blue
                staticLinesLayer.eachLayer(function (layer) {
                    if (allConnectedLineIds.has(layer.lineId)) {
                        // Hide this static line (will be replaced by animated version)
                        layer.setStyle({ opacity: 0 });
                    } else {
                        // Show this static line in teal-blue
                        layer.setStyle({
                            color: '#4A90A4',
                            opacity: 0.6
                        });
                    }
                });

                // Add animated ant paths for connected lines
                allConnectedLineIds.forEach(lineId => {
                    const lineData = networkGraph.lines.find(l => l.id === lineId);
                    if (lineData && lineData.antPath) {
                        animatedLinesLayer.addLayer(lineData.antPath);
                    }
                });

                // Show animated layer (static layer stays visible)
                if (!map.hasLayer(animatedLinesLayer)) {
                    animatedLinesLayer.addTo(map);
                }
            } else {
                // No active generators - restore all static lines to teal-blue
                staticLinesLayer.eachLayer(function (layer) {
                    layer.setStyle({
                        color: '#4A90A4',
                        opacity: 0.6
                    });
                });

                // Remove animated layer
                if (map.hasLayer(animatedLinesLayer)) {
                    map.removeLayer(animatedLinesLayer);
                }
            }
        }

        // --- Time Simulation Logic ---

        // Default Profiles (Arrays of 24 values)
        const profiles = {
            solar: [],
            wind: [],
            load: []
        };

        // Temporary profile storage for editing
        let tempProfiles = {
            solar: [],
            wind: [],
            load: []
        };

        let currentTab = 'solar';

        function setupTimeSimulation() {
            // Initialize Profiles
            initProfiles();

            const timeSlider = document.getElementById('timeSlider');
            const timeText = document.getElementById('timeText');
            const simStatus = document.getElementById('simStatus');
            const timeBasedToggle = document.getElementById('timeBasedToggle');
            const prevHourBtn = document.getElementById('prevHourBtn');
            const nextHourBtn = document.getElementById('nextHourBtn');

            // Initial update - small delay to ensure plants are loaded
            setTimeout(() => {
                if (timeBasedToggle.checked) {
                    updateSimulation(parseInt(timeSlider.value));
                }
            }, 1000);

            // Handle checkbox toggle
            timeBasedToggle.addEventListener('change', function () {
                if (this.checked) {
                    // Enable time-based simulation
                    timeSlider.style.opacity = '1';
                    timeSlider.disabled = false;
                    updateSimulation(parseInt(timeSlider.value));
                } else {
                    // Disable time-based simulation - turn all plants OFF
                    timeSlider.style.opacity = '0.5';
                    timeSlider.disabled = true;

                    // Turn all plants OFF
                    activeGenerators = 0;
                    networkGraph.plants.forEach(plant => {
                        plant.isOn = false;
                        const fuelType = (plant.fuel || 'UNKNOWN').toUpperCase();
                        updatePlantMarker(plant, false, '#808080');
                    });

                    // Update flow to clear all animated lines
                    updateFlow();
                }
            });

            timeSlider.addEventListener('input', function () {
                const hour = parseInt(this.value);

                // Update Time Display
                const ampm = hour >= 12 ? 'PM' : 'AM';
                const displayHour = hour % 12 || 12;
                timeText.textContent = `${displayHour}:00 ${ampm}`;

                // Update Simulation Status Text
                updateStatusText(hour);

                // Only update simulation if time-based mode is enabled
                if (timeBasedToggle.checked) {
                    updateSimulation(hour);
                }
            });

            // Tooltip for slider hover
            const tooltip = document.getElementById('timeSliderTooltip');

            function formatHour(hour) {
                const ampm = hour >= 12 ? 'PM' : 'AM';
                const displayHour = hour % 12 || 12;
                return `${displayHour}:00 ${ampm}`;
            }

            function getHourFromPosition(e, slider) {
                const rect = slider.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const percent = Math.max(0, Math.min(1, x / rect.width));
                return Math.round(percent * 23);
            }

            timeSlider.addEventListener('mouseenter', function (e) {
                if (!this.disabled) {
                    tooltip.classList.add('visible');
                }
            });

            timeSlider.addEventListener('mousemove', function (e) {
                if (!this.disabled) {
                    const hour = getHourFromPosition(e, this);
                    tooltip.textContent = formatHour(hour);

                    // Position tooltip above cursor (centered horizontally)
                    const rect = this.getBoundingClientRect();
                    tooltip.style.left = e.clientX + 'px';
                    tooltip.style.top = (rect.top - 35) + 'px';
                }
            });

            timeSlider.addEventListener('mouseleave', function () {
                tooltip.classList.remove('visible');
            });

            // Previous hour button handler
            prevHourBtn.addEventListener('click', function () {
                const currentHour = parseInt(timeSlider.value);
                const newHour = currentHour === 0 ? 23 : currentHour - 1;
                timeSlider.value = newHour;

                // Trigger the input event to update display and simulation
                const event = new Event('input');
                timeSlider.dispatchEvent(event);
            });

            // Next hour button handler
            nextHourBtn.addEventListener('click', function () {
                const currentHour = parseInt(timeSlider.value);
                const newHour = currentHour === 23 ? 0 : currentHour + 1;
                timeSlider.value = newHour;

                // Trigger the input event to update display and simulation
                const event = new Event('input');
                timeSlider.dispatchEvent(event);
            });

            setupProfileEditor();
        }

        function initProfiles() {
            for (let i = 0; i < 24; i++) {
                profiles.solar[i] = getInitialSolarFactor(i);
                profiles.wind[i] = getInitialWindFactor(i);
                profiles.load[i] = getInitialLoadFactor(i);
            }
            // Deep copy for temp storage
            tempProfiles = JSON.parse(JSON.stringify(profiles));
        }

        function updateStatusText(hour) {
            const simStatus = document.getElementById('simStatus');

            // Calculate Net Load for status context
            const solar = profiles.solar[hour];
            const wind = profiles.wind[hour];
            const load = profiles.load[hour];
            const netLoad = Math.max(0, load - (solar * 0.5) - (wind * 0.1)); // Proxy

            if (solar > 0.6) {
                simStatus.textContent = "Mid-Day: High Solar output displacing fossil fuels.";
            } else if (load > 0.7 && solar < 0.3) {
                simStatus.textContent = "Peak Demand: Solar fading, Peakers ramping up hard.";
            } else if (load < 0.4) {
                simStatus.textContent = "Off-Peak: Low demand, wind & baseload serving grid.";
            } else {
                simStatus.textContent = "Normal Operations.";
            }
        }

        function setupProfileEditor() {
            const modal = document.getElementById('profile-editor-modal');
            const openBtn = document.getElementById('openProfileEditorBtn');
            const closeBtn = document.querySelector('.close-modal');
            const saveBtn = document.getElementById('saveProfilesBtn');
            const resetBtn = document.getElementById('resetProfilesBtn');
            const tabs = document.querySelectorAll('.tab-btn');

            // Open Modal
            openBtn.addEventListener('click', () => {
                // Reset temp profiles to current active profiles
                tempProfiles = JSON.parse(JSON.stringify(profiles));
                renderSliders(currentTab);
                modal.style.display = 'flex';
            });

            // Close Modal
            closeBtn.addEventListener('click', () => {
                modal.style.display = 'none';
            });

            // Close on outside click
            window.addEventListener('click', (e) => {
                if (e.target == modal) {
                    modal.style.display = 'none';
                }
            });

            // Tab Switching
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Remove active class from all
                    tabs.forEach(t => t.classList.remove('active'));
                    // Add active to clicked
                    tab.classList.add('active');
                    // Update current tab
                    currentTab = tab.getAttribute('data-tab');
                    // Render sliders
                    renderSliders(currentTab);
                });
            });

            // Save Changes
            saveBtn.addEventListener('click', () => {
                // Commit temp profiles to main profiles (update arrays, not reassign const)
                profiles.solar = [...tempProfiles.solar];
                profiles.wind = [...tempProfiles.wind];
                profiles.load = [...tempProfiles.load];

                // Close the modal
                modal.style.display = 'none';

                // Update simulation immediately with new profile data
                const hour = parseInt(document.getElementById('timeSlider').value);
                updateStatusText(hour);
                updateSimulation(hour);
                console.log('Profiles updated:', profiles);
            });

            // Reset Defaults
            resetBtn.addEventListener('click', () => {
                initProfiles(); // Re-run init math
                tempProfiles = JSON.parse(JSON.stringify(profiles));
                renderSliders(currentTab); // Re-render
            });
        }

        function renderSliders(type) {
            const container = document.getElementById('sliders-wrapper');
            const labelContainer = document.getElementById('profile-label-container');
            container.innerHTML = ''; // Clear existing

            const data = tempProfiles[type];

            // Determine color and label
            let barColor = '#888';
            let unitLabel = '';
            let capacityBase = 0; // MW

            if (type === 'solar') {
                barColor = '#FFD700';
                capacityBase = 26617; // Total Solar MW
                unitLabel = `Solar Output (% of ${capacityBase.toLocaleString()} MW)`;
            }
            if (type === 'wind') {
                barColor = '#1E90FF';
                capacityBase = 12714; // Total Wind MW
                unitLabel = `Wind Output (% of ${capacityBase.toLocaleString()} MW)`;
            }
            if (type === 'load') {
                barColor = '#FF4500';
                capacityBase = 55000; // Assumed Peak Load
                unitLabel = `Gross System Demand (% of ${capacityBase.toLocaleString()} MW Peak)`;
            }

            labelContainer.textContent = unitLabel;

            for (let i = 0; i < 24; i++) {
                const group = document.createElement('div');
                group.className = 'hour-slider-group';

                const valPercent = Math.round(data[i] * 100);
                const valMW = Math.round(data[i] * capacityBase).toLocaleString();

                const slider = document.createElement('input');
                slider.type = 'range';
                slider.min = '0';
                slider.max = '100'; // Percent
                slider.value = valPercent;
                slider.className = 'vertical-slider';
                slider.dataset.hour = i;
                slider.title = `${valPercent}% (~${valMW} MW)`; // Tooltip with MW

                // Style accent color if supported (browser dependent)
                slider.style.accentColor = barColor;

                const label = document.createElement('div');
                label.className = 'hour-label';
                label.textContent = `${i}:00`;

                // Hover Label for Value
                const valDisplay = document.createElement('div');
                valDisplay.style.fontSize = '8px';
                valDisplay.style.color = '#888';
                valDisplay.style.textAlign = 'center';
                valDisplay.style.marginTop = '2px';
                valDisplay.textContent = `${valPercent}%`;

                // Event Listener to update temp data
                slider.addEventListener('input', function () {
                    const newVal = parseInt(this.value);
                    tempProfiles[type][i] = newVal / 100;
                    valDisplay.textContent = `${newVal}%`;
                    this.title = `${newVal}% (~${Math.round((newVal / 100) * capacityBase).toLocaleString()} MW)`;
                });

                group.appendChild(valDisplay); // Value on top
                group.appendChild(slider);
                group.appendChild(label);
                container.appendChild(group);
            }
        }

        function updateSimulation(hour) {
            if (!networkGraph.plants || networkGraph.plants.length === 0) return;

            // System Capacities (Derived from Data)
            const CAP_GAS = sysCap.GAS || 41685;
            const CAP_HYDRO = sysCap.HYDRO || 15997;
            const CAP_SOLAR = sysCap.SOLAR || 26617;
            const CAP_WIND = sysCap.WIND || 12714;
            const CAP_BASELOAD = sysCap.BASELOAD || 5100;
            const CAP_PEAK_LOAD = 55000; // Assumed System Peak

            // 1. Retrieve Factors from Profiles (0.0 to 1.0)
            const solarFactor = profiles.solar[hour];
            const windFactor = profiles.wind[hour];
            const loadFactor = profiles.load[hour];

            // 2. Calculate MW Real-time values
            const solarMW = solarFactor * CAP_SOLAR;
            const windMW = windFactor * CAP_WIND;
            const loadMW = loadFactor * CAP_PEAK_LOAD;
            const baseloadMW = CAP_BASELOAD; // Always on (simplified)

            // 3. Calculate Net Load (The demand left for dispatchable resources)
            // Net Load = Total Demand - Renewables - Baseload
            let netLoadMW = loadMW - solarMW - windMW - baseloadMW;

            // Ensure non-negative for calculation (though negative implies curtailment)
            if (netLoadMW < 0) netLoadMW = 0;

            // 4. Determine Dispatch Requirements
            const totalDispatchableCap = CAP_GAS + CAP_HYDRO;

            // Dispatch Fraction: What % of our dispatchable fleet do we need?
            // We add a 1.17x buffer to simulate CAISO reserve requirements (17% operating reserves)
            // making the grid look "busier" at high loads, responding to user feedback.
            let dispatchFraction = (netLoadMW / totalDispatchableCap) * 1.17;

            // Cap at 1.0 (100% on)
            if (dispatchFraction > 1.0) dispatchFraction = 1.0;
            if (dispatchFraction < 0) dispatchFraction = 0;


            // Debug log to console to verify logic if needed
            // console.log(`Hour ${hour}: Load ${Math.round(loadMW)}MW, Net ${Math.round(netLoadMW)}MW, Disp% ${(dispatchFraction*100).toFixed(1)}%`);

            activeGenerators = 0;

            networkGraph.plants.forEach(plant => {
                // Skip retired plants (capacity <= 0) or plants below capacity cutoff
                if (plant.capacity <= 0 || plant.capacity < minCapacity) {
                    plant.isOn = false;
                    // Ensure visual state is off (even if hidden)
                    updatePlantMarker(plant, false, '#808080');
                    return;
                }

                const fuelType = (plant.fuel || 'UNKNOWN').toUpperCase();
                let shouldBeOn = false;
                let customColor = null;

                const plantHash = plant.id.split('').reduce((a, b) => a + b.charCodeAt(0), 0);
                const randomVal = (plantHash % 100) / 100; // 0.0 to 1.0 deterministic random

                if (fuelType === 'SUN') {
                    // Solar Logic
                    if (solarFactor > 0.05) {
                        shouldBeOn = true;
                        customColor = interpolateColor('#808080', '#FFD700', solarFactor);
                    }

                } else if (['WND', 'WIND'].includes(fuelType)) {
                    // Wind Logic
                    if (randomVal < windFactor) shouldBeOn = true;

                } else if (['NG', 'GAS', 'OGW', 'OG', 'BIT', 'OIL', 'DFO'].includes(fuelType)) {
                    // Gas Logic: Dispatchable
                    // We use the dispatchFraction calculated in MW
                    // Shift hash slightly so Gas and Hydro don't turn on identically
                    const gasRandom = ((plantHash + 33) % 100) / 100;
                    if (gasRandom < dispatchFraction) shouldBeOn = true;

                } else if (['WAT', 'HYD'].includes(fuelType)) {
                    // Hydro Logic: Dispatchable
                    // Hydro often has slightly different logic (peaking), but for simplicity 
                    // and to ensure meeting demand, we use the same dispatch fraction
                    if (randomVal < dispatchFraction) shouldBeOn = true;

                } else if (['NUC', 'GEO', 'BIO', 'WH'].includes(fuelType)) {
                    // Baseload Logic (95% availability)
                    if ((plantHash % 100) > 5) shouldBeOn = true;

                } else if (['BAT', 'OTH'].includes(fuelType)) {
                    // Battery Logic
                    // Charge when Solar is high (> 50% capacity)
                    // Discharge when Dispatch Fraction is high (> 60% of gas fleet needed)

                    if (dispatchFraction > 0.6) {
                        // Discharge (Gold) - Peak Shaving
                        shouldBeOn = true;
                        customColor = '#FFD700';
                    } else if (solarFactor > 0.5) {
                        // Charge (Cyan) - Soaking up sun
                        shouldBeOn = true;
                        customColor = '#00FFFF';
                    }
                }

                // Update State
                plant.isOn = shouldBeOn;
                if (shouldBeOn) activeGenerators++;

                // Update Visuals
                const baseColor = getFuelColor(plant.fuel);
                const displayColor = customColor || baseColor;
                updatePlantMarker(plant, shouldBeOn, displayColor);
            });

            updateFlow();
        }

        function updatePlantMarker(plant, isOn, color) {
            if (!plant.marker) return;

            const fuelType = (plant.fuel || 'UNKNOWN').toUpperCase();
            const marker = plant.marker;

            if (isOn) {
                if (marker instanceof L.CircleMarker) {
                    marker.setStyle({ fillColor: color });
                } else {
                    const isLargeMarker = ['WND', 'WIND', 'BAT', 'OTH', 'NUC'].includes(fuelType);
                    const isWind = ['WND', 'WIND'].includes(fuelType);
                    const markerSize = isWind ? 18 : (isLargeMarker ? 16 : 12);
                    const markerAnchor = isWind ? 9 : (isLargeMarker ? 8 : 6);

                    // Check if charging battery to change shape/icon if needed?
                    // For now just changing color is enough

                    marker.setIcon(L.divIcon({
                        className: 'custom-div-icon',
                        html: getMarkerHTML(fuelType, color, 'large'),
                        iconSize: [markerSize, markerSize],
                        iconAnchor: [markerAnchor, markerAnchor]
                    }));
                }
            } else {
                // Turn OFF (Grey)
                const grey = '#808080';
                if (marker instanceof L.CircleMarker) {
                    marker.setStyle({ fillColor: grey });
                } else {
                    const isLargeMarker = ['WND', 'WIND', 'BAT', 'OTH', 'NUC'].includes(fuelType);
                    const isWind = ['WND', 'WIND'].includes(fuelType);
                    const markerSize = isWind ? 18 : (isLargeMarker ? 16 : 12);
                    const markerAnchor = isWind ? 9 : (isLargeMarker ? 8 : 6);
                    marker.setIcon(L.divIcon({
                        className: 'custom-div-icon',
                        html: getMarkerHTML(fuelType, grey, 'large'),
                        iconSize: [markerSize, markerSize],
                        iconAnchor: [markerAnchor, markerAnchor]
                    }));
                }
            }
        }

        // Initial Math Functions (used to populate arrays)
        function getInitialSolarFactor(hour) {
            if (hour < 6 || hour > 20) return 0;
            const peak = 13;
            const sigma = 2.5;
            return Math.exp(-Math.pow(hour - peak, 2) / (2 * Math.pow(sigma, 2)));
        }

        function getInitialWindFactor(hour) {
            return 0.5 + 0.3 * Math.cos((hour / 24) * 2 * Math.PI);
        }

        function getInitialLoadFactor(hour) {
            const morning = 0.4 * Math.exp(-Math.pow(hour - 10, 2) / 10);
            const evening = 0.6 * Math.exp(-Math.pow(hour - 19, 2) / 10);
            const base = 0.3;
            return Math.min(1.0, base + morning + evening);
        }

        // Color Interpolation (Hex to Hex)
        function interpolateColor(color1, color2, factor) {
            if (factor >= 1) return color2;
            if (factor <= 0) return color1;

            const r1 = parseInt(color1.substring(1, 3), 16);
            const g1 = parseInt(color1.substring(3, 5), 16);
            const b1 = parseInt(color1.substring(5, 7), 16);

            const r2 = parseInt(color2.substring(1, 3), 16);
            const g2 = parseInt(color2.substring(3, 5), 16);
            const b2 = parseInt(color2.substring(5, 7), 16);

            const r = Math.round(r1 + factor * (r2 - r1));
            const g = Math.round(g1 + factor * (g2 - g1));
            const b = Math.round(b1 + factor * (b2 - b1));

            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        // LMP Price Visualization Logic
        let lmpLayer = L.layerGroup();
        // Modes are determined by checking the DOM checkboxes directly

        function showLMPPrices() {
            // NOTE: Removed early return to allow re-rendering when time changes
            lmpLayer.clearLayers();

            const checkTotal = document.getElementById('lmp-total');
            const checkEnergy = document.getElementById('lmp-energy');
            const checkCongestion = document.getElementById('lmp-congestion');
            const checkLoss = document.getElementById('lmp-loss');
            const checkGHG = document.getElementById('lmp-ghg');

            const activeModes = [];
            if (checkTotal?.checked) activeModes.push('LMP_Total');
            if (checkEnergy?.checked) activeModes.push('LMP_Energy');
            if (checkCongestion?.checked) activeModes.push('LMP_Congestion');
            if (checkLoss?.checked) activeModes.push('LMP_Loss');
            if (checkGHG?.checked) activeModes.push('LMP_GHG');

            // If nothing checked, effective hide? Or just show nothing?
            if (activeModes.length === 0) {
                // hideLMPPrices(); // Maybe just show empty layer?
                // Let's keep layer but no markers
                console.log("No LMP modes selected.");
                return;
            }

            // Determine Hour Index (0-23)
            let currentHourIndex = 0;
            const useSliderTime = document.getElementById('timeBasedToggle')?.checked;

            if (useSliderTime) {
                // Use Slider Value
                const sliderVal = document.getElementById('timeSlider')?.value;
                currentHourIndex = parseInt(sliderVal) || 0;
            } else {
                // Use Real Time (PST)
                try {
                    const now = new Date();
                    const options = { timeZone: 'America/Los_Angeles', hour: 'numeric', hour12: false };
                    const formatter = new Intl.DateTimeFormat('en-US', options);
                    let h = parseInt(formatter.format(now));
                    if (isNaN(h)) h = 0;
                    currentHourIndex = h % 24;
                } catch (e) {
                    console.error("Error determining PST time", e);
                    currentHourIndex = new Date().getHours();
                }
            }

            const he = currentHourIndex + 1; // Hour Ending
            // console.log(`Displaying LMP Prices (${currentLMPMode}) for HE ${he}`); // Removed old log

            // Iterate over substations to create price markers
            networkGraph.substations.forEach(sub => {
                const props = sub.feature.properties;

                // Calculate Sum of Selected Components
                let combinedPrice = 0;
                let hasValidData = false;

                activeModes.forEach(mode => {
                    let val = null;
                    if (props[mode + '_24h'] && Array.isArray(props[mode + '_24h'])) {
                        val = props[mode + '_24h'][currentHourIndex];
                    } else if (!useSliderTime) {
                        // Fallback to scalar
                        val = props[mode];
                    }

                    if (val !== null && val !== undefined) {
                        combinedPrice += val;
                        hasValidData = true;
                    }
                });

                if (hasValidData) {
                    // Determine Color Scale
                    // If only one mode is selected, use its specific scale.
                    // If multiple, use default price scale (unless all are typically small?)
                    // For safety, if sum is large, use price scale.

                    let scaleMode = 'LMP_Total';
                    if (activeModes.length === 1) {
                        scaleMode = activeModes[0];
                    } else if (activeModes.length > 1) {
                        scaleMode = 'Combined'; // Indicate combined mode for color function
                    }


                    const color = getLMPColor(combinedPrice, scaleMode);

                    const marker = L.circleMarker(sub.latlng, {
                        radius: 5,
                        fillColor: color,
                        color: '#000',
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.9
                    });

                    // Build tooltip
                    let tooltipContent = `<strong>${sub.name}</strong><br>`;
                    tooltipContent += `<small>Hour Ending ${he} (DAM Settled)</small><br>`;

                    const fmt = (v) => (v !== null && v !== undefined) ? `$${v.toFixed(2)}` : 'N/A';

                    // Show Combined Price if multiple or explicit
                    if (activeModes.length > 1) {
                        tooltipContent += `<b>Combined Price: ${fmt(combinedPrice)}</b><br>`;
                        tooltipContent += `<small style="color:#666">(${activeModes.map(m => m.replace('LMP_', '')).join(' + ')})</small><br>`;
                    } else {
                        tooltipContent += `<b>${activeModes[0].replace('LMP_', '')}: ${fmt(combinedPrice)}</b><br>`;
                    }

                    tooltipContent += `<hr style="margin:4px 0">`;

                    // Always show full breakdown for context
                    const getVal = (key) => {
                        if (props[key + '_24h'] && Array.isArray(props[key + '_24h'])) return props[key + '_24h'][currentHourIndex];
                        return props[key];
                    };

                    tooltipContent += `Total: ${fmt(getVal('LMP_Total'))}<br>`;
                    tooltipContent += `Energy: ${fmt(getVal('LMP_Energy'))}<br>`;
                    tooltipContent += `Congestion: ${fmt(getVal('LMP_Congestion'))}<br>`;
                    tooltipContent += `Loss: ${fmt(getVal('LMP_Loss'))}<br>`;
                    tooltipContent += `GHG: ${fmt(getVal('LMP_GHG'))}`;

                    marker.bindTooltip(tooltipContent, { direction: 'top' });

                    lmpLayer.addLayer(marker);
                }
            });

            if (!map.hasLayer(lmpLayer)) {
                lmpLayer.addTo(map);
            }
        }

        function getModeLabel(mode) {
            // This function is no longer used with the new tooltip logic
            switch (mode) {
                case 'LMP_Total': return 'Total LMP';
                case 'LMP_Energy': return 'Energy';
                case 'LMP_Congestion': return 'Congestion';
                case 'LMP_Loss': return 'Loss';
                case 'LMP_GHG': return 'GHG';
                default: return 'Price';
            }
        }

        function hideLMPPrices() {
            if (map.hasLayer(lmpLayer)) {
                map.removeLayer(lmpLayer);
                const btn = document.getElementById('lmp-trigger');
                if (btn) btn.classList.remove('active');
            }
            // Also hide list
            document.getElementById('lmp-list').classList.remove('show');
        }

        function setupLMPToggle() {
            const btn = document.getElementById('lmp-trigger');
            const list = document.getElementById('lmp-list');
            if (!btn || !list) return;

            // Toggle Menu
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                list.classList.toggle('show');

                // If opening menu and nothing is showing, turn on?
                if (list.classList.contains('show') && !map.hasLayer(lmpLayer)) {
                    showLMPPrices();
                    btn.classList.add('active');
                }
            });

            // Handle Checkbox Changes
            const inputs = list.querySelectorAll('input[type="checkbox"]');
            inputs.forEach(input => {
                input.addEventListener('change', (e) => {
                    // Exclusive Logic
                    if (input.id === 'lmp-total' && input.checked) {
                        // Uncheck others
                        inputs.forEach(i => {
                            if (i.id !== 'lmp-total') i.checked = false;
                        });
                    } else if (input.checked) {
                        // If any other component checked, uncheck Total
                        const total = document.getElementById('lmp-total');
                        if (total) total.checked = false;
                    }

                    // Re-render
                    if (map.hasLayer(lmpLayer)) {
                        showLMPPrices();
                    } else {
                        // If layer is hidden but user checks something, assume they want to see it?
                        if (input.checked) {
                            showLMPPrices();
                            btn.classList.add('active');
                        }
                    }
                });

                // Prevent menu highlight click from toggling checkbox twice (if clicking label/row)
                // The label handles click for input. Row click might be issue if logic added to row.
                // Current structure: input inside div. Label for input.
                // We don't need row click listener if label works.
                // But let's stop propagation on input to be safe.
                input.addEventListener('click', (e) => e.stopPropagation());
            });

            // Prevent div click from closing menu (bubble up)
            list.addEventListener('click', (e) => e.stopPropagation());

            // Handle "Hide Layer"
            const hideBtn = document.getElementById('lmp-turn-off');
            if (hideBtn) {
                hideBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    hideLMPPrices();
                });
            }

            // Close list when clicking outside
            window.addEventListener('click', (e) => {
                if (!list.contains(e.target) && !btn.contains(e.target)) {
                    list.classList.remove('show');
                }
            });

            // Slider & Toggle Integration (Existing)
            const timeSlider = document.getElementById('timeSlider');
            const timeToggle = document.getElementById('timeBasedToggle');

            if (timeSlider) {
                timeSlider.addEventListener('input', () => {
                    if (map.hasLayer(lmpLayer) && timeToggle?.checked) showLMPPrices();
                });
            }
            if (timeToggle) {
                timeToggle.addEventListener('change', () => {
                    if (map.hasLayer(lmpLayer)) showLMPPrices();
                });
            }
        }

        function getLMPColor(price, mode = 'LMP_Total') {
            // Standard Price Scale (Total, Energy, or High Combined)
            if (mode === 'LMP_GHG') {
                // Usually small positive or zero
                // User requested WHITE for GHG as they are all 0
                return '#FFFFFF';
            }

            // Diverging Gradient for Components (Blue -> White -> Red)
            if (mode === 'LMP_Congestion' || mode === 'LMP_Loss' || mode === 'Combined') {
                // Baseline 0 = White (#FFFFFF)
                // Positive = Red (#F44336)
                // Negative = Blue (#2196F3)

                // Define range roughly
                let max = 15; // Max cost -> Red
                let min = -15; // Max credit -> Blue

                // For Total/Combined, prices are usually ~30. So this scale would be all red.
                // We need adaptive scaling.
                // If Combined and > 20, use Standard price scale?
                // User asked for "Gradient... for Congestion and Loss".

                if (mode === 'LMP_Congestion') {
                    // Congestion usually 0-20. 
                    // 0 -> White.
                    // 15 -> Red.
                    // -5 -> Blue (rare)
                    if (price === 0) return '#FFFFFF';
                    if (price > 0) return interpolateColor('#FFFFFF', '#F44336', Math.min(1, price / 15));
                    return interpolateColor('#FFFFFF', '#2196F3', Math.min(1, Math.abs(price) / 5));
                }

                if (mode === 'LMP_Loss') {
                    // Loss usually -5 to +5
                    if (price === 0) return '#FFFFFF';
                    if (price > 0) return interpolateColor('#FFFFFF', '#F44336', Math.min(1, price / 5));
                    return interpolateColor('#FFFFFF', '#2196F3', Math.min(1, Math.abs(price) / 5));
                }

                // Fallback for Combined if dominated by components
                // If value is small (< 10), use gradient?
                if (Math.abs(price) < 15) {
                    if (price >= 0) return interpolateColor('#FFFFFF', '#F44336', Math.min(1, price / 15));
                    return interpolateColor('#FFFFFF', '#2196F3', Math.min(1, Math.abs(price) / 15));
                }
            }

            // Standard Price Scale (Total, Energy, or High Combined)
            // < $30 green, $30-60 yellow, > $60 red
            if (price < 30) return '#4CAF50';
            if (price < 45) return '#8BC34A';
            if (price < 60) return '#FFEB3B';
            if (price < 80) return '#FF9800';
            return '#F44336';
        }
    </script>
</body>

</html>
```
