<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Planning Simulator | Dr. Eshan Singh</title>
    <link rel="icon" type="image/png" href="/assets/favicon.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-plugin-dragdata@2.2.1/dist/chartjs-plugin-dragdata.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Lora:wght@400;500;700&display=swap"
        rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #fcfcfc;
            color: #1f2937;
        }

        .font-lora {
            font-family: 'Lora', serif;
        }

        .glass-card {
            background-color: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 1rem;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
        }

        .mesh-gradient-container {
            position: relative;
            z-index: 1;
        }

        .mesh-gradient-1 {
            background-image: radial-gradient(at 40% 20%, hsla(28, 100%, 74%, 1) 0px, transparent 50%),
                radial-gradient(at 80% 20%, hsla(189, 100%, 56%, 1) 0px, transparent 50%),
                radial-gradient(at 0% 50%, hsla(355, 100%, 93%, 1) 0px, transparent 50%),
                radial-gradient(at 80% 50%, hsla(340, 100%, 76%, 1) 0px, transparent 50%),
                radial-gradient(at 0% 100%, hsla(22, 100%, 77%, 1) 0px, transparent 50%),
                radial-gradient(at 80% 100%, hsla(242, 100%, 70%, 1) 0px, transparent 50%);
            background-size: 100% 100%;
            filter: blur(25px) saturate(1.2);
            opacity: 0.15;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: -1;
            animation: pulse-bg 15s infinite alternate;
        }

        .tutorial-active .mesh-gradient-1 {
            animation: none !important;
        }

        .form-input {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 0.5rem;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 9999px;
            outline: none;
            border: 1px solid #e5e7eb;
            transition: background .2s;
        }

        .form-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 1.25rem;
            height: 1.25rem;
            background: #2563eb;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .form-input::-moz-range-thumb {
            width: 1.25rem;
            height: 1.25rem;
            background: #2563eb;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .mix-slider-track {
            background-color: #e5e7eb;
            border-radius: 9999px;
            height: 0.75rem;
            width: 100%;
            overflow: hidden;
            position: relative;
        }

        .mix-slider-fill {
            height: 100%;
            border-radius: 9999px;
            transition: width 0.2s ease-in-out;
        }

        .mix-slider-default-outline {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            border: 1px solid black;
            border-radius: 9999px;
            box-sizing: border-box;
            background: transparent;
        }

        .value-input {
            width: 6rem;
            /* Adjust width as needed */
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            border: 1px solid #d1d5db;
            text-align: right;
            background-color: rgba(255, 255, 255, 0.8);
        }

        /* Color-coded slider thumbs */
        .thumb-solar::-webkit-slider-thumb {
            background-color: rgba(251, 191, 36, 1);
        }

        .thumb-solar::-moz-range-thumb {
            background-color: rgba(251, 191, 36, 1);
        }

        .thumb-wind::-webkit-slider-thumb {
            background-color: rgba(52, 211, 153, 1);
        }

        /* Lighter green */
        .thumb-wind::-moz-range-thumb {
            background-color: rgba(52, 211, 153, 1);
        }

        /* Lighter green */
        .thumb-offshoreWind::-webkit-slider-thumb {
            background-color: rgba(12, 148, 103, 1);
        }

        .thumb-offshoreWind::-moz-range-thumb {
            background-color: rgba(12, 148, 103, 1);
        }

        .thumb-geothermal::-webkit-slider-thumb {
            background-color: rgba(120, 40, 40, 1);
        }

        .thumb-geothermal::-moz-range-thumb {
            background-color: rgba(120, 40, 40, 1);
        }

        .thumb-nuclear::-webkit-slider-thumb {
            background-color: rgba(239, 68, 68, 1);
        }

        .thumb-nuclear::-moz-range-thumb {
            background-color: rgba(239, 68, 68, 1);
        }

        .thumb-storage::-webkit-slider-thumb {
            background-color: rgba(168, 85, 247, 1);
        }

        .thumb-storage::-moz-range-thumb {
            background-color: rgba(168, 85, 247, 1);
        }

        .thumb-neutral::-webkit-slider-thumb {
            background-color: rgba(107, 114, 128, 1);
        }

        .thumb-neutral::-moz-range-thumb {
            background-color: rgba(107, 114, 128, 1);
        }

        .thumb-biomass::-webkit-slider-thumb {
            background-color: rgba(101, 67, 33, 1);
        }

        /* Brown color for biomass */
        .thumb-biomass::-moz-range-thumb {
            background-color: rgba(101, 67, 33, 1);
        }

        .thumb-rng::-webkit-slider-thumb {
            background-color: rgba(132, 204, 22, 1);
        }

        /* Lime green for RNG */
        .thumb-rng::-moz-range-thumb {
            background-color: rgba(132, 204, 22, 1);
        }

        .thumb-hydrogen::-webkit-slider-thumb {
            background-color: rgba(219, 39, 119, 1);
        }

        /* Pink/magenta for hydrogen */
        .thumb-hydrogen::-moz-range-thumb {
            background-color: rgba(219, 39, 119, 1);
        }

        /* Rainbow Border Animation */
        @keyframes rainbow-border {
            0% {
                background-position: 0% 50%;
            }

            100% {
                background-position: 200% 50%;
            }
        }

        .rainbow-glow {
            position: relative;
            background: linear-gradient(90deg, #ff0080, #ff8000, #ffff00, #80ff00, #00ff80, #0080ff, #8000ff, #ff0080);
            background-size: 200% 200%;
            animation: rainbow-border 2s linear infinite;
            padding: 2px;
            border-radius: 9999px;
        }

        .rainbow-glow .button-content {
            background: #f3f4f6;
            border-radius: 9999px;
            padding: 0.5rem 1rem;
            display: block;
            color: #374151;
            font-size: 0.875rem;
            font-weight: 500;
            transition: background-color 0.3s;
        }

        .rainbow-glow:hover .button-content {
            background: #e5e7eb;
        }

        /* Style for active season preset button */
        .preset-active {
            background-color: #4b5563 !important;
            /* A darker gray */
            color: #ffffff !important;
        }

        /* --- TUTORIAL STYLES --- */
        #tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 9998;
            display: none;
            /* Controlled by JS */
        }

        #tutorial-popover {
            position: fixed;
            background-color: white;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            z-index: 10001;
            width: 320px;
            max-width: 90vw;
            display: none;
            transition: top 0.3s ease-in-out, left 0.3s ease-in-out, transform 0.3s ease-in-out;
        }

        .tutorial-highlight-active {
            position: relative;
            z-index: 9999;
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.7),
                0 0 20px 10px rgba(59, 130, 246, 0.4),
                0 0 0 9999px rgba(0, 0, 0, 0.6);
            transition: box-shadow 0.3s ease-in-out;
        }

        .tutorial-highlight-active.rounded-full {
            border-radius: 9999px;
        }

        .tutorial-highlight-active.rounded-lg {
            border-radius: 1rem;
        }

        /* --- TAB STYLES --- */
        .tab-button {
            color: #6B7280;
            cursor: pointer;
        }

        .tab-button:hover {
            background-color: #F3F4F6;
        }

        .tab-button.tab-active {
            background-color: #3B82F6;
            color: white;
        }

        .tab-content {
            animation: fadeIn 0.3s ease-in;
        }

        .tab-content.hidden {
            display: none;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* --- OPTIMIZATION RESULTS STYLES --- */
        .optimization-results {
            animation: slideIn 0.4s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .metric-card {
            padding: 1rem;
            background-color: #F9FAFB;
            border-radius: 0.5rem;
        }

        .capacity-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem;
            background-color: #F3F4F6;
            border-radius: 0.375rem;
            margin-bottom: 0.5rem;
        }

        .capacity-item:hover {
            background-color: #E5E7EB;
        }

        /* --- BUTTON STYLES --- */
        .btn {
            display: inline-block;
            padding: 0.5rem 1rem;
            font-weight: 500;
            border-radius: 0.375rem;
            transition: all 0.2s;
            cursor: pointer;
            border: none;
        }

        .btn-success {
            background-color: #10B981;
            color: white;
        }

        .btn-success:hover {
            background-color: #059669;
        }

        .btn-secondary {
            background-color: #6B7280;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #4B5563;
        }

        /* --- NOTIFICATION STYLES --- */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #10B981;
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            z-index: 10000;
            animation: notificationSlide 0.3s ease-out;
        }

        @keyframes notificationSlide {
            from {
                transform: translateX(400px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>

<body class="antialiased">
    <!-- Custom Confirmation Modal -->
    <div id="confirmation-modal" class="hidden fixed inset-0 z-50 overflow-y-auto">
        <!-- Backdrop -->
        <div class="fixed inset-0 bg-black bg-opacity-50 transition-opacity"></div>

        <!-- Modal Content -->
        <div class="flex items-center justify-center min-h-screen p-4">
            <div class="relative bg-white rounded-lg shadow-xl max-w-md w-full p-6 transform transition-all">
                <!-- Icon -->
                <div class="flex items-center justify-center w-12 h-12 mx-auto mb-4 bg-orange-100 rounded-full">
                    <svg class="w-6 h-6 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                    </svg>
                </div>

                <!-- Title -->
                <h3 class="text-lg font-semibold text-gray-900 text-center mb-2">Re-run Optimization?</h3>

                <!-- Message -->
                <p class="text-sm text-gray-600 text-center mb-6" id="confirmation-modal-message">
                    This will modify the baseline capacity assumptions and re-run the optimization. Proceed?
                </p>

                <!-- Buttons -->
                <div class="flex gap-3">
                    <button id="confirmation-modal-cancel"
                            class="flex-1 px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium rounded-lg transition-colors">
                        Cancel
                    </button>
                    <button id="confirmation-modal-ok"
                            class="flex-1 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg transition-colors">
                        OK
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Tooltip element -->
    <div id="hover-tooltip"
        class="absolute hidden bg-gray-800 text-white text-sm rounded-md px-2 py-1 z-50 pointer-events-none shadow-lg">
    </div>

    <!-- TUTORIAL HTML -->
    <div id="tutorial-overlay"></div>
    <div id="tutorial-popover">
        <h3 id="tutorial-title" class="text-xl font-lora font-bold mb-2 text-gray-800"></h3>
        <p id="tutorial-text" class="text-gray-600 mb-4"></p>
        <div class="flex justify-between items-center">
            <button id="tutorial-skip" class="text-sm text-gray-500 hover:text-gray-800">Skip Tour</button>
            <div>
                <button id="tutorial-prev"
                    class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-200 rounded-md hover:bg-gray-300 mr-2">Prev</button>
                <button id="tutorial-next"
                    class="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700">Next</button>
            </div>
        </div>
    </div>

    <div class="mesh-gradient-container">
        <div class="mesh-gradient-1"></div>

        <header class="p-8">
            <div class="container mx-auto flex justify-between items-center">
                <div class="flex flex-col">
                    <a href="/" class="font-lora text-2xl font-semibold">Dr. Eshan Singh</a>
                    <div class="text-sm text-gray-500 mt-1">
                        <span>Views: </span><span id="visitor-count">Loading...</span>
                    </div>
                </div>
                <nav class="flex items-center space-x-2">
                    <a href="/energy.html"
                        class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-full hover:bg-gray-200 transition-colors">Articles</a>
                    <a href="/transport-model/index.html" class="rainbow-glow">
                        <span class="button-content">Transport Model</span>
                    </a>
                    <a href="/grid-planner/index.html" class="rainbow-glow">
                        <span class="button-content">Grid Planner</span>
                    </a>
                    <a href="/grid-operator/index.html" class="rainbow-glow">
                        <span class="button-content">Grid Operator</span>
                    </a>
                    <a href="https://www.eshansingh.xyz/transmission/index.html" class="rainbow-glow">
                        <span class="button-content">CA Grid Map</span>
                    </a>
                    <a href="/musings.html"
                        class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-full hover:bg-gray-200 transition-colors">Musings</a>
                </nav>
            </div>
        </header>

        <div class="container mx-auto p-4 md:p-8 pt-0">

            <section id="tutorial-step-1" class="text-center mb-12">
                <h1 class="font-lora text-5xl md:text-6xl font-medium leading-tight text-gray-900">Grid Planning
                    Simulator</h1>
                <p class="mt-4 text-lg text-gray-600 max-w-3xl mx-auto">
                    Your challenge: Use policy levers for clean energy and direct air capture to eliminate CO2 emissions
                    from the electricity grid, while minimizing the impact on customer bill.
                </p>
                <div class="flex justify-center items-center space-x-4 mt-4">
                    <a href="grid-model-documentation.html"
                        class="inline-flex items-center px-4 py-2 bg-blue-100 text-blue-700 rounded-full hover:bg-blue-200 transition-colors text-sm font-medium">
                        ðŸ“– View Documentation
                    </a>
                    <button id="start-tutorial-btn"
                        class="inline-flex items-center px-4 py-2 bg-green-100 text-green-700 rounded-full hover:bg-green-200 transition-colors text-sm font-medium">
                        ðŸš€ Show Tutorial
                    </button>
                </div>
                <p class="mt-4 text-sm text-gray-600">
                    Send your queries at <a href="mailto:hello@eshansingh.xyz"
                        class="text-blue-600 hover:underline">hello@eshansingh.xyz</a>
                </p>
            </section>

            <!-- TAB NAVIGATION -->
            <div class="flex justify-center mb-8">
                <div class="inline-flex rounded-lg border border-gray-200 bg-white p-1 shadow-sm">
                    <button id="tab-manual"
                        class="tab-button tab-active px-6 py-2 rounded-md text-sm font-medium transition-colors">
                        Manual Mode
                    </button>
                    <button id="tab-optimize"
                        class="tab-button px-6 py-2 rounded-md text-sm font-medium transition-colors">
                        Optimize Mode
                    </button>
                </div>
            </div>

            <!-- MANUAL MODE TAB CONTENT -->
            <div id="manual-mode-content" class="tab-content">
                <!-- Full Width Charts Section - LOAD GENERATION, PRICE, CO2 -->
                <div class="space-y-8 mb-8">
                    <!-- Load Generation Chart -->
                    <div class="glass-card rounded-lg w-full">
                        <div class="mb-4 relative">
                            <div class="flex justify-between items-center mb-4">
                                <h2 class="text-2xl font-lora font-semibold text-gray-800">All Year - Hourly Electricity
                                    Generation (GWh)</h2>
                            </div>
                            <canvas id="generationMixChart" height="100"></canvas>
                        </div>
                    </div>

                    <!-- Marginal Price Chart -->
                    <div class="glass-card rounded-lg w-full">
                        <h2 class="text-2xl font-lora font-semibold mb-4 text-gray-800">All Year - Hourly Marginal Price
                            ($/MWh)</h2>
                        <canvas id="marginalPriceChart" height="100"></canvas>
                    </div>

                    <!-- Monthly CO2 Emissions Bar Chart -->
                    <div class="glass-card rounded-lg w-full">
                        <h2 class="text-2xl font-lora font-semibold mb-4 text-gray-800">Monthly Total CO2 Emissions
                            (Metric
                            Tons)</h2>
                        <canvas id="co2EmissionsChart" height="100"></canvas>
                    </div>
                </div>

                <!-- Row 1: Installed Capacity Mix | Generation Mix (Full Width) -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                    <!-- Installed Capacity Mix -->
                    <div id="tutorial-step-4" class="glass-card rounded-lg">
                        <h2 class="text-2xl font-lora font-semibold mb-4 text-gray-800">Installed Capacity Mix (%)</h2>
                        <div id="grid-mix-sliders" class="space-y-3">
                            <!-- Sliders will be dynamically inserted here -->
                        </div>
                        <!-- NEW: Container for storage capacity display -->
                        <div id="storage-capacity-display" class="mt-6"></div>
                    </div>

                    <!-- Generation Mix -->
                    <div class="glass-card rounded-lg">
                        <h2 class="text-2xl font-lora font-semibold mb-4 text-gray-800">Yearly Generation Mix (%)</h2>
                        <div id="generation-mix-sliders" class="space-y-3">
                            <!-- New chart sliders will be dynamically inserted here -->
                        </div>
                    </div>
                </div>

                <!-- Row 2: Policy Levers | (Metrics + Government Incentives) -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                    <!-- Left: Policy Levers -->
                    <div id="tutorial-step-3" class="glass-card space-y-6 rounded-lg">
                        <div class="mb-6">
                            <label for="country-select" class="block text-md font-medium text-gray-700 mb-2">Select
                                Default Grid Mix</label>
                            <select id="country-select"
                                class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 bg-white">
                                <!-- Options will be populated by JS -->
                            </select>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <div class="flex items-center justify-around">
                                <button id="undo-button"
                                    class="p-2 text-sm font-medium text-gray-700 bg-gray-200 rounded-full hover:bg-gray-300 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                                    title="Undo" disabled>
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                        fill="currentColor">
                                        <path fill-rule="evenodd"
                                            d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"
                                            clip-rule="evenodd" />
                                    </svg>
                                </button>
                                <button id="redo-button"
                                    class="p-2 text-sm font-medium text-gray-700 bg-gray-200 rounded-full hover:bg-gray-300 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                                    title="Redo" disabled>
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                        fill="currentColor">
                                        <path fill-rule="evenodd"
                                            d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"
                                            clip-rule="evenodd" />
                                    </svg>
                                </button>
                            </div>
                            <button id="make-default-button"
                                class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-200 rounded-full hover:bg-gray-300 transition-colors"
                                title="Set the current lever positions as your new default">Make Default</button>
                            <button id="reset-to-default-button"
                                class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-200 rounded-full hover:bg-gray-300 transition-colors"
                                title="Reset levers to the default for this grid mix">Reset to Default</button>
                            <button id="reset-to-zero-button"
                                class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-200 rounded-full hover:bg-gray-300 transition-colors"
                                title="Reset all policy and new capacity levers to zero">Reset to Zero</button>
                        </div>
                        <div>
                            <h2
                                class="text-2xl font-lora font-semibold mb-4 border-b border-t pt-4 border-gray-300 pb-4 text-gray-800">
                                Policy Levers</h2>
                            <div class="space-y-6 pt-4">
                                <!-- Levers -->
                                <div>
                                    <label for="solar-slider" class="block text-md font-medium text-gray-700">New Solar
                                        Capacity</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="solar-slider" min="0" max="200" step="0.01" value="0"
                                            class="w-full form-input thumb-solar">
                                        <input type="number" id="solar-input" min="0" max="200" step="0.01" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="solar-unit">GW</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="wind-slider" class="block text-md font-medium text-gray-700">New Onshore
                                        Wind Capacity</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="wind-slider" min="0" max="200" step="0.01" value="0"
                                            class="w-full form-input thumb-wind">
                                        <input type="number" id="wind-input" min="0" max="200" step="0.01" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="wind-unit">GW</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="offshoreWind-slider" class="block text-md font-medium text-gray-700">New
                                        Offshore Wind Capacity</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="offshoreWind-slider" min="0" max="200" step="0.01"
                                            value="0" class="w-full form-input thumb-offshoreWind">
                                        <input type="number" id="offshoreWind-input" min="0" max="200" step="0.01"
                                            value="0" class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="offshoreWind-unit">GW</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="geothermal-slider" class="block text-md font-medium text-gray-700">New
                                        Geothermal Capacity</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="geothermal-slider" min="0" max="50" step="0.01"
                                            value="0" class="w-full form-input thumb-geothermal">
                                        <input type="number" id="geothermal-input" min="0" max="50" step="0.01"
                                            value="0" class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="geothermal-unit">GW</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="nuclear-slider" class="block text-md font-medium text-gray-700">New
                                        Nuclear Capacity</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="nuclear-slider" min="0" max="50" step="0.01" value="0"
                                            class="w-full form-input thumb-nuclear">
                                        <input type="number" id="nuclear-input" min="0" max="50" step="0.01" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="nuclear-unit">GW</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="biomass-slider" class="block text-md font-medium text-gray-700">New
                                        Biomass Capacity</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="biomass-slider" min="0" max="50" step="1" value="0"
                                            class="w-full form-input thumb-biomass">
                                        <input type="number" id="biomass-input" min="0" max="50" step="1" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="biomass-unit">GW</span>
                                    </div>
                                </div>
                                <!-- NEW: RNG (Biogas) Slider -->
                                <div>
                                    <label for="rng-slider" class="block text-md font-medium text-gray-700">New RNG
                                        (Biogas) Capacity</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="rng-slider" min="0" max="50" step="1" value="0"
                                            class="w-full form-input thumb-rng">
                                        <input type="number" id="rng-input" min="0" max="50" step="1" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left" id="rng-unit">GW</span>
                                    </div>
                                </div>
                                <!-- NEW: Hydrogen Slider -->
                                <div>
                                    <label for="hydrogen-slider" class="block text-md font-medium text-gray-700">New
                                        Hydrogen Capacity</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="hydrogen-slider" min="0" max="50" step="1" value="0"
                                            class="w-full form-input thumb-hydrogen">
                                        <input type="number" id="hydrogen-input" min="0" max="50" step="1" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="hydrogen-unit">GW</span>
                                    </div>
                                </div>
                                <div class="border-t border-gray-300 pt-6">
                                    <label for="battery4hr-slider" class="block text-md font-medium text-gray-700">4-hr
                                        Battery Storage</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="battery4hr-slider" min="0" max="200" step="0.01"
                                            value="0" class="w-full form-input thumb-storage">
                                        <input type="number" id="battery4hr-input" min="0" max="200" step="0.01"
                                            value="0" class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="battery4hr-unit">GWh</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="battery8hr-slider" class="block text-md font-medium text-gray-700">8-hr
                                        Battery Storage</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="battery8hr-slider" min="0" max="200" step="0.01"
                                            value="0" class="w-full form-input thumb-storage">
                                        <input type="number" id="battery8hr-input" min="0" max="200" step="0.01"
                                            value="0" class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="battery8hr-unit">GWh</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="longduration-slider"
                                        class="block text-md font-medium text-gray-700">24-hr Long Duration
                                        Storage</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="longduration-slider" min="0" max="500" step="0.01"
                                            value="0" class="w-full form-input thumb-storage">
                                        <input type="number" id="longduration-input" min="0" max="500" step="0.01"
                                            value="0" class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="longduration-unit">GWh</span>
                                    </div>
                                </div>
                                <div class="border-t border-gray-300 pt-6">
                                    <label for="demandflex-slider"
                                        class="block text-md font-medium text-gray-700">Demand Flexibility</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="demandflex-slider" min="0" max="25" value="0"
                                            class="w-full form-input thumb-neutral">
                                        <input type="number" id="demandflex-input" min="0" max="25" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="demandflex-unit">%</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="dac-slider" class="block text-md font-medium text-gray-700">Direct Air
                                        Capture
                                        Deployment</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="dac-slider" min="0" max="10000" step="0.1" value="0"
                                            class="w-full form-input thumb-neutral">
                                        <input type="number" id="dac-input" min="0" max="10000" step="0.1" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="dac-unit">t/hr</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>


                    <!-- Right: Metrics + Government Incentives -->
                    <div class="space-y-8">
                        <div id="tutorial-step-5" class="glass-card rounded-lg sticky top-6 z-10">
                            <div class="grid grid-cols-2 gap-4 text-center">
                                <div
                                    title="Based on the average wholesale price of electricity&#10;Assuming natural gas plant on the margin drives the price">
                                    <h3 class="text-xl font-lora font-semibold text-gray-800">Marginal Price</h3>
                                    <p id="bill-impact" class="text-5xl font-bold text-blue-600 mt-2">0%</p>
                                </div>
                                <div title="Based on the total annualized cost to operate the grid">
                                    <h3 class="text-xl font-lora font-semibold text-gray-800">System Cost</h3>
                                    <p id="system-cost-impact" class="text-5xl font-bold text-blue-600 mt-2">0%</p>
                                </div>
                            </div>
                            <div class="text-center mt-2">
                                <p id="co2-avoided-text" class="text-md font-medium text-gray-700"></p>
                            </div>
                        </div>



                        <!-- Government Incentives Section -->
                        <div class="glass-card rounded-lg">
                            <h2
                                class="text-2xl font-lora font-semibold mb-4 border-b border-t border-gray-300 pt-4 pb-4 text-gray-800">
                                Government Incentives</h2>
                            <div class="space-y-6 pt-4">
                                <!-- Incentive levers -->
                                <div>
                                    <label for="carbon-tax-slider"
                                        class="block text-sm font-medium text-gray-700">Carbon Tax</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="carbon-tax-slider" min="0" max="200" value="0"
                                            class="w-full form-input thumb-neutral">
                                        <input type="number" id="carbon-tax-input" min="0" max="200" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="carbon-tax-unit">$/ton</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="export-price-slider"
                                        class="block text-sm font-medium text-gray-700">Export Price</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="export-price-slider" min="-100" max="100" value="-20"
                                            class="w-full form-input thumb-neutral">
                                        <input type="number" id="export-price-input" min="-100" max="100" value="-20"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="export-price-unit">$/MWh</span>
                                    </div>
                                </div>
                                <div class="border-t border-gray-300 pt-6">
                                    <label for="solar-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">Solar (PTC)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="solar-incentive-slider" min="0" max="50" value="0"
                                            class="w-full form-input thumb-solar">
                                        <input type="number" id="solar-incentive-input" min="0" max="50" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="solar-incentive-unit">$/MWh</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="wind-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">Onshore Wind (PTC)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="wind-incentive-slider" min="0" max="50" value="0"
                                            class="w-full form-input thumb-wind">
                                        <input type="number" id="wind-incentive-input" min="0" max="50" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="wind-incentive-unit">$/MWh</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="offshoreWind-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">Offshore Wind (PTC)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="offshoreWind-incentive-slider" min="0" max="50"
                                            value="0" class="w-full form-input thumb-offshoreWind">
                                        <input type="number" id="offshoreWind-incentive-input" min="0" max="50"
                                            value="0" class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="offshoreWind-incentive-unit">$/MWh</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="geothermal-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">Geothermal (PTC)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="geothermal-incentive-slider" min="0" max="50" value="0"
                                            class="w-full form-input thumb-geothermal">
                                        <input type="number" id="geothermal-incentive-input" min="0" max="50" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="geothermal-incentive-unit">$/MWh</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="nuclear-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">Nuclear (PTC)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="nuclear-incentive-slider" min="0" max="50" value="0"
                                            class="w-full form-input thumb-nuclear">
                                        <input type="number" id="nuclear-incentive-input" min="0" max="50" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="nuclear-incentive-unit">$/MWh</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="biomass-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">Biomass (PTC)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="biomass-incentive-slider" min="0" max="50" value="0"
                                            class="w-full form-input thumb-biomass">
                                        <input type="number" id="biomass-incentive-input" min="0" max="50" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="biomass-incentive-unit">$/MWh</span>
                                    </div>
                                </div>
                                <!-- NEW: RNG (Biogas) Incentive Slider -->
                                <div>
                                    <label for="rng-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">RNG (Biogas) (PTC)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="rng-incentive-slider" min="0" max="50" value="0"
                                            class="w-full form-input thumb-rng">
                                        <input type="number" id="rng-incentive-input" min="0" max="50" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="rng-incentive-unit">$/MWh</span>
                                    </div>
                                </div>
                                <!-- NEW: Hydrogen Incentive Slider -->
                                <div>
                                    <label for="hydrogen-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">Hydrogen (PTC)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="hydrogen-incentive-slider" min="0" max="50" value="0"
                                            class="w-full form-input thumb-hydrogen">
                                        <input type="number" id="hydrogen-incentive-input" min="0" max="50" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="hydrogen-incentive-unit">$/MWh</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="storage-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">Storage (ITC)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="storage-incentive-slider" min="0" max="100" value="0"
                                            class="w-full form-input thumb-storage">
                                        <input type="number" id="storage-incentive-input" min="0" max="100" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="storage-incentive-unit">$/kWh</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="dac-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">Direct Air Capture (45Q)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="dac-incentive-slider" min="0" max="200" value="0"
                                            class="w-full form-input thumb-neutral">
                                        <input type="number" id="dac-incentive-input" min="0" max="200" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="dac-incentive-unit">$/ton</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>


                <!-- Hourly Capacity Factors Chart -->
                <div class="grid grid-cols-1 gap-8 mb-8">
                    <div id="tutorial-step-2" class="glass-card rounded-lg w-full">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-2xl font-lora font-semibold text-gray-800">Hourly Capacity Factors</h2>
                            <div class="flex items-center space-x-2">
                                <div id="cf-edit-controls" class="flex items-center space-x-1">
                                    <button id="edit-cf-btn" class="p-2 rounded-full hover:bg-gray-200"
                                        title="Edit capacity factor profiles">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                            fill="currentColor">
                                            <path
                                                d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" />
                                            <path fill-rule="evenodd"
                                                d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z"
                                                clip-rule="evenodd" />
                                        </svg>
                                    </button>
                                    <button id="revert-cf-btn" class="p-2 rounded-full hover:bg-gray-200 hidden"
                                        title="Revert to original capacity factor profiles">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-700"
                                            viewBox="0 0 20 20" fill="currentColor">
                                            <path fill-rule="evenodd"
                                                d="M7.707 3.293a1 1 0 010 1.414L5.414 7H11a7 7 0 017 7v2a1 1 0 11-2 0v-2a5 5 0 00-5-5H5.414l2.293 2.293a1 1 0 11-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"
                                                clip-rule="evenodd" />
                                        </svg>
                                    </button>
                                    <button id="confirm-cf-btn" class="p-2 rounded-full hover:bg-gray-200 hidden"
                                        title="Confirm changes to capacity factors">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-500"
                                            viewBox="0 0 20 20" fill="currentColor">
                                            <path fill-rule="evenodd"
                                                d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
                                                clip-rule="evenodd" />
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <canvas id="capacityFactorChart" height="100"></canvas>
                    </div>
                </div>

            </div>
        </div>
    </div>
    </div>
    </div>

    <!-- END MANUAL MODE CONTENT -->
    </div>

    <!-- OPTIMIZE MODE TAB CONTENT -->
    <div id="optimize-mode-content" class="tab-content hidden">
        <div class="max-w-4xl mx-auto">
            <div class="glass-card rounded-lg p-8">
                <h2 class="text-3xl font-lora font-semibold mb-2 text-gray-900">Capacity Expansion Optimization</h2>
                <p class="text-gray-600 mb-8">
                    Let the algorithm find the optimal mix of generation and storage capacity to meet your CO2 emissions
                    target at minimum cost.
                </p>

                <!-- Input Section -->
                <div class="space-y-6 mb-8">
                    <!-- CO2 Target Input -->
                    <div>
                        <label for="co2-target-input" class="block text-sm font-medium text-gray-700 mb-2">
                            CO2 Emissions Target (million metric tons/year)
                        </label>
                        <input type="number" id="co2-target-input" value="30.0" min="0" max="100" step="1"
                            class="w-full px-4 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                        <p class="mt-2 text-sm text-gray-500">
                            Current baseline: <span id="baseline-co2" class="font-semibold text-gray-700">38.09</span>
                            million MT
                        </p>
                    </div>

                    <!-- Options Checkboxes -->
                    <div class="space-y-3">
                        <label class="flex items-center">
                            <input type="checkbox" id="allow-dac" checked
                                class="mr-2 form-checkbox h-4 w-4 text-blue-600">
                            <span class="text-sm text-gray-700">
                                Allow Direct Air Capture (DAC) <span class="text-gray-500">- Enable CO2 removal
                                    technology if needed</span>
                            </span>
                        </label>

                        <label class="flex items-center">
                            <input type="checkbox" id="respect-curtailment" checked
                                class="mr-2 form-checkbox h-4 w-4 text-blue-600">
                            <span class="text-sm text-gray-700">
                                Limit curtailment to 20% <span class="text-gray-500">- Prevents excessive renewable
                                    overbuild</span>
                            </span>
                        </label>
                    </div>
                </div>

                <!-- Cost Assumptions Edit Section -->
                <div class="mb-6">
                    <button id="toggle-costs-btn"
                        class="text-blue-600 hover:text-blue-800 text-sm font-medium flex items-center focus:outline-none transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20"
                            fill="currentColor">
                            <path
                                d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" />
                        </svg>
                        Edit Cost & Performance Assumptions
                    </button>

                    <!-- Cost Assumptions Editor (Hidden) -->
                    <div id="cost-editor-container"
                        class="hidden mt-3 p-4 bg-gray-50 rounded-lg border border-gray-200 shadow-inner">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="font-semibold text-gray-800 text-sm">Technology Cost Assumptions</h3>
                            <button id="reset-costs-btn"
                                class="text-xs text-red-600 hover:text-red-800 border border-red-200 px-2 py-1 rounded bg-white hover:bg-red-50 transition-colors">
                                Reset to Defaults
                            </button>
                        </div>

                        <!-- Global Params -->
                        <div class="mb-4">
                            <label class="block text-xs font-medium text-gray-500 mb-1">Discount Rate (decimal)</label>
                            <input type="number" id="cost-discount-rate" step="0.01" min="0" max="0.2"
                                class="w-32 text-sm border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500">
                        </div>

                        <!-- Table -->
                        <div class="overflow-x-auto">
                            <table class="min-w-full text-xs text-left bg-white rounded border border-gray-200">
                                <thead>
                                    <tr class="bg-gray-100 border-b border-gray-200">
                                        <th class="px-3 py-2 font-medium text-gray-700">Technology</th>
                                        <th class="px-2 py-2 font-medium text-gray-700">CAPEX<br><span
                                                class="font-normal text-gray-400 text-[10px]">$/kW</span></th>
                                        <th class="px-2 py-2 font-medium text-gray-700">Fixed O&M<br><span
                                                class="font-normal text-gray-400 text-[10px]">$/kW-yr</span></th>
                                        <th class="px-2 py-2 font-medium text-gray-700">Var O&M<br><span
                                                class="font-normal text-gray-400 text-[10px]">$/MWh</span></th>
                                        <th class="px-2 py-2 font-medium text-gray-700">Life<br><span
                                                class="font-normal text-gray-400 text-[10px]">yrs</span></th>
                                    </tr>
                                </thead>
                                <tbody id="cost-table-body" class="divide-y divide-gray-200">
                                    <!-- Rows injected by JS -->
                                </tbody>
                            </table>
                        </div>
                        <p class="text-xs text-gray-500 mt-2 italic">* Storage CAPEX is $/kWh. DAC CAPEX is $/ton/yr. NG
                            Variable O&M shows start-end range implies ramp.</p>
                    </div>
                </div>

                <!-- Run Optimization Button -->
                <button id="run-optimization-btn"
                    class="w-full px-6 py-3 bg-blue-600 text-white font-medium rounded-lg hover:bg-blue-700 transition-colors shadow-md">
                    Find Optimal Solution
                </button>

                <!-- Progress Display -->
                <div id="optimization-progress" class="hidden mt-8">
                    <h3 class="font-semibold text-lg mb-3 text-gray-800">Optimization Progress</h3>

                    <!-- Progress Bar -->
                    <div class="w-full bg-gray-200 rounded-full h-3 mb-4 overflow-hidden">
                        <div id="progress-bar" class="bg-blue-600 h-3 rounded-full transition-all duration-300"
                            style="width: 0%"></div>
                    </div>

                    <!-- Stats Grid -->
                    <div class="grid grid-cols-3 gap-4 text-center">
                        <div class="bg-gray-50 rounded-lg p-3">
                            <p class="text-xs text-gray-600 mb-1">Iteration</p>
                            <p class="text-xl font-bold text-gray-900"><span id="iter-count">0</span> / <span id="max-iter">1000</span></p>
                        </div>
                        <div class="bg-gray-50 rounded-lg p-3">
                            <p class="text-xs text-gray-600 mb-1">Best Cost</p>
                            <p class="text-xl font-bold text-blue-600">$<span id="best-cost">--</span>B/yr</p>
                        </div>
                        <div class="bg-gray-50 rounded-lg p-3">
                            <p class="text-xs text-gray-600 mb-1">CO2 Level</p>
                            <p class="text-xl font-bold text-green-600"><span id="current-co2">--</span> MT</p>
                        </div>
                    </div>
                </div>

                <!-- Results Display Container -->
                <div id="optimization-results-container" class="mt-8">
                    <!-- Results will be inserted here via JavaScript -->
                </div>
            </div>
        </div>
    </div>
    <!-- END OPTIMIZE MODE CONTENT -->

    <!-- Copyright Footer -->
    <footer class="container mx-auto p-4 mt-12 text-center border-t border-gray-200">
        <p class="text-sm text-gray-600">
            Â© 2025 <a href="https://eshansingh.xyz" class="font-medium text-gray-800 hover:text-blue-600">Dr. Eshan
                Singh</a>. All rights reserved.
        </p>
        <p class="text-xs text-gray-500 mt-1">
            For licensing inquiries: <a href="mailto:hello@eshansingh.xyz"
                class="text-blue-600 hover:text-blue-700 underline">hello@eshansingh.xyz</a>
        </p>
    </footer>
    <script type="module">
        // --- FIREBASE IMPORTS ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, runTransaction, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- HARDCODED FIREBASE CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyCdEeu0VugTfZD-R-62pFvBdb313TeM4xs",
            authDomain: "grid-decarbonization.firebaseapp.com",
            projectId: "grid-decarbonization",
            storageBucket: "grid-decarbonization.appspot.com",
            messagingSenderId: "902419724670",
            appId: "1:902419724670:web:b636a75ea44325946a9b2f",
            measurementId: "G-3Q9HE19CGN"
        };

        // --- INITIALIZE FIREBASE & DEFINE KEY VARIABLES ---
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const appId = firebaseConfig.appId;

        // --- MODEL PARAMETERS & DATA (GLOBAL SCOPE) ---
        const MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        const HOURS = [];
        MONTHS.forEach(m => {
            Array.from({ length: 24 }, (_, i) => HOURS.push(`${m} ${i}:00`));
        });

        const countryGridMixData = {
            "California": {
                totalCapacityMW: 89223,
                peakLoadsMW: { summer: 52061, winter: 47500, fall: 46000, spring: 41000 },
                mix: { coal: 0.1, naturalGas: 43.4, hydro: 15.7, wind: 7.1, offshoreWind: 0, solar: 26.1, nuclear: 2.7, geothermal: 3.0, biomass: 1.0, rng: 0.4 },
                storageGWh: { battery4hr: 53.0 },
                defaultExportPrice: -20
            },
            "China": {
                totalCapacityMW: 3400000,
                peakLoadsMW: { summer: 1340000, winter: 1206000, fall: 1179200, spring: 1072000 },
                mix: { coal: 40.0, naturalGas: 8.0, hydro: 12.5, wind: 14.0, offshoreWind: 1.6, solar: 20.0, nuclear: 2.5, geothermal: 0.1, biomass: 0.9, rng: 0.4 },
                storageGWh: { battery4hr: 222 }
            },
            "United States": {
                totalCapacityMW: 1275000,
                peakLoadsMW: { summer: 800000, winter: 720000, fall: 704000, spring: 640000 },
                mix: { coal: 15.0, naturalGas: 48.0, hydro: 7.8, wind: 11.5, offshoreWind: 0.2, solar: 9.0, nuclear: 8.0, geothermal: 0.3, biomass: 0.8, rng: 0.4 },
                storageGWh: { battery4hr: 95 }
            },
            "India": {
                totalCapacityMW: 476000,
                peakLoadsMW: { summer: 243000, winter: 206550, fall: 213840, spring: 194400 },
                mix: { coal: 50.0, naturalGas: 6.0, hydro: 10.0, wind: 9.5, offshoreWind: 0, solar: 18.0, nuclear: 1.8, geothermal: 0.0, biomass: 1.9, rng: 0.8 },
                storageGWh: { battery4hr: 1 }
            },
            "Japan": {
                totalCapacityMW: 295000,
                peakLoadsMW: { summer: 181000, winter: 162900, fall: 159280, spring: 144800 },
                mix: { coal: 20.0, naturalGas: 35.0, hydro: 17.0, wind: 1.6, offshoreWind: 0.1, solar: 15.5, nuclear: 10.5, geothermal: 0.2, biomass: 1.1, rng: 0.5 },
                storageGWh: { battery4hr: 1.2 }
            },
            "Russia": {
                totalCapacityMW: 248000,
                peakLoadsMW: { winter: 160000, summer: 144000, fall: 140800, spring: 128000 },
                mix: { coal: 15.0, naturalGas: 52.0, hydro: 20.0, wind: 0.9, offshoreWind: 0, solar: 0.8, nuclear: 11.3, geothermal: 0.0, biomass: 0.1, rng: 0.1 }
            },
            "Brazil": {
                totalCapacityMW: 180000,
                peakLoadsMW: { summer: 101860, winter: 91674, fall: 89637, spring: 81488 },
                mix: { coal: 2.0, naturalGas: 18.0, hydro: 59.0, wind: 10.5, offshoreWind: 0, solar: 9.5, nuclear: 1.0, geothermal: 0.0, biomass: 5.6, rng: 2.4 }
            },
            "Germany": {
                totalCapacityMW: 210000,
                peakLoadsMW: { winter: 84000, summer: 75600, fall: 73920, spring: 67200 },
                mix: { coal: 14.0, naturalGas: 38.0, hydro: 4.0, wind: 22.0, offshoreWind: 4.0, solar: 12.0, nuclear: 5.0, geothermal: 0.0, biomass: 4.2, rng: 1.8 },
                storageGWh: { battery4hr: 22.1 }
            },
            "Canada": {
                totalCapacityMW: 165000,
                peakLoadsMW: { winter: 140000, summer: 126000, fall: 123200, spring: 112000 },
                mix: { coal: 4.5, naturalGas: 13.5, hydro: 57.0, wind: 8.5, offshoreWind: 0, solar: 2.5, nuclear: 14.0, geothermal: 0.0, biomass: 1.4, rng: 0.6 },
                storageGWh: { battery4hr: 1 }
            },
            "South Korea": {
                totalCapacityMW: 125000,
                peakLoadsMW: { summer: 93000, winter: 83700, fall: 81840, spring: 74400 },
                mix: { coal: 34.0, naturalGas: 20.0, hydro: 5.0, wind: 1.4, offshoreWind: 0.1, solar: 12.5, nuclear: 27.0, geothermal: 0.0, biomass: 0.7, rng: 0.3 },
                storageGWh: { battery4hr: 9 }
            },
            "France": {
                totalCapacityMW: 115000,
                peakLoadsMW: { winter: 102000, summer: 91800, fall: 89760, spring: 81600 },
                mix: { coal: 1.0, naturalGas: 10.0, hydro: 10.0, wind: 8.0, offshoreWind: 0.5, solar: 6.0, nuclear: 64.0, geothermal: 0.0, biomass: 0.3, rng: 0.1 },
                storageGWh: { battery4hr: 1.0 }
            },
            "United Kingdom": {
                totalCapacityMW: 78000,
                peakLoadsMW: { winter: 60000, summer: 54000, fall: 52800, spring: 48000 },
                mix: { coal: 1.0, naturalGas: 38.0, hydro: 2.0, wind: 15.0, offshoreWind: 14.0, solar: 19.0, nuclear: 9.0, geothermal: 0.0, biomass: 4.2, rng: 1.8 },
                storageGWh: { battery4hr: 16.0 }
            },
            "Australia": {
                totalCapacityMW: 65000,
                peakLoadsMW: { summer: 47000, winter: 42300, fall: 41360, spring: 37600 },
                mix: { coal: 45.0, naturalGas: 18.0, hydro: 13.0, wind: 10.0, offshoreWind: 0, solar: 13.0, nuclear: 0.0, geothermal: 0.0, biomass: 0.7, rng: 0.3 },
                storageGWh: { battery4hr: 5.6 }
            },
            "Spain": {
                totalCapacityMW: 120000,
                peakLoadsMW: { summer: 45000, winter: 40500, fall: 39600, spring: 36000 },
                mix: { coal: 2.0, naturalGas: 22.0, hydro: 17.0, wind: 27.5, offshoreWind: 0, solar: 21.5, nuclear: 7.0, geothermal: 0.0, biomass: 1.0, rng: 0.4 },
                storageGWh: { battery4hr: 1.7 }
            },
            "Italy": {
                totalCapacityMW: 122000,
                peakLoadsMW: { summer: 60000, winter: 54000, fall: 52800, spring: 48000 },
                mix: { coal: 4.0, naturalGas: 47.0, hydro: 18.0, wind: 10.0, offshoreWind: 0, solar: 19.0, nuclear: 0.0, geothermal: 1.0, biomass: 1.4, rng: 0.6 },
                storageGWh: { battery4hr: 6 }
            },
            "Indonesia": {
                totalCapacityMW: 75000,
                peakLoadsMW: { summer: 50000, winter: 45000, fall: 44000, spring: 40000 },
                mix: { coal: 48.0, naturalGas: 28.0, hydro: 9.0, wind: 0.2, offshoreWind: 0, solar: 2.8, nuclear: 0.0, geothermal: 3.0, biomass: 0.7, rng: 0.3 }
            },
            "South Africa": {
                totalCapacityMW: 60000,
                peakLoadsMW: { winter: 34000, summer: 30600, fall: 29920, spring: 27200 },
                mix: { coal: 78.0, naturalGas: 6.0, hydro: 6.0, wind: 5.5, offshoreWind: 0, solar: 3.5, nuclear: 0.0, geothermal: 0.0, biomass: 0.3, rng: 0.1 },
                storageGWh: { battery4hr: 2 }
            },
            "Mexico": {
                totalCapacityMW: 88000,
                peakLoadsMW: { summer: 50000, winter: 45000, fall: 44000, spring: 40000 },
                mix: { coal: 5.0, naturalGas: 58.0, hydro: 15.0, wind: 9.0, offshoreWind: 0, solar: 11.0, nuclear: 1.0, geothermal: 1.0, biomass: 0.3, rng: 0.1 },
                storageGWh: { battery4hr: 0.6 }
            },
            "Norway": {
                totalCapacityMW: 39000,
                peakLoadsMW: { winter: 25000, summer: 22500, fall: 22000, spring: 20000 },
                mix: { coal: 0.0, naturalGas: 0.0, hydro: 91.0, wind: 8.5, offshoreWind: 0, solar: 0.5, nuclear: 0.0, geothermal: 0.0, biomass: 0.0, rng: 0.0 },
                storageGWh: { battery4hr: 0.2 }
            },
            "New Zealand": {
                totalCapacityMW: 9800,
                peakLoadsMW: { winter: 7000, summer: 6300, fall: 6160, spring: 5600 },
                mix: { coal: 0.0, naturalGas: 14.0, hydro: 56.0, wind: 7.5, offshoreWind: 0, solar: 1.5, nuclear: 0.0, geothermal: 20.0, biomass: 0.7, rng: 0.3 },
                storageGWh: { battery4hr: 0.4 }
            },
            "Vietnam": {
                totalCapacityMW: 80000,
                peakLoadsMW: { summer: 45000, winter: 40500, fall: 39600, spring: 36000 },
                mix: { coal: 32.0, naturalGas: 9.0, hydro: 28.0, wind: 6.0, offshoreWind: 0, solar: 24.0, nuclear: 0.0, geothermal: 0.0, biomass: 0.7, rng: 0.3 },
                storageGWh: { battery4hr: 0.1 }
            }
        };

        const carbonTaxes = {
            "California": 26, "Canada": 61, "China": 8, "France": 48, "Germany": 43, "Japan": 2,
            "South Korea": 22, "Spain": 16, "United Kingdom": 22, "South Africa": 9,
            "Mexico": 3, "Norway": 85, "New Zealand": 50
        };

        // High-demand seasonal profiles (used for non-California countries)
        const SEASONAL_DEMAND_PROFILES = {
            'spring-high': [28, 26, 25, 24, 24, 25, 28, 32, 33, 32, 30, 28, 27, 28, 30, 34, 39, 45, 48, 46, 42, 38, 34, 30],
            'summer-high': [30, 28, 27, 26, 26, 27, 29, 33, 37, 40, 42, 44, 46, 48, 50, 52, 55, 56, 55, 52, 48, 43, 38, 33],
            'fall-high': [27, 25, 24, 23, 23, 24, 27, 31, 34, 36, 37, 38, 39, 40, 41, 43, 46, 50, 49, 46, 42, 37, 32, 29],
            'winter-high': [32, 30, 29, 29, 30, 34, 40, 45, 44, 42, 40, 39, 39, 40, 41, 43, 45, 46, 45, 42, 39, 36, 34, 32],
            // Typical profiles (scaled from high profiles)
            'spring-typical': [28, 26, 25, 24, 24, 25, 28, 32, 33, 32, 30, 28, 27, 28, 30, 34, 39, 45, 48, 46, 42, 38, 34, 30].map(v => v * 0.79),
            'summer-typical': [30, 28, 27, 26, 26, 27, 29, 33, 37, 40, 42, 44, 46, 48, 50, 52, 55, 56, 55, 52, 48, 43, 38, 33].map(v => v * 0.82),
            'fall-typical': [27, 25, 24, 23, 23, 24, 27, 31, 34, 36, 37, 38, 39, 40, 41, 43, 46, 50, 49, 46, 42, 37, 32, 29].map(v => v * 0.77),
            'winter-typical': [32, 30, 29, 29, 30, 34, 40, 45, 44, 42, 40, 39, 39, 40, 41, 43, 45, 46, 45, 42, 39, 36, 34, 32].map(v => v * 0.73)
        };

        // California profiles loaded from JSON (populated during initialization)
        let CALIFORNIA_PROFILES = {};

        // This object will hold the calculated POTENTIAL generation, not a pre-dispatched baseline.
        let BASELINE_POTENTIAL_GENERATION = {};
        let currentCountryInstalledCapacity = {};
        let currentBaselineStorage = {};
        let yearlyGenerationTotalsGWh = {}; // For tooltips

        const SOLAR_CF_PROFILE = [0, 0, 0, 0, 0, 0.05, 0.15, 0.3, 0.5, 0.7, 0.8, 0.85, 0.9, 0.85, 0.8, 0.7, 0.3, 0.05, 0, 0, 0, 0, 0, 0];
        const WIND_CF_PROFILE = [0.4, 0.42, 0.45, 0.46, 0.45, 0.4, 0.35, 0.3, 0.25, 0.2, 0.2, 0.2, 0.25, 0.3, 0.35, 0.4, 0.5, 0.6, 0.65, 0.6, 0.55, 0.5, 0.45, 0.4];
        const OFFSHORE_WIND_CF_PROFILE = [0.55, 0.56, 0.57, 0.58, 0.58, 0.57, 0.55, 0.52, 0.5, 0.48, 0.47, 0.46, 0.47, 0.48, 0.5, 0.52, 0.55, 0.6, 0.62, 0.61, 0.6, 0.58, 0.57, 0.56];

        const SEASONAL_HYDRO_CF = {
            spring: 0.50,
            summer: 0.30,
            fall: 0.25,
            winter: 0.35
        };

        const SEASONAL_MULTIPLIERS = {
            spring: { solar: 1.0, wind: 1.0, offshoreWind: 1.0 },
            summer: { solar: 1.1, wind: 0.8, offshoreWind: 0.9 },
            fall: { solar: 0.8, wind: 1.0, offshoreWind: 1.0 },
            winter: { solar: 0.6, wind: 1.1, offshoreWind: 1.1 }
        };
        const countryProfiles = {
            "California": { // Using default CA profile
                solar: SOLAR_CF_PROFILE,
                wind: WIND_CF_PROFILE,
                offshoreWind: OFFSHORE_WIND_CF_PROFILE
            },
            "Germany": {
                solar: [0, 0, 0, 0, 0, 0.02, 0.1, 0.25, 0.45, 0.6, 0.7, 0.75, 0.7, 0.6, 0.4, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0],
                wind: [0.5, 0.52, 0.55, 0.56, 0.55, 0.5, 0.45, 0.4, 0.35, 0.3, 0.3, 0.3, 0.35, 0.4, 0.45, 0.5, 0.6, 0.7, 0.75, 0.7, 0.65, 0.6, 0.55, 0.5],
                offshoreWind: [0.6, 0.62, 0.65, 0.66, 0.65, 0.6, 0.55, 0.5, 0.45, 0.4, 0.4, 0.4, 0.45, 0.5, 0.55, 0.6, 0.7, 0.8, 0.85, 0.8, 0.75, 0.7, 0.65, 0.6]
            },
            "United Kingdom": {
                solar: [0, 0, 0, 0, 0, 0.01, 0.08, 0.2, 0.4, 0.55, 0.65, 0.7, 0.65, 0.55, 0.35, 0.1, 0.02, 0, 0, 0, 0, 0, 0, 0],
                wind: [0.6, 0.62, 0.65, 0.68, 0.66, 0.6, 0.55, 0.5, 0.45, 0.4, 0.4, 0.4, 0.45, 0.5, 0.55, 0.6, 0.7, 0.8, 0.85, 0.8, 0.75, 0.7, 0.65, 0.6],
                offshoreWind: [0.7, 0.72, 0.75, 0.78, 0.76, 0.7, 0.65, 0.6, 0.55, 0.5, 0.5, 0.5, 0.55, 0.6, 0.65, 0.7, 0.8, 0.9, 0.95, 0.9, 0.85, 0.8, 0.75, 0.7]
            },
            "Australia": {
                solar: [0, 0, 0, 0, 0, 0.08, 0.2, 0.4, 0.6, 0.8, 0.9, 0.95, 0.9, 0.8, 0.6, 0.3, 0.1, 0, 0, 0, 0, 0, 0, 0],
                wind: [0.3, 0.3, 0.3, 0.25, 0.2, 0.2, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.45, 0.4, 0.35, 0.3, 0.3, 0.3, 0.35, 0.4, 0.4, 0.35, 0.3],
                offshoreWind: [0.4, 0.4, 0.4, 0.35, 0.3, 0.3, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.55, 0.5, 0.45, 0.4, 0.4, 0.4, 0.45, 0.5, 0.5, 0.45, 0.4]
            },
            "default": {
                solar: SOLAR_CF_PROFILE,
                wind: WIND_CF_PROFILE,
                offshoreWind: OFFSHORE_WIND_CF_PROFILE
            }
        };
        const EMISSION_FACTORS = { naturalGas: 395, hydro: 0, nuclear: 0, solar: 0, wind: 0, offshoreWind: 0, geothermal: 0, coal: 850, biomass: 0, rng: 0, hydrogen: 0 };

        const DEFAULT_COST_DATA = {
            capex: {
                solar: 1200, wind: 1500, offshoreWind: 5000, nuclear: 7242, geothermal: 3329, biomass: 3500, rng: 3000, hydrogen: 3500,
                naturalGas: 1300, hydro: 3336, coal: 4407,
                battery4hr: 350, battery8hr: 300, longduration: 300, // $/kWh
                dac: 1000 // $/ton/year
            },
            fixed_om: {
                solar: 15, wind: 35, offshoreWind: 100, nuclear: 140, geothermal: 120, biomass: 100, rng: 95, hydrogen: 90, // $/kW-year
                naturalGas: 20, hydro: 20, coal: 40,
                battery4hr: 15, battery8hr: 15, longduration: 60, // $/kW-year
                dac: 20 // $/ton/year
            },
            variable_om: {
                solar: 0, wind: 1, offshoreWind: 0, nuclear: 10, geothermal: 5, biomass: 10, rng: 50, hydrogen: 410, // $/MWh - includes green H2 fuel cost (~$6/kg at 45% efficiency)
                naturalGasCCGT: { start: 35, end: 80 }, // NEW: $/MWh
                naturalGasCT: { start: 100, end: 150 }, // NEW: $/MWh
                hydro: 5, coal: 30, // $/MWh
                battery4hr: 0, battery8hr: 2, longduration: 1,
                dac: 400, // $/ton
                storage: 30 // $/MWh - an assumed opportunity cost for dispatching storage
            },
            lifetime: {
                solar: 30, wind: 30, offshoreWind: 30, nuclear: 60, geothermal: 30, biomass: 25, rng: 25, hydrogen: 30,
                naturalGas: 30, hydro: 80, coal: 40,
                battery4hr: 15, battery8hr: 15, longduration: 25, dac: 25
            },
            capacity_factor: {
                solar: 0.25, wind: 0.35, offshoreWind: 0.50, nuclear: 0.9, geothermal: 0.9, biomass: 0.85, rng: 0.85, hydrogen: 0.20,
                naturalGas: 0.55, hydro: 0.45, coal: 0.6
            },
            discount_rate: 0.07
        };

        // Initialize mutable cost data for the session
        let COST_DATA = JSON.parse(JSON.stringify(DEFAULT_COST_DATA));

        document.addEventListener('DOMContentLoaded', async function () {
            setLogLevel('debug');

            // --- DOM ELEMENTS ---
            const sliders = {
                solar: document.getElementById('solar-slider'), wind: document.getElementById('wind-slider'), offshoreWind: document.getElementById('offshoreWind-slider'),
                geothermal: document.getElementById('geothermal-slider'), nuclear: document.getElementById('nuclear-slider'),
                biomass: document.getElementById('biomass-slider'), rng: document.getElementById("rng-slider"), hydrogen: document.getElementById("hydrogen-slider"),
                battery4hr: document.getElementById('battery4hr-slider'), battery8hr: document.getElementById('battery8hr-slider'),
                longduration: document.getElementById('longduration-slider'), demandflex: document.getElementById('demandflex-slider'),
                dac: document.getElementById('dac-slider'), solarIncentive: document.getElementById('solar-incentive-slider'),
                windIncentive: document.getElementById('wind-incentive-slider'), offshoreWindIncentive: document.getElementById('offshoreWind-incentive-slider'),
                geothermalIncentive: document.getElementById('geothermal-incentive-slider'),
                nuclearIncentive: document.getElementById('nuclear-incentive-slider'), biomassIncentive: document.getElementById('biomass-incentive-slider'),
                rngIncentive: document.getElementById("rng-incentive-slider"), hydrogenIncentive: document.getElementById("hydrogen-incentive-slider"),
                storageIncentive: document.getElementById('storage-incentive-slider'),
                dacIncentive: document.getElementById('dac-incentive-slider'), carbonTax: document.getElementById('carbon-tax-slider'),
                exportPrice: document.getElementById('export-price-slider'),
            };
            const inputs = {
                solar: document.getElementById('solar-input'), wind: document.getElementById('wind-input'), offshoreWind: document.getElementById('offshoreWind-input'),
                geothermal: document.getElementById('geothermal-input'), nuclear: document.getElementById('nuclear-input'),
                biomass: document.getElementById('biomass-input'), rng: document.getElementById("rng-input"), hydrogen: document.getElementById("hydrogen-input"),
                battery4hr: document.getElementById('battery4hr-input'), battery8hr: document.getElementById('battery8hr-input'),
                longduration: document.getElementById('longduration-input'), demandflex: document.getElementById('demandflex-input'),
                dac: document.getElementById('dac-input'), solarIncentive: document.getElementById('solar-incentive-input'),
                windIncentive: document.getElementById('wind-incentive-input'), offshoreWindIncentive: document.getElementById('offshoreWind-incentive-input'),
                geothermalIncentive: document.getElementById('geothermal-incentive-input'),
                nuclearIncentive: document.getElementById('nuclear-incentive-input'), biomassIncentive: document.getElementById('biomass-incentive-input'),
                rngIncentive: document.getElementById("rng-incentive-input"), hydrogenIncentive: document.getElementById("hydrogen-incentive-input"),
                storageIncentive: document.getElementById('storage-incentive-input'),
                dacIncentive: document.getElementById('dac-incentive-input'), carbonTax: document.getElementById('carbon-tax-input'),
                exportPrice: document.getElementById('export-price-input'),
            };

            const billImpactEl = document.getElementById('bill-impact');
            const systemCostImpactEl = document.getElementById('system-cost-impact');
            const co2AvoidedEl = document.getElementById('co2-avoided-text');
            const resetToZeroButton = document.getElementById('reset-to-zero-button');
            const makeDefaultButton = document.getElementById('make-default-button');
            const resetToDefaultButton = document.getElementById('reset-to-default-button');
            const undoButton = document.getElementById('undo-button');
            const redoButton = document.getElementById('redo-button');
            const gridMixSlidersContainer = document.getElementById('grid-mix-sliders');
            const storageCapacityDisplayContainer = document.getElementById('storage-capacity-display');
            const generationMixSlidersContainer = document.getElementById('generation-mix-sliders');
            const countrySelect = document.getElementById('country-select');
            const hoverTooltip = document.getElementById('hover-tooltip');
            const startTutorialBtn = document.getElementById('start-tutorial-btn');

            const currentDemandProfileText = document.getElementById('current-demand-profile-text');
            const editDemandBtn = document.getElementById('edit-demand-btn');
            const confirmDemandBtn = document.getElementById('confirm-demand-btn');
            const revertDemandBtn = document.getElementById('revert-demand-btn');
            const demandPresetsDiv = document.getElementById('demand-presets');

            const editCFBtn = document.getElementById('edit-cf-btn');
            const confirmCFBtn = document.getElementById('confirm-cf-btn');
            const revertCFBtn = document.getElementById('revert-cf-btn');
            const visitorCountEl = document.getElementById('visitor-count');


            // --- STATE MANAGEMENT ---
            let stateHistory = [];
            let historyIndex = -1;
            let userDefaultState = {};
            let systemDefaultState = {};
            let customBaselineSystemCost = 0;
            let customBaselineConsumerCost = 0; // NEW
            let customBaselineTotalAnnualCO2 = 0;
            let enabledTechnologies = {};
            let defaultCapacityMix = {};
            let defaultGenerationMix = {};
            let currentSystemDefaultProfileName = 'spring-typical';

            let isDemandEditMode = false;
            let currentDemand = [...SEASONAL_DEMAND_PROFILES['spring-high']];
            let originalDemandBeforeEdit = [];
            let currentDemandProfileName = 'Spring Typical';

            let isCFEditMode = false;
            let currentSolarCFProfile = [];
            let currentWindCFProfile = [];
            let currentOffshoreWindCFProfile = [];
            let currentHydroCF = SEASONAL_HYDRO_CF.spring; // Initialize with spring
            let originalSolarCFBeforeEdit = [];
            let originalWindCFBeforeEdit = [];
            let originalOffshoreWindCFBeforeEdit = [];
            let currentCFProfileName = 'Spring';

            // Full profiles for optimization (288 hours)
            let fullSolarProfile = [];
            let fullWindProfile = [];
            let fullOffshoreWindProfile = [];
            let activePotentialGeneration = {};
            let currentBaselineStorage = {};

            // Optimization context (set before running optimization)
            let optimizationContext = null;

            // --- CHARTING SETUP ---
            const generationCtx = document.getElementById('generationMixChart').getContext('2d');
            const marginalPriceCtx = document.getElementById('marginalPriceChart').getContext('2d'); // NEW
            const co2Ctx = document.getElementById('co2EmissionsChart').getContext('2d');
            const capacityFactorCtx = document.getElementById('capacityFactorChart').getContext('2d');

            const COLORS = {
                naturalGas: 'rgba(156, 163, 175, 0.9)', hydro: 'rgba(59, 130, 246, 0.8)',
                nuclear: 'rgba(239, 68, 68, 0.8)', solar: 'rgba(251, 191, 36, 1)',
                wind: 'rgba(52, 211, 153, 0.8)', /* CHANGE: Lighter green for Onshore Wind */
                offshoreWind: 'rgba(12, 148, 103, 0.8)',
                geothermal: 'rgba(120, 40, 40, 0.8)',
                biomass: 'rgba(101, 67, 33, 0.8)',
                rng: 'rgba(132, 204, 22, 0.8)',
                hydrogen: 'rgba(219, 39, 119, 0.8)', /* Pink/magenta for hydrogen */
                storage: 'rgba(168, 85, 247, 0.8)', demand: 'rgba(17, 24, 39, 1)',
                curtailment: 'rgba(253, 186, 116, 0.8)', coal: 'rgba(0, 0, 0, 0.8)',
                price: 'rgba(79, 70, 229, 1)' // NEW for price chart
            };

            // Helper function to create a patterned fill for "to Storage" generation
            function createPattern(baseColor, patternColor) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 10;
                canvas.height = 10;
                ctx.fillStyle = baseColor;
                ctx.fillRect(0, 0, 10, 10);
                ctx.strokeStyle = patternColor;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 10);
                ctx.lineTo(10, 0);
                ctx.moveTo(-1, 1);
                ctx.lineTo(1, -1);
                ctx.moveTo(9, 11);
                ctx.lineTo(11, 9);
                ctx.stroke();
                return ctx.createPattern(canvas, 'repeat');
            }

            const PATTERNS = {
                solarToStorage: createPattern(COLORS.solar, 'rgba(168, 85, 247, 0.7)'),
                windToStorage: createPattern(COLORS.wind, 'rgba(168, 85, 247, 0.7)'),
                offshoreWindToStorage: createPattern(COLORS.offshoreWind, 'rgba(168, 85, 247, 0.7)'),
                hydroToStorage: createPattern(COLORS.hydro, COLORS.storage),
                geothermalToStorage: createPattern(COLORS.geothermal, COLORS.storage),
                nuclearToStorage: createPattern(COLORS.nuclear, COLORS.storage),
                coalToStorage: createPattern(COLORS.coal, COLORS.storage),
                naturalGasToStorage: createPattern(COLORS.naturalGas, COLORS.storage),
                biomassToStorage: createPattern(COLORS.biomass, COLORS.storage),
            };

            const generationChartConfig = {
                type: 'line',
                data: {
                    labels: HOURS,
                    datasets: [
                        { label: 'Nuclear', data: [], backgroundColor: COLORS.nuclear, borderColor: COLORS.nuclear, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Geothermal', data: [], backgroundColor: COLORS.geothermal, borderColor: COLORS.geothermal, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Biomass', data: [], backgroundColor: COLORS.biomass, borderColor: COLORS.biomass, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'RNG (Biogas)', data: [], backgroundColor: COLORS.rng, borderColor: COLORS.rng, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Hydrogen', data: [], backgroundColor: COLORS.hydrogen, borderColor: COLORS.hydrogen, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Hydro', data: [], backgroundColor: COLORS.hydro, borderColor: COLORS.hydro, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Onshore Wind', data: [], backgroundColor: COLORS.wind, borderColor: COLORS.wind, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Offshore Wind', data: [], backgroundColor: COLORS.offshoreWind, borderColor: COLORS.offshoreWind, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Solar', data: [], backgroundColor: COLORS.solar, borderColor: COLORS.solar, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Natural Gas', data: [], backgroundColor: COLORS.naturalGas, borderColor: COLORS.naturalGas, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Coal', data: [], backgroundColor: COLORS.coal, borderColor: COLORS.coal, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Storage', data: [], backgroundColor: COLORS.storage, borderColor: COLORS.storage, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Solar to Storage', data: [], backgroundColor: PATTERNS.solarToStorage, borderColor: COLORS.solar, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false, hidden: false },
                        { label: 'Onshore Wind to Storage', data: [], backgroundColor: PATTERNS.windToStorage, borderColor: COLORS.wind, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false, hidden: false },
                        { label: 'Offshore Wind to Storage', data: [], backgroundColor: PATTERNS.offshoreWindToStorage, borderColor: COLORS.offshoreWind, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false, hidden: false },
                        { label: 'Curtailment', data: [], backgroundColor: COLORS.curtailment, borderColor: COLORS.curtailment, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Demand', data: currentDemand, type: 'line', borderColor: COLORS.demand, borderWidth: 1.5, pointRadius: 0, fill: false, order: -1 }
                    ]
                },
                options: {
                    responsive: true, animation: { duration: 0 },
                    plugins: {
                        tooltip: {
                            mode: 'index',
                            callbacks: {
                                title: function (context) {
                                    return context[0].label;
                                },
                                label: function (context) {
                                    return ''; // We build the full tooltip in the footer
                                },
                                footer: function (tooltipItems) {
                                    const totals = {};
                                    let stackTotal = 0;

                                    tooltipItems.forEach(function (tooltipItem) {
                                        let label = tooltipItem.dataset.label;
                                        const value = tooltipItem.raw;
                                        if (value === 0) return;

                                        // Consolidate "to Storage" tooltips
                                        if (label.includes('to Storage')) {
                                            const sourceTech = label.replace(' to Storage', '');
                                            label = `${sourceTech} (to Storage)`;
                                        }

                                        totals[label] = (totals[label] || 0) + value;

                                        if (tooltipItem.dataset.type !== 'line') {
                                            if (!label.includes('to Storage') && label !== 'Curtailment') {
                                                stackTotal += value;
                                            }
                                        }
                                    });

                                    const lines = [];
                                    const tooltipOrder = ['Coal', 'Natural Gas', 'Hydro', 'Geothermal', 'Biomass', 'RNG (Biogas)', 'Hydrogen', 'Nuclear', 'Solar', 'Onshore Wind', 'Offshore Wind', 'Storage', 'Curtailment', 'Solar (to Storage)', 'Onshore Wind (to Storage)', 'Offshore Wind (to Storage)', 'Demand'];
                                    tooltipOrder.forEach(label => {
                                        if (totals[label] > 0.01) {
                                            lines.push(`${label}: ${totals[label].toFixed(2)}`);
                                        }
                                    });

                                    if (stackTotal > 0) {
                                        lines.push('------------------');
                                        lines.push(`Total Gen to Grid: ${stackTotal.toFixed(2)}`);
                                    }
                                    return lines;
                                }
                            }
                        },
                        legend: {
                            position: 'bottom',
                            labels: {
                                filter: function (legendItem) {
                                    return !legendItem.text.includes('to Storage') && legendItem.text !== 'Demand';
                                }
                            }
                        },
                        dragData: { enabled: false }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            title: { display: false },
                            ticks: {
                                callback: function (value, index) {
                                    // Show month name only at the center of each month (hour 12 of 24)
                                    if (index % 24 === 12) {
                                        const monthIndex = Math.floor(index / 24);
                                        return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][monthIndex];
                                    }
                                    return '';
                                },
                                autoSkip: false,
                                maxRotation: 0
                            }
                        },
                        y: { stacked: true, min: 0, title: { display: true, text: 'Generation (GWh)' } }
                    }
                }
            };
            const marginalPriceChartConfig = {
                type: 'line',
                data: {
                    labels: HOURS,
                    datasets: [{
                        label: 'Marginal Price (with Storage)', data: [],
                        borderColor: COLORS.price, backgroundColor: 'rgba(79, 70, 229, 0.1)',
                        borderWidth: 1.5, fill: true, tension: 0.3, pointRadius: 0
                    }, {
                        label: 'Marginal Price (without Storage)', data: [],
                        borderColor: 'rgba(239, 68, 68, 1)',
                        borderWidth: 1.5, borderDash: [5, 5],
                        fill: false, tension: 0.3, pointRadius: 0
                    }]
                },
                options: {
                    responsive: true, animation: { duration: 0 },
                    scales: {
                        x: {
                            title: { display: false },
                            ticks: {
                                callback: function (value, index) {
                                    // Show month name only at the center of each month (hour 12 of 24)
                                    if (index % 24 === 12) {
                                        const monthIndex = Math.floor(index / 24);
                                        return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][monthIndex];
                                    }
                                    return '';
                                },
                                autoSkip: false,
                                maxRotation: 0
                            }
                        },
                        y: { title: { display: true, text: 'Price ($/MWh)' } }
                    },
                    plugins: {
                        legend: { display: true }
                    }
                }
            };
            const co2ChartConfig = {
                type: 'bar',
                data: {
                    labels: MONTHS,
                    datasets: [{
                        label: 'Total CO2 Emissions (Metric Tons)', data: [],
                        backgroundColor: 'rgba(239, 68, 68, 0.6)',
                        borderColor: 'rgba(239, 68, 68, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true, animation: { duration: 0 },
                    scales: {
                        y: { beginAtZero: true, title: { display: true, text: 'Total CO2 (Metric Tons)' } }
                    },
                    plugins: {
                        legend: { display: false },
                        annotation: {
                            annotations: {
                                totalCO2: {
                                    type: 'label',
                                    content: 'Total Annual CO2: 0 tons',
                                    position: { x: 'center', y: 'top' },
                                    yAdjust: 10,
                                    backgroundColor: 'rgba(249, 250, 251, 0.85)',
                                    borderColor: 'rgba(209, 213, 219, 1)',
                                    borderWidth: 1,
                                    borderRadius: 6,
                                    color: '#1f2937',
                                    font: { weight: 'bold', size: 16 },
                                    padding: 8,
                                }
                            }
                        }
                    }
                }
            };
            const capacityFactorChartConfig = {
                type: 'line',
                data: {
                    labels: HOURS,
                    datasets: [
                        { label: 'Solar', data: [], borderColor: COLORS.solar, borderWidth: 1.5, pointRadius: 0, fill: false, tension: 0.4, dragData: false },
                        { label: 'Onshore Wind', data: [], borderColor: COLORS.wind, borderWidth: 1.5, pointRadius: 0, fill: false, tension: 0.4, dragData: false },
                        { label: 'Offshore Wind', data: [], borderColor: COLORS.offshoreWind, borderWidth: 1.5, pointRadius: 0, fill: false, tension: 0.4, dragData: false }
                    ]
                },
                options: {
                    responsive: true, animation: { duration: 0 },
                    plugins: {
                        legend: { position: 'bottom' },
                        dragData: {
                            round: 2,
                            showTooltip: true,
                            onDrag: (e, datasetIndex, index, value) => {
                                // Enforce constraints DURING dragging for real-time feedback
                                if (value < 0) return 0;
                                if (value > 1) return 1;
                                return value;
                            },
                            onDragEnd: (e, datasetIndex, index, value) => {
                                const chart = e.chart;
                                let updatedValue = value;
                                if (value < 0) updatedValue = 0;
                                if (value > 1) updatedValue = 1;
                                chart.data.datasets[datasetIndex].data[index] = updatedValue;
                                chart.update('none');
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: false },
                            ticks: {
                                callback: function (value, index) {
                                    // Show month name only at the center of each month (hour 12 of 24)
                                    if (index % 24 === 12) {
                                        const monthIndex = Math.floor(index / 24);
                                        return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][monthIndex];
                                    }
                                    return '';
                                },
                                autoSkip: false,
                                maxRotation: 0
                            }
                        },
                        y: { title: { display: true, text: 'Capacity Factor (%)' }, min: 0, max: 1, ticks: { callback: value => `${value * 100}%` } }
                    }
                }
            };

            const generationChart = new Chart(generationCtx, generationChartConfig);
            const marginalPriceChart = new Chart(marginalPriceCtx, marginalPriceChartConfig); // NEW
            const co2Chart = new Chart(co2Ctx, co2ChartConfig);
            const capacityFactorChart = new Chart(capacityFactorCtx, capacityFactorChartConfig);

            // Magnifying glass for capacity factor chart
            const cfMagnifier = document.getElementById('cf-magnifier');
            const cfMagnifierCanvas = document.getElementById('cf-magnifier-canvas');
            const cfMagnifierCtx = cfMagnifierCanvas.getContext('2d');

            function updateMagnifier(e, chart) {
                // Only show magnifier when in edit mode
                if (!isCFEditMode) return;

                const rect = chart.canvas.getBoundingClientRect();

                // Calculate cursor position relative to canvas
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Only show magnifier if cursor is within canvas display bounds
                if (mouseX < 0 || mouseX > rect.width || mouseY < 0 || mouseY > rect.height) {
                    hideMagnifier();
                    return;
                }

                // Convert display coordinates to canvas coordinates (handle canvas scaling)
                const scaleX = chart.canvas.width / rect.width;
                const scaleY = chart.canvas.height / rect.height;
                const x = mouseX * scaleX;
                const y = mouseY * scaleY;

                // Position magnifier centered on cursor
                const magnifierLeft = e.clientX - 100;
                const magnifierTop = e.clientY - 100;

                cfMagnifier.style.left = magnifierLeft + 'px';
                cfMagnifier.style.top = magnifierTop + 'px';
                cfMagnifier.classList.remove('hidden');

                // Draw zoomed portion of chart
                const sourceSize = 80; // 80px becomes 200px = 2.5x zoom
                const sourceX = x - sourceSize / 2;
                const sourceY = y - sourceSize / 2;

                cfMagnifierCtx.fillStyle = 'white';
                cfMagnifierCtx.fillRect(0, 0, 200, 200);
                cfMagnifierCtx.drawImage(
                    chart.canvas,
                    sourceX, sourceY, sourceSize, sourceSize,
                    0, 0, 200, 200
                );

                // Draw crosshair at center
                cfMagnifierCtx.strokeStyle = '#EF4444';
                cfMagnifierCtx.lineWidth = 2;
                cfMagnifierCtx.beginPath();
                cfMagnifierCtx.moveTo(100, 90);
                cfMagnifierCtx.lineTo(100, 110);
                cfMagnifierCtx.moveTo(90, 100);
                cfMagnifierCtx.lineTo(110, 100);
                cfMagnifierCtx.stroke();
            }

            function hideMagnifier() {
                cfMagnifier.classList.add('hidden');
            }

            // Add event listeners to capacity factor chart for magnifier
            capacityFactorCtx.canvas.addEventListener('mousemove', (e) => {
                if (isCFEditMode) {
                    updateMagnifier(e, capacityFactorChart);
                }
            });

            capacityFactorCtx.canvas.addEventListener('mouseleave', hideMagnifier);


            // --- COST CALCULATION ---
            function calculateTotalAnnualSystemCost(generation, capacity, currentIncentives, curtailedEnergy, baselineCapacity, baselineStorage, gasGenDetails) {
                let totalAnnualCost = 0;
                const d = COST_DATA.discount_rate;
                const numHours = generation.solar.length;
                const hoursPerMonth = 24;

                function getAnnualSum(profile) {
                    if (!profile) return 0;
                    let sum = 0;
                    for (let i = 0; i < numHours; i++) {
                        const monthIndex = Math.floor(i / hoursPerMonth) % 12;
                        sum += profile[i] * DAYS_IN_MONTH[monthIndex];
                    }
                    return sum;
                }

                for (const tech in COST_DATA.capacity_factor) {
                    if (tech === 'naturalGas') continue;

                    const techData = COST_DATA;
                    if (!techData.lifetime[tech]) continue;
                    const n = techData.lifetime[tech];
                    const crf = (d * Math.pow(1 + d, n)) / (Math.pow(1 + d, n) - 1);

                    const baselineCapacityGW = baselineCapacity[tech] || 0;
                    const newCapacityGW = capacity[tech] || 0;
                    const totalCapacityKW = (baselineCapacityGW + newCapacityGW) * 1000000;

                    if (totalCapacityKW > 0) {
                        const annualized_capex = techData.capex[tech] * totalCapacityKW * crf;
                        const annual_fom = techData.fixed_om[tech] * totalCapacityKW;
                        const annual_generation_mwh = getAnnualSum(generation[tech]) * 1000;
                        const annual_vom = techData.variable_om[tech] * annual_generation_mwh;

                        let annual_ptc = 0;
                        if (currentIncentives[tech]) {
                            annual_ptc = currentIncentives[tech] * annual_generation_mwh;
                        }

                        totalAnnualCost += annualized_capex + annual_fom + annual_vom - annual_ptc;
                    }
                }

                const baselineNGCapacityGW = baselineCapacity.naturalGas || 0;
                const newNGCapacityGW = capacity.naturalGas || 0;
                const totalNGCapacityKW = (baselineNGCapacityGW + newNGCapacityGW) * 1000000;

                if (totalNGCapacityKW > 0) {
                    const n = COST_DATA.lifetime.naturalGas;
                    const crf = (d * Math.pow(1 + d, n)) / (Math.pow(1 + d, n) - 1);
                    const annualized_capex = COST_DATA.capex.naturalGas * totalNGCapacityKW * crf;
                    const annual_fom = COST_DATA.fixed_om.naturalGas * totalNGCapacityKW;
                    const annual_vom_ng = (gasGenDetails?.ccgt?.cost || 0) + (gasGenDetails?.ct?.cost || 0);
                    totalAnnualCost += annualized_capex + annual_fom + annual_vom_ng;
                }

                for (const type of ['battery4hr', 'battery8hr', 'longduration']) {
                    if (!enabledTechnologies[type]) continue;
                    const baseline_gwh = baselineStorage[type] || 0;
                    const new_gwh = capacity[type] || 0;
                    const total_gwh = baseline_gwh + new_gwh;

                    if (total_gwh > 0) {
                        if (!COST_DATA.lifetime[type]) continue;
                        const n = COST_DATA.lifetime[type];
                        const crf = (d * Math.pow(1 + d, n)) / (Math.pow(1 + d, n) - 1);

                        let capex_per_kwh = COST_DATA.capex[type] - currentIncentives.storage;
                        const total_kwh = total_gwh * 1000000;
                        const duration = type === 'longduration' ? 24 : parseInt(type.match(/\d+/)[0]);
                        const total_kw = total_kwh / duration;

                        const annualized_capex = capex_per_kwh * total_kwh * crf;
                        const annual_fom = COST_DATA.fixed_om[type] * total_kw;
                        const annual_discharge_mwh = getAnnualSum(generation.storage) * 1000;
                        const annual_vom = COST_DATA.variable_om[type] * annual_discharge_mwh;

                        totalAnnualCost += annualized_capex + annual_fom + annual_vom;
                    }
                }

                if (capacity.dac > 0) {
                    const annualDacCapacityTons = capacity.dac * 24 * 365;
                    const n = COST_DATA.lifetime.dac;
                    const crf = (d * Math.pow(1 + d, n)) / (Math.pow(1 + d, n) - 1);

                    const annualizedDacCapex = COST_DATA.capex.dac * annualDacCapacityTons * crf;
                    const annualDacFom = COST_DATA.fixed_om.dac * annualDacCapacityTons;
                    const dacVariableCost = annualDacCapacityTons * COST_DATA.variable_om.dac;
                    const dacIncentiveValue = annualDacCapacityTons * currentIncentives.dac;

                    totalAnnualCost += (annualizedDacCapex + annualDacFom + dacVariableCost - dacIncentiveValue);
                }

                const totalAnnualCO2 = getAnnualSum(calculateEmissions(generation, 0));
                totalAnnualCost += (totalAnnualCO2 / 1000) * currentIncentives.carbonTax; // carbonTax is in $/ton, CO2 is in kg

                const annualExportRevenue = getAnnualSum(curtailedEnergy) * 1000 * currentIncentives.exportPrice;
                totalAnnualCost -= annualExportRevenue;

                return totalAnnualCost;
            }

            // NEW: Function to calculate consumer cost based on marginal price
            function calculateAnnualConsumerCost(hourlyMarginalPrice, demand) {
                let totalCost = 0;
                const numHours = hourlyMarginalPrice.length;
                const hoursPerMonth = 24;
                for (let i = 0; i < numHours; i++) {
                    const monthIndex = Math.floor(i / hoursPerMonth) % 12;
                    totalCost += hourlyMarginalPrice[i] * demand[i] * 1000 * DAYS_IN_MONTH[monthIndex];
                }
                return totalCost;
            }


            // --- REWRITTEN DISPATCH LOGIC ---
            function getSimulationResult(inputs, solarProfile, windProfile, offshoreWindProfile, potentialGen, baselineStorageGWh = {}, hydroCF, countryName, storageOverrideDisabled = false) {
                const VRE_SOURCES = ['solar', 'wind', 'offshoreWind'];
                const INFLEXIBLE_SOURCES = ['nuclear', 'geothermal', 'biomass', 'rng', 'hydrogen'];
                const numHours = solarProfile.length;

                let finalGeneration = {
                    coal: Array(numHours).fill(0), naturalGas: Array(numHours).fill(0),
                    hydro: Array(numHours).fill(0), nuclear: Array(numHours).fill(0),
                    geothermal: Array(numHours).fill(0), biomass: Array(numHours).fill(0), rng: Array(numHours).fill(0), hydrogen: Array(numHours).fill(0),
                    solar: Array(numHours).fill(0), wind: Array(numHours).fill(0), offshoreWind: Array(numHours).fill(0),
                    storage: Array(numHours).fill(0), curtailment: Array(numHours).fill(0),
                    solarToStorage: Array(numHours).fill(0), windToStorage: Array(numHours).fill(0), offshoreWindToStorage: Array(numHours).fill(0)
                };

                let curtailmentBySource = { solar: Array(numHours).fill(0), wind: Array(numHours).fill(0), offshoreWind: Array(numHours).fill(0) };

                let modifiedDemand = [...currentDemand];

                if (inputs.capacity.demandflex > 0) {
                    for (let dayStart = 0; dayStart < numHours; dayStart += 24) {
                        const dayLoad = modifiedDemand.slice(dayStart, dayStart + 24);
                        const originalPeak = Math.max(...dayLoad);
                        let totalAmountToShift = originalPeak * (inputs.capacity.demandflex / 100);

                        const shiftIncrement = 0.1;
                        let iterations = 0;
                        while (totalAmountToShift > 0.01 && iterations < 100) {
                            const currentPeak = Math.max(...dayLoad);
                            const currentTrough = Math.min(...dayLoad);
                            if (currentPeak <= currentTrough) break;

                            const peakIndex = dayLoad.indexOf(currentPeak);
                            const troughIndex = dayLoad.indexOf(currentTrough);

                            const amount = Math.min(shiftIncrement, totalAmountToShift);
                            dayLoad[peakIndex] -= amount;
                            dayLoad[troughIndex] += amount;

                            modifiedDemand[dayStart + peakIndex] -= amount;
                            modifiedDemand[dayStart + troughIndex] += amount;

                            totalAmountToShift -= amount;
                            iterations++;
                        }
                    }
                }


                let currentPotential = JSON.parse(JSON.stringify(potentialGen));

                // Ensure all technology arrays exist and are correctly sized to numHours
                const allTechs = ['solar', 'wind', 'offshoreWind', 'nuclear', 'geothermal', 'biomass', 'rng', 'hydrogen', 'hydro', 'naturalGas', 'coal'];
                for (const tech of allTechs) {
                    if (!currentPotential[tech] || currentPotential[tech].length !== numHours) {
                        // If array is missing or wrong size, create/resize it
                        const existingArray = currentPotential[tech] || [];
                        currentPotential[tech] = Array(numHours).fill(0);
                        // Copy existing values if any
                        for (let j = 0; j < Math.min(existingArray.length, numHours); j++) {
                            currentPotential[tech][j] = existingArray[j] || 0;
                        }
                        // For arrays that were shorter, repeat the 24-hour pattern
                        if (existingArray.length === 24 && numHours > 24) {
                            for (let j = 24; j < numHours; j++) {
                                currentPotential[tech][j] = existingArray[j % 24] || 0;
                            }
                        }
                    }
                }

                for (let i = 0; i < numHours; i++) {
                    currentPotential.solar[i] += inputs.capacity.solar * solarProfile[i];
                    currentPotential.wind[i] += inputs.capacity.wind * windProfile[i];
                    currentPotential.offshoreWind[i] += inputs.capacity.offshoreWind * offshoreWindProfile[i];
                    currentPotential.nuclear[i] += inputs.capacity.nuclear * COST_DATA.capacity_factor.nuclear;
                    currentPotential.geothermal[i] += inputs.capacity.geothermal * COST_DATA.capacity_factor.geothermal;
                    currentPotential.biomass[i] += inputs.capacity.biomass * COST_DATA.capacity_factor.biomass;
                    currentPotential.rng[i] += inputs.capacity.rng * COST_DATA.capacity_factor.rng;
                    currentPotential.hydrogen[i] += inputs.capacity.hydrogen * COST_DATA.capacity_factor.hydrogen;
                }
                const hydroCapacity = (currentCountryInstalledCapacity.hydro || 0) + (inputs.capacity.hydro || 0);
                const maxHourlyHydroOutput = countryName === 'California' ? hydroCapacity * 0.32 : hydroCapacity;

                let netLoad = Array(numHours).fill(0);
                for (let i = 0; i < numHours; i++) {
                    let vreAndInflexibleGen = 0;
                    [...INFLEXIBLE_SOURCES, ...VRE_SOURCES].forEach(tech => {
                        const potential = currentPotential[tech][i];
                        finalGeneration[tech][i] = potential;
                        vreAndInflexibleGen += potential;
                    });
                    netLoad[i] = modifiedDemand[i] - vreAndInflexibleGen;
                }

                if (!storageOverrideDisabled) {
                    const storageDispatch = dispatchStorageEconomically(netLoad, inputs, baselineStorageGWh, currentPotential);
                    finalGeneration.storage = storageDispatch.discharge;

                    for (let i = 0; i < numHours; i++) {
                        netLoad[i] += storageDispatch.charge[i];
                        netLoad[i] -= storageDispatch.discharge[i];

                        if (storageDispatch.charge[i] > 0) {
                            let totalVrePotential = finalGeneration.solar[i] + finalGeneration.wind[i] + finalGeneration.offshoreWind[i];
                            if (totalVrePotential > 0) {
                                const vreChargeAmount = Math.min(storageDispatch.charge[i], totalVrePotential);
                                let solarCharge = (finalGeneration.solar[i] / totalVrePotential) * vreChargeAmount;
                                let windCharge = (finalGeneration.wind[i] / totalVrePotential) * vreChargeAmount;
                                let offshoreCharge = (finalGeneration.offshoreWind[i] / totalVrePotential) * vreChargeAmount;

                                finalGeneration.solarToStorage[i] = solarCharge = Math.min(solarCharge, finalGeneration.solar[i]);
                                finalGeneration.windToStorage[i] = windCharge = Math.min(windCharge, finalGeneration.wind[i]);
                                finalGeneration.offshoreWindToStorage[i] = offshoreCharge = Math.min(offshoreCharge, finalGeneration.offshoreWind[i]);

                                finalGeneration.solar[i] -= solarCharge;
                                finalGeneration.wind[i] -= windCharge;
                                finalGeneration.offshoreWind[i] -= offshoreCharge;
                            }
                        }
                    }
                }

                for (let i = 0; i < numHours; i++) {
                    if (netLoad[i] < 0) {
                        finalGeneration.curtailment[i] = -netLoad[i];

                        // Flexibility: Solar, Wind, Nuclear, Geothermal, Biomass, RNG, and Hydrogen can all curtail
                        const flexibleResources = [...VRE_SOURCES, 'nuclear', 'geothermal', 'biomass', 'rng', 'hydrogen'];
                        let availableForCurtailment = 0;
                        flexibleResources.forEach(tech => availableForCurtailment += finalGeneration[tech][i]);

                        if (availableForCurtailment > 0) {
                            flexibleResources.forEach(tech => {
                                const proportion = finalGeneration[tech][i] / availableForCurtailment;
                                const reduction = Math.min(finalGeneration.curtailment[i] * proportion, finalGeneration[tech][i]);
                                if (VRE_SOURCES.includes(tech)) {
                                    curtailmentBySource[tech][i] += reduction;
                                }
                                finalGeneration[tech][i] -= reduction;
                            });
                        }
                        netLoad[i] = 0;
                    }
                }

                for (let dayStart = 0; dayStart < numHours; dayStart += 24) {
                    const dayNetLoad = netLoad.slice(dayStart, dayStart + 24);
                    const totalDailyHydroEnergy = hydroCapacity * hydroCF * 24;
                    const baseloadHydroEnergy = totalDailyHydroEnergy * 0.40;
                    let flexibleHydroEnergy = totalDailyHydroEnergy * 0.60;

                    const deficitHours = dayNetLoad.map((load, h) => load > 0.01 ? h + dayStart : -1).filter(h => h !== -1);
                    if (deficitHours.length > 0) {
                        const hourlyBaseloadHydro = baseloadHydroEnergy / deficitHours.length;
                        deficitHours.forEach(i => {
                            const hydroToDispatch = Math.min(hourlyBaseloadHydro, netLoad[i], maxHourlyHydroOutput - finalGeneration.hydro[i]);
                            finalGeneration.hydro[i] += hydroToDispatch;
                            netLoad[i] -= hydroToDispatch;
                        });
                    }
                    while (flexibleHydroEnergy > 0.01) {
                        let maxPriority = -Infinity, maxPriorityHour = -1;
                        for (let i = dayStart; i < dayStart + 24; i++) {
                            if (netLoad[i] > 0.01 && netLoad[i] > maxPriority) {
                                maxPriority = netLoad[i];
                                maxPriorityHour = i;
                            }
                        }
                        if (maxPriorityHour === -1) break;
                        const hydroToDispatch = Math.min(0.1, flexibleHydroEnergy, netLoad[maxPriorityHour], maxHourlyHydroOutput - finalGeneration.hydro[maxPriorityHour]);
                        if (hydroToDispatch < 0.001) break;
                        finalGeneration.hydro[maxPriorityHour] += hydroToDispatch;
                        netLoad[maxPriorityHour] -= hydroToDispatch;
                        flexibleHydroEnergy -= hydroToDispatch;
                    }
                }

                const { gasGenDetails, hourlyMarginalPrice, thermalGeneration } = calculateThermalDispatchAndPrice(netLoad, inputs, currentPotential);
                finalGeneration.naturalGas = thermalGeneration.naturalGas;
                finalGeneration.coal = thermalGeneration.coal;

                for (let i = 0; i < numHours; i++) {
                    if (finalGeneration.curtailment[i] > 0.01) {
                        hourlyMarginalPrice[i] = inputs.incentives.exportPrice;
                    }
                }

                const newEmissions = calculateEmissions(finalGeneration, inputs.capacity.dac * 1000);  // Convert t/hr to kg/hr
                const newSystemCost = calculateTotalAnnualSystemCost(finalGeneration, inputs.capacity, inputs.incentives, finalGeneration.curtailment, currentCountryInstalledCapacity, baselineStorageGWh, gasGenDetails);

                return {
                    generation: finalGeneration,
                    emissions: newEmissions,
                    systemCost: newSystemCost,
                    demand: modifiedDemand,
                    curtailmentBySource: curtailmentBySource,
                    hourlyMarginalPrice: hourlyMarginalPrice
                };
            }

            function calculateThermalDispatchAndPrice(netLoad, inputs, currentPotential) {
                const gasGenDetails = { ccgt: { generation: 0, cost: 0 }, ct: { generation: 0, cost: 0 } };
                const numHours = netLoad.length;
                const hourlyMarginalPrice = Array(numHours).fill(0);
                const thermalGeneration = { naturalGas: Array(numHours).fill(0), coal: Array(numHours).fill(0) };

                const totalNGCapacity = (currentCountryInstalledCapacity.naturalGas || 0) + (inputs.capacity.naturalGas || 0);
                const ccgtCapacity = totalNGCapacity * 0.7;
                const ctCapacity = totalNGCapacity * 0.3;

                const hoursPerMonth = 24;

                for (let i = 0; i < numHours; i++) {
                    let remainingLoad = netLoad[i];
                    let hourlyPrice = 0;

                    if (remainingLoad <= 0.01) {
                        hourlyMarginalPrice[i] = 0;
                        continue;
                    }

                    const monthIndex = Math.floor(i / hoursPerMonth) % 12;
                    const days = DAYS_IN_MONTH[monthIndex];

                    if (ccgtCapacity > 0) {
                        const ccgtToDispatch = Math.min(remainingLoad, ccgtCapacity);
                        if (ccgtToDispatch > 0) {
                            thermalGeneration.naturalGas[i] += ccgtToDispatch;
                            remainingLoad -= ccgtToDispatch;
                            const costStart = COST_DATA.variable_om.naturalGasCCGT.start;
                            const costEnd = COST_DATA.variable_om.naturalGasCCGT.end;
                            const priceAtDispatch = costStart + (costEnd - costStart) * (ccgtToDispatch / ccgtCapacity);
                            hourlyPrice = Math.max(hourlyPrice, priceAtDispatch);
                            const avgCost = (costStart + priceAtDispatch) / 2;
                            gasGenDetails.ccgt.cost += ccgtToDispatch * 1000 * avgCost * days;
                        }
                    }

                    if (remainingLoad > 0.01 && ctCapacity > 0) {
                        const ctToDispatch = Math.min(remainingLoad, ctCapacity);
                        if (ctToDispatch > 0) {
                            thermalGeneration.naturalGas[i] += ctToDispatch;
                            remainingLoad -= ctToDispatch;
                            const costStart = COST_DATA.variable_om.naturalGasCT.start;
                            const costEnd = COST_DATA.variable_om.naturalGasCT.end;
                            const priceAtDispatch = costStart + (costEnd - costStart) * (ctToDispatch / ctCapacity);
                            hourlyPrice = Math.max(hourlyPrice, priceAtDispatch);
                            const avgCost = (costStart + priceAtDispatch) / 2;
                            gasGenDetails.ct.cost += ctToDispatch * 1000 * avgCost * days;
                        }
                    }

                    if (remainingLoad > 0.01 && currentPotential.coal[i] > 0) {
                        const coalToDispatch = Math.min(remainingLoad, currentPotential.coal[i]);
                        thermalGeneration.coal[i] += coalToDispatch;
                        remainingLoad -= coalToDispatch;
                        hourlyPrice = Math.max(hourlyPrice, COST_DATA.variable_om.coal);
                    }
                    hourlyMarginalPrice[i] = hourlyPrice;
                }
                return { gasGenDetails, hourlyMarginalPrice, thermalGeneration };
            }

            function dispatchStorageEconomically(initialNetLoad, inputs, baselineStorageGWh, currentPotential) {
                const storageTypes = ['battery4hr', 'battery8hr', 'longduration'];
                const storageCapacityGWh = {};
                const storagePowerGW = {};
                let totalStorageEnergyGWh = 0;

                storageTypes.forEach(type => {
                    if (enabledTechnologies[type]) {
                        const capacity = (baselineStorageGWh[type] || 0) + inputs.capacity[type];
                        storageCapacityGWh[type] = capacity;
                        totalStorageEnergyGWh += capacity;
                        const duration = type === 'longduration' ? 24 : parseInt(type.match(/\d+/)[0]);
                        storagePowerGW[type] = capacity / duration;
                    } else {
                        storageCapacityGWh[type] = 0;
                        storagePowerGW[type] = 0;
                    }
                });

                const numHours = initialNetLoad.length;

                if (totalStorageEnergyGWh === 0) {
                    return { charge: Array(numHours).fill(0), discharge: Array(numHours).fill(0) };
                }

                let netLoad = [...initialNetLoad];
                let hourlyCharge = Array(numHours).fill(0);
                let hourlyDischarge = Array(numHours).fill(0);
                let totalChargedGWh = 0;

                const storageEfficiency = 0.85;
                const DISPATCH_INCREMENT = 0.1;
                const PROFIT_THRESHOLD = 20;

                for (let dayStart = 0; dayStart < numHours; dayStart += 24) {

                    let dayPotential = {};
                    for (let k in currentPotential) {
                        if (Array.isArray(currentPotential[k])) dayPotential[k] = currentPotential[k].slice(dayStart, dayStart + 24);
                    }

                    let dayNetLoad = netLoad.slice(dayStart, dayStart + 24);
                    let dayCharge = Array(24).fill(0);
                    let dayDischarge = Array(24).fill(0);

                    let dayTotalCharged = 0;

                    while (true) {
                        const { hourlyMarginalPrice } = calculateThermalDispatchAndPrice(dayNetLoad, inputs, dayPotential);

                        let maxPrice = -Infinity, minPrice = Infinity;
                        let maxPriceHour = -1, minPriceHour = -1;

                        // Find max and min prices
                        for (let i = 0; i < 24; i++) {
                            if (hourlyMarginalPrice[i] > maxPrice) { maxPrice = hourlyMarginalPrice[i]; }
                            if (hourlyMarginalPrice[i] < minPrice) { minPrice = hourlyMarginalPrice[i]; }
                        }

                        // Find all hours with maximum price, then pick the one with least existing discharge
                        // This spreads discharging across multiple high-price hours
                        const maxPriceHours = [];
                        for (let i = 0; i < 24; i++) {
                            if (Math.abs(hourlyMarginalPrice[i] - maxPrice) < 0.01) {
                                maxPriceHours.push(i);
                            }
                        }

                        if (maxPriceHours.length > 0) {
                            maxPriceHour = maxPriceHours[0];
                            let minExistingDischarge = dayDischarge[maxPriceHours[0]];
                            for (let j = 1; j < maxPriceHours.length; j++) {
                                const hour = maxPriceHours[j];
                                if (dayDischarge[hour] < minExistingDischarge) {
                                    minExistingDischarge = dayDischarge[hour];
                                    maxPriceHour = hour;
                                }
                            }
                        }

                        // Find all hours with minimum price, then pick the one with least existing charge
                        // This spreads charging across multiple low-price hours instead of concentrating it
                        const minPriceHours = [];
                        for (let i = 0; i < 24; i++) {
                            if (Math.abs(hourlyMarginalPrice[i] - minPrice) < 0.01) {
                                minPriceHours.push(i);
                            }
                        }

                        if (minPriceHours.length > 0) {
                            // Pick the hour with the least existing charge to spread charging out
                            minPriceHour = minPriceHours[0];
                            let minExistingCharge = dayCharge[minPriceHours[0]];
                            for (let j = 1; j < minPriceHours.length; j++) {
                                const hour = minPriceHours[j];
                                if (dayCharge[hour] < minExistingCharge) {
                                    minExistingCharge = dayCharge[hour];
                                    minPriceHour = hour;
                                }
                            }
                        }

                        if ((maxPrice * storageEfficiency) - minPrice <= PROFIT_THRESHOLD || maxPriceHour === -1 || minPriceHour === -1) break;

                        let availableCharge = 0, availableDischarge = 0;
                        storageTypes.forEach(t => { availableCharge += storagePowerGW[t]; availableDischarge += storagePowerGW[t]; });

                        const chargeHeadroom = availableCharge - dayCharge[minPriceHour];
                        const dischargeHeadroom = availableDischarge - dayDischarge[maxPriceHour];
                        const energyHeadroom = totalStorageEnergyGWh - dayTotalCharged;

                        const dispatchAmount = Math.min(DISPATCH_INCREMENT, chargeHeadroom, dischargeHeadroom, energyHeadroom);
                        if (dispatchAmount < 0.01) break;

                        const chargeAmount = dispatchAmount / storageEfficiency;
                        dayCharge[minPriceHour] += chargeAmount;
                        dayDischarge[maxPriceHour] += dispatchAmount;
                        dayTotalCharged += chargeAmount;

                        dayNetLoad[minPriceHour] += chargeAmount;
                        dayNetLoad[maxPriceHour] -= dispatchAmount;
                    }

                    for (let i = 0; i < 24; i++) {
                        hourlyCharge[dayStart + i] = dayCharge[i];
                        hourlyDischarge[dayStart + i] = dayDischarge[i];
                        netLoad[dayStart + i] = dayNetLoad[i];
                    }
                }

                return { charge: hourlyCharge, discharge: hourlyDischarge };
            }


            function runSimulation() {
                // Collect inputs
                const currentValues = {};
                for (const key in sliders) {
                    currentValues[key] = parseFloat(sliders[key].value);
                }

                const selectedCountry = countrySelect.value;
                // If profiles aren't ready, use empty arrays (prevents crash on first load)
                const baseProfiles = {
                    solar: countryProfiles[selectedCountry]?.solar || countryProfiles['default'].solar,
                    wind: countryProfiles[selectedCountry]?.wind || countryProfiles['default'].wind,
                    offshoreWind: countryProfiles[selectedCountry]?.offshoreWind || countryProfiles['default'].offshoreWind
                };

                // Construct 12-month profiles
                let fullSolarProfile = [];
                let fullWindProfile = [];
                let fullOffshoreWindProfile = [];
                const fullDemand = [];

                // Check if we should use user-defined profiles instead of rebuilding from base
                if (currentCFProfileName === "User Defined" &&
                    currentSolarCFProfile.length === 288 &&
                    currentWindCFProfile.length === 288 &&
                    currentOffshoreWindCFProfile.length === 288) {
                    // Use the saved user-defined profiles directly
                    fullSolarProfile = [...currentSolarCFProfile];
                    fullWindProfile = [...currentWindCFProfile];
                    fullOffshoreWindProfile = [...currentOffshoreWindCFProfile];
                } else {
                    // Build profiles from base with seasonal multipliers
                    // Map months to seasons (0=Jan, 11=Dec)
                    const userSeasonMap = [
                        'winter', 'winter', // Jan, Feb
                        'spring', 'spring', 'spring', // Mar, Apr, May
                        'summer', 'summer', 'summer', 'summer', // Jun, Jul, Aug, Sep
                        'fall', 'fall', // Oct, Nov
                        'winter' // Dec
                    ];

                    for (let m = 0; m < 12; m++) {
                        const season = userSeasonMap[m];
                        const seasonalMultipliers = SEASONAL_MULTIPLIERS[season] || { solar: 1.0, wind: 1.0, offshoreWind: 1.0 };

                        // Apply seasonal multipliers to base profiles to create monthly profiles
                        const sSolar = baseProfiles.solar.map(cf => Math.min(1, cf * seasonalMultipliers.solar));
                        const sWind = baseProfiles.wind.map(cf => Math.min(1, cf * seasonalMultipliers.wind));
                        const sOffshoreWind = baseProfiles.offshoreWind.map(cf => Math.min(1, cf * seasonalMultipliers.offshoreWind));

                        fullSolarProfile.push(...sSolar);
                        fullWindProfile.push(...sWind);
                        fullOffshoreWindProfile.push(...sOffshoreWind);
                    }
                }

                // Determine if we are using High or Typical demand based on current selection
                const isHighDemand = currentDemandProfileName.toLowerCase().includes('high');

                // Map months to seasons for demand (0=Jan, 11=Dec)
                const userSeasonMap = [
                    'winter', 'winter', // Jan, Feb
                    'spring', 'spring', 'spring', // Mar, Apr, May
                    'summer', 'summer', 'summer', 'summer', // Jun, Jul, Aug, Sep
                    'fall', 'fall', // Oct, Nov
                    'winter' // Dec
                ];

                let activePotentialGeneration = {};
                if (typeof BASELINE_POTENTIAL_GENERATION !== 'undefined') {
                    for (const tech in BASELINE_POTENTIAL_GENERATION) {
                        activePotentialGeneration[tech] = [];
                    }
                }

                for (let m = 0; m < 12; m++) {
                    const season = userSeasonMap[m];

                    // Demand Generation - use the appropriate seasonal profile
                    // For typical: 'winter-typical', 'spring-typical', etc.
                    // For high: 'winter-high', 'spring-high', etc.
                    const demandType = isHighDemand ? 'high' : 'typical';
                    const demandKey = `${season}-${demandType}`;
                    const sDemand = SEASONAL_DEMAND_PROFILES[demandKey] || SEASONAL_DEMAND_PROFILES[`${season}-high`] || Array(24).fill(30);
                    fullDemand.push(...sDemand);

                    // Duplicate baseline potential generation for 12 months
                    // BASELINE_POTENTIAL_GENERATION contains simple 24-hour profiles (not seasonal structure)
                    if (typeof BASELINE_POTENTIAL_GENERATION !== 'undefined') {
                        for (const tech in BASELINE_POTENTIAL_GENERATION) {
                            // BASELINE_POTENTIAL_GENERATION[tech] is a 24-hour array
                            activePotentialGeneration[tech].push(...(BASELINE_POTENTIAL_GENERATION[tech] || Array(24).fill(0)));
                        }
                    }
                }

                currentDemand = fullDemand; // Update global currentDemand

                // REMOVED: This code was incorrectly OVERWRITING baseline generation when using user-defined CFs
                // The baseline should stay in activePotentialGeneration, and NEW capacity is added via inputs.capacity in getSimulationResult
                // If using user-defined CF profiles, they're already applied to fullSolarProfile/fullWindProfile/fullOffshoreWindProfile
                // and will be used correctly when getSimulationResult adds inputs.capacity to the baseline (line 2042-2044)

                // DEBUG: Log array lengths to identify the issue
                console.log('DEBUG runSimulation:', {
                    fullDemandLength: fullDemand.length,
                    fullSolarProfileLength: fullSolarProfile.length,
                    fullWindProfileLength: fullWindProfile.length,
                    fullOffshoreWindProfileLength: fullOffshoreWindProfile.length,
                    activePotentialGenerationSolar: activePotentialGeneration.solar?.length,
                    activePotentialGenerationWind: activePotentialGeneration.wind?.length,
                    currentDemandLength: currentDemand.length,
                    firstFewDemandValues: fullDemand.slice(0, 5),
                    lastFewDemandValues: fullDemand.slice(-5)
                });

                const inputsForSim = {
                    capacity: {
                        solar: currentValues.solar,
                        wind: currentValues.wind,
                        offshoreWind: currentValues.offshoreWind,
                        geothermal: currentValues.geothermal,
                        nuclear: currentValues.nuclear,
                        biomass: currentValues.biomass,
                        rng: currentValues.rng,
                        hydrogen: currentValues.hydrogen,
                        battery4hr: currentValues.battery4hr,
                        battery8hr: currentValues.battery8hr,
                        longduration: currentValues.longduration,
                        dac: currentValues.dac,
                        hydro: 0,
                        naturalGas: 0,
                        coal: 0,
                        demandflex: currentValues.demandflex
                    },
                    incentives: {
                        solar: currentValues.solarIncentive,
                        wind: currentValues.windIncentive,
                        offshoreWind: currentValues.offshoreWindIncentive,
                        geothermal: currentValues.geothermalIncentive,
                        nuclear: currentValues.nuclearIncentive,
                        biomass: currentValues.biomassIncentive,
                        rng: currentValues.rngIncentive,
                        hydrogen: currentValues.hydrogenIncentive,
                        storage: currentValues.storageIncentive,
                        dac: currentValues.dacIncentive,
                        carbonTax: currentValues.carbonTax,
                        exportPrice: currentValues.exportPrice
                    }
                };

                // DEBUG: Log simulation inputs to compare with optimization
                if (typeof window.debugSimulationInputs === 'undefined') {
                    window.debugSimulationInputs = true;
                    console.log('=== MANUAL MODE SIMULATION INPUTS ===');
                    console.log('NEW Capacity passed:', inputsForSim.capacity);
                    console.log('Solar profile length:', fullSolarProfile.length);
                    console.log('Solar profile sample (first 10):');
                    fullSolarProfile.slice(0, 10).forEach((val, i) => console.log(`  Hour ${i}: ${val.toFixed(4)}`));
                    console.log('Wind profile length:', fullWindProfile.length);
                    console.log('Wind profile sample (first 10):');
                    fullWindProfile.slice(0, 10).forEach((val, i) => console.log(`  Hour ${i}: ${val.toFixed(4)}`));
                    console.log('Demand length:', fullDemand.length);
                    console.log('Demand sample (first 10):');
                    fullDemand.slice(0, 10).forEach((val, i) => console.log(`  Hour ${i}: ${val.toFixed(2)} GW`));
                    console.log('Baseline storage:', currentBaselineStorage);
                    console.log('Baseline capacity:', currentCountryInstalledCapacity);
                    console.log('potentialGen keys:', Object.keys(activePotentialGeneration));
                    console.log('potentialGen.solar length:', activePotentialGeneration.solar?.length);
                    console.log('potentialGen.solar sample (first 10):');
                    activePotentialGeneration.solar?.slice(0, 10).forEach((val, i) => console.log(`  Hour ${i}: ${val.toFixed(4)} GW`));
                    console.log('potentialGen.wind sample (first 10):');
                    activePotentialGeneration.wind?.slice(0, 10).forEach((val, i) => console.log(`  Hour ${i}: ${val.toFixed(4)} GW`));
                    console.log('potentialGen.hydro sample (first 10):');
                    activePotentialGeneration.hydro?.slice(0, 10).forEach((val, i) => console.log(`  Hour ${i}: ${val.toFixed(4)} GW`));
                    console.log('potentialGen.naturalGas sample (first 10):');
                    activePotentialGeneration.naturalGas?.slice(0, 10).forEach((val, i) => console.log(`  Hour ${i}: ${val.toFixed(4)} GW`));
                }

                const result = getSimulationResult(inputsForSim, fullSolarProfile, fullWindProfile, fullOffshoreWindProfile, activePotentialGeneration, currentBaselineStorage, currentHydroCF, selectedCountry);
                const resultWithoutStorage = getSimulationResult(inputsForSim, fullSolarProfile, fullWindProfile, fullOffshoreWindProfile, activePotentialGeneration, currentBaselineStorage, currentHydroCF, selectedCountry, true);

                // DEBUG: Log curtailment calculation
                console.log('=== MANUAL MODE RESULT OBJECT ANALYSIS ===');
                console.log('Generation keys:', Object.keys(result.generation));
                console.log('Has curtailment key?', 'curtailment' in result.generation);
                console.log('Curtailment array length:', result.generation.curtailment?.length);
                console.log('Curtailment is all zeros?', result.generation.curtailment?.every(v => v === 0));

                const manualCurtailmentRate = calculateCurtailmentRate(result);
                const totalCurtailmentGWh = result.generation.curtailment.reduce((sum, val, i) => {
                    const monthIndex = Math.floor(i / 24) % 12;
                    return sum + val * DAYS_IN_MONTH[monthIndex];
                }, 0);
                console.log('Manual mode curtailment rate (calculated):', (manualCurtailmentRate * 100).toFixed(2) + '%');
                console.log('Manual mode total curtailment:', totalCurtailmentGWh.toFixed(2), 'GWh/year');
                console.log('Manual mode curtailment sample (hours 10-20, peak solar):');
                const manCurtSample = result.generation.curtailment.slice(10, 20);
                manCurtSample.forEach((val, i) => console.log(`  Hour ${i + 10}: ${val.toFixed(4)} GW`));
                console.log('Manual mode curtailment all hours sum check:');
                const manCurtAllHours = result.generation.curtailment.reduce((sum, val) => sum + val, 0);
                console.log(`  Total hourly curtailment (not annualized): ${manCurtAllHours.toFixed(2)} GWh`);

                // Find WHICH hours have non-zero curtailment
                const hoursWithCurtailment = [];
                result.generation.curtailment.forEach((val, i) => {
                    if (val > 0.001) {
                        hoursWithCurtailment.push({ hour: i, value: val.toFixed(4), month: Math.floor(i / 24) });
                    }
                });
                console.log(`Found ${hoursWithCurtailment.length} hours with curtailment > 0:`, hoursWithCurtailment.slice(0, 20));

                // Check solar + wind generation to see if there's potential for curtailment
                const manSolarGen = result.generation.solar?.slice(10, 20).reduce((sum, v) => sum + v, 0);
                const manWindGen = result.generation.wind?.slice(10, 20).reduce((sum, v) => sum + v, 0);
                console.log(`Manual mode solar gen (hours 10-20): ${manSolarGen?.toFixed(2)} GWh`);
                console.log(`Manual mode wind gen (hours 10-20): ${manWindGen?.toFixed(2)} GWh`);

                // Compare with expected optimization results (if available) - SLIDERS ONLY HERE
                if (window.lastOptimizationResult && (Date.now() - window.expectedOptimizationResults.timestamp) < 10000) {
                    console.log('=== COMPARING WITH OPTIMIZATION RESULTS ===');
                    console.log('Expected solution:', window.expectedOptimizationResults.solution);
                    console.log('Current slider values:');
                    const currentSliderValues = {};
                    for (const tech of OPTIMIZATION_CONFIG.TECHNOLOGIES) {
                        if (sliders[tech]) {
                            currentSliderValues[tech] = parseFloat(sliders[tech].value);
                        }
                    }
                    console.log(JSON.stringify(currentSliderValues, null, 2));

                    // Check if slider values match expected
                    let mismatch = false;
                    for (const tech of OPTIMIZATION_CONFIG.TECHNOLOGIES) {
                        const expected = window.expectedOptimizationResults.solution[tech] || 0;
                        const actual = currentSliderValues[tech] || 0;
                        if (Math.abs(expected - actual) > 0.01) {
                            console.warn(`MISMATCH: ${tech} expected=${expected.toFixed(2)} actual=${actual.toFixed(2)}`);
                            mismatch = true;
                        }
                    }
                    if (!mismatch) {
                        console.log('âœ“ Slider values match expected solution');
                    }
                }

                const totalAnnualSystemCost = result.systemCost;
                const annualConsumerCost = calculateAnnualConsumerCost(result.hourlyMarginalPrice, result.demand);

                const totalAnnualSystemCostBaseline = customBaselineSystemCost;
                const systemCostPercentageChange = totalAnnualSystemCostBaseline > 0 ? ((totalAnnualSystemCost - totalAnnualSystemCostBaseline) / totalAnnualSystemCostBaseline) * 100 : 0;

                const billPercentageChange = customBaselineConsumerCost > 0 ? ((annualConsumerCost - customBaselineConsumerCost) / customBaselineConsumerCost) * 100 : 0;

                // Calculate total annual CO2 by multiplying each hour by days in that month
                let totalAnnualCO2 = 0;
                const hoursPerMonth = 24;
                for (let i = 0; i < result.emissions.length; i++) {
                    const monthIndex = Math.floor(i / hoursPerMonth) % 12;
                    totalAnnualCO2 += result.emissions[i] * DAYS_IN_MONTH[monthIndex];
                }

                // Calculate CO2 avoided and abatement cost
                const co2Avoided = customBaselineTotalAnnualCO2 - totalAnnualCO2;
                const abatementCost = co2Avoided > 0 ? (totalAnnualSystemCost - totalAnnualSystemCostBaseline) / (co2Avoided / 1e9) : 0;

                // CRITICAL: Compare optimization vs manual results (if available)
                if (window.lastOptimizationResult && (Date.now() - window.expectedOptimizationResults.timestamp) < 10000) {
                    console.log('=== SIMULATION RESULTS COMPARISON ===');
                    console.log('Optimization CO2:', (window.lastOptimizationCO2 / 1e9).toFixed(2), 'million MT');
                    console.log('Manual CO2:', (totalAnnualCO2 / 1e9).toFixed(2), 'million MT');
                    console.log('Difference:', ((totalAnnualCO2 - window.lastOptimizationCO2) / 1e9).toFixed(2), 'million MT');
                    console.log('Optimization Curtailment:', (window.lastOptimizationCurtailment * 100).toFixed(2), '%');
                    console.log('Manual Curtailment:', (manualCurtailmentRate * 100).toFixed(2), '%');
                    console.log('Difference:', ((manualCurtailmentRate - window.lastOptimizationCurtailment) * 100).toFixed(2), 'percentage points');

                    if (Math.abs(totalAnnualCO2 - window.lastOptimizationCO2) > 1e6) {
                        console.error('âš ï¸ SIGNIFICANT CO2 MISMATCH! Investigating...');
                        console.log('Storage discharge (hour 15):', result.generation.discharge?.[15]);
                        console.log('Storage charge (hour 15):', result.generation.charge?.[15]);
                    }
                    if (Math.abs(manualCurtailmentRate - window.lastOptimizationCurtailment) > 0.01) {
                        console.error('âš ï¸ SIGNIFICANT CURTAILMENT MISMATCH! Investigating...');
                        console.log('Peak hour (12) demand:', currentDemand[12], 'GW');
                        console.log('Peak hour (12) solar gen:', result.generation.solar?.[12], 'GW');
                        console.log('Peak hour (12) total gen:', Object.keys(result.generation).filter(k => k !== 'curtailment').map(k => result.generation[k]?.[12] || 0).reduce((a, b) => a + b, 0), 'GW');
                    }
                }

                updateCharts(result.generation, result.emissions, result.demand, totalAnnualCO2, fullSolarProfile, fullWindProfile, fullOffshoreWindProfile, result.hourlyMarginalPrice, resultWithoutStorage.hourlyMarginalPrice);

                updateGridMixSlider(currentCountryInstalledCapacity, defaultCapacityMix);
                updateGenerationMixSlider(result.generation, defaultGenerationMix, result.curtailmentBySource);

                billImpactEl.textContent = `${billPercentageChange > 0 ? '+' : ''}${billPercentageChange.toFixed(0)}%`;
                systemCostImpactEl.textContent = `${systemCostPercentageChange > 0 ? '+' : ''}${systemCostPercentageChange.toFixed(0)}%`;

                [billImpactEl, systemCostImpactEl].forEach((el, index) => {
                    const change = index === 0 ? billPercentageChange : systemCostPercentageChange;
                    if (change > 0) {
                        el.className = 'text-5xl font-bold text-red-600 mt-2';
                    } else if (change < 0) {
                        el.className = 'text-5xl font-bold text-green-600 mt-2';
                    } else {
                        el.className = 'text-5xl font-bold text-blue-600 mt-2';
                    }
                });

                // Display CO2 Avoided
                const co2AvoidedPercent = customBaselineTotalAnnualCO2 > 0 ? (co2Avoided / customBaselineTotalAnnualCO2) * 100 : 0;

                if (Math.abs(co2Avoided) < 1000) { // 1000 kg = 1 ton tolerance
                    co2AvoidedEl.textContent = `CO2 avoided: 0 tons (0%)`;
                    co2AvoidedEl.className = 'text-md font-medium text-gray-700';
                } else {
                    let text = `CO2 avoided: ${(co2Avoided / 1e9).toFixed(1)}M tons (${co2AvoidedPercent.toFixed(0)}%)`;
                    if (co2Avoided > 0) {
                        text += ` at $${abatementCost.toFixed(0)}/ton`;
                    }
                    co2AvoidedEl.textContent = text;
                    co2AvoidedEl.className = co2Avoided > 0 ? 'text-md font-medium text-green-600' : 'text-md font-medium text-red-600';
                }
            }

            function calculateEmissions(generation, dacRate) {
                const co2 = [];
                const numHours = generation.naturalGas.length;
                for (let i = 0; i < numHours; i++) {
                    let hourlyEmission = 0;
                    if (EMISSION_FACTORS) {
                        // Generation is in GW, emission factors are in kg/MWh
                        // Need to multiply by 1000 to convert GW to MW
                        hourlyEmission += (generation.naturalGas[i] || 0) * 1000 * EMISSION_FACTORS.naturalGas;
                        hourlyEmission += (generation.coal[i] || 0) * 1000 * EMISSION_FACTORS.coal;
                        hourlyEmission += (generation.biomass[i] || 0) * 1000 * EMISSION_FACTORS.biomass;
                    } else {
                        // Fallback
                        hourlyEmission += (generation.naturalGas[i] || 0) * 1000 * 0.45;
                        hourlyEmission += (generation.coal[i] || 0) * 1000 * 1.0;
                    }
                    hourlyEmission -= dacRate;
                    co2.push(Math.max(0, hourlyEmission));
                }
                return co2;
            }

            function updateCharts(generation, emissions, demand, totalAnnualCO2, solarProfile, windProfile, offshoreWindProfile, hourlyMarginalPrice, priceWithoutStorage) {
                const chartData = generationChart.data.datasets;

                const techMap = {
                    nuclear: 0, geothermal: 1, biomass: 2, rng: 3, hydrogen: 4, hydro: 5,
                    wind: 6, offshoreWind: 7, solar: 8,
                    naturalGas: 9, coal: 10, storage: 11,
                    solarToStorage: 12, windToStorage: 13, offshoreWindToStorage: 14, curtailment: 15
                };

                for (const tech in techMap) {
                    if (generation[tech]) {
                        chartData[techMap[tech]].data = generation[tech];
                    }
                }
                chartData[16].data = demand;

                generationChart.update('none');

                // Update marginal price chart
                marginalPriceChart.data.datasets[0].data = hourlyMarginalPrice;
                marginalPriceChart.data.datasets[1].data = priceWithoutStorage;
                marginalPriceChart.update('none');

                // Update CO2 chart (Monthly Bar Chart)
                const monthlyEmissions = Array(12).fill(0);
                // emissions is length 288 (hourly rates t/hr)
                for (let i = 0; i < emissions.length; i++) {
                    const monthIndex = Math.floor(i / 24) % 12;
                    monthlyEmissions[monthIndex] += emissions[i] * DAYS_IN_MONTH[monthIndex];
                }

                co2Chart.data.datasets[0].data = monthlyEmissions;
                if (co2Chart.options.plugins.annotation && co2Chart.options.plugins.annotation.annotations.totalCO2) {
                    co2Chart.options.plugins.annotation.annotations.totalCO2.content = `Total Annual CO2: ${(totalAnnualCO2 / 1e9).toFixed(2)} Million Tons`;
                }
                co2Chart.update('none');

                capacityFactorChart.data.datasets[0].data = solarProfile;
                capacityFactorChart.data.datasets[1].data = windProfile;
                capacityFactorChart.data.datasets[2].data = offshoreWindProfile;
                capacityFactorChart.update('none');
            }

            function updateGridMixSlider(installedCapacity, defaultMix) {
                const capacities = {};
                let totalCapacity = 0;

                for (const tech in COST_DATA.capacity_factor) {
                    const baselineCapacity = installedCapacity[tech] || 0;
                    let newCapacity = 0;
                    if (sliders[tech]) {
                        newCapacity = parseFloat(sliders[tech].value);
                    }
                    capacities[tech] = baselineCapacity + newCapacity;
                    totalCapacity += capacities[tech];
                }

                if (totalCapacity > 0) {
                    for (const tech in capacities) {
                        if (COST_DATA.capacity_factor[tech]) { // Only for generators
                            const percentage = (capacities[tech] / totalCapacity) * 100;
                            const fillEl = document.getElementById(`mix-fill-${tech}`);
                            const valueEl = document.getElementById(`mix-value-${tech}`);
                            const outlineEl = document.getElementById(`mix-default-outline-${tech}`);

                            if (fillEl && valueEl) {
                                fillEl.style.width = `${percentage}%`;
                                valueEl.textContent = `${percentage.toFixed(1)}%`;
                            }
                            if (outlineEl && defaultMix[tech] !== undefined) {
                                outlineEl.style.width = `${defaultMix[tech]}%`;
                            }
                        }
                    }
                }

                // Update storage display
                ['battery4hr', 'battery8hr', 'longduration'].forEach(type => {
                    const baselineGWh = currentBaselineStorage[type] || 0;
                    const newGWh = parseFloat(sliders[type].value);
                    const totalGWh = baselineGWh + newGWh;
                    const duration = type === 'longduration' ? 24 : parseInt(type.match(/\d+/)[0]);
                    const totalGW = totalGWh / duration;
                    const displayEl = document.getElementById(`storage-capacity-${type}`);
                    if (displayEl) {
                        displayEl.textContent = `${totalGW.toFixed(2)} GW / ${totalGWh.toFixed(2)} GWh`;
                    }
                });
            }

            function createGridMixSliders() {
                const techOrder = ['coal', 'naturalGas', 'solar', 'hydro', 'wind', 'offshoreWind', 'nuclear', 'geothermal', 'biomass', 'rng', 'hydrogen'];
                techOrder.forEach(tech => {
                    let name = tech.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                    if (tech === 'wind') name = 'Onshore Wind';
                    if (tech === 'offshoreWind') name = 'Offshore Wind';
                    if (tech === 'rng') name = 'RNG (Biogas)';
                    if (tech === 'hydrogen') name = 'Hydrogen';

                    const color = COLORS[tech] || '#ccc';

                    const wrapper = document.createElement('div');
                    wrapper.className = 'grid grid-cols-6 gap-2 items-center mix-slider-row';
                    wrapper.dataset.tech = tech;

                    const checkboxContainer = document.createElement('div');
                    checkboxContainer.className = "flex items-center justify-center";
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `toggle-${tech}`;
                    checkbox.checked = true;
                    checkbox.className = "form-checkbox h-5 w-5 text-blue-600 rounded";
                    checkbox.addEventListener('change', () => {
                        enabledTechnologies[tech] = checkbox.checked;
                        runSimulation();
                        saveState();
                    });
                    checkboxContainer.appendChild(checkbox);
                    wrapper.appendChild(checkboxContainer);

                    const label = document.createElement('label');
                    label.textContent = name;
                    label.className = 'col-span-1 text-sm font-medium text-gray-700';
                    wrapper.appendChild(label);

                    const sliderContainer = document.createElement('div');
                    sliderContainer.className = 'col-span-3';
                    const track = document.createElement('div');
                    track.className = 'mix-slider-track';
                    const fill = document.createElement('div');
                    fill.id = `mix-fill-${tech}`;
                    fill.className = 'mix-slider-fill';
                    fill.style.backgroundColor = color;
                    const outline = document.createElement('div');
                    outline.id = `mix-default-outline-${tech}`;
                    outline.className = 'mix-slider-default-outline';
                    track.appendChild(fill);
                    track.appendChild(outline);
                    sliderContainer.appendChild(track);
                    wrapper.appendChild(sliderContainer);

                    const value = document.createElement('span');
                    value.id = `mix-value-${tech}`;
                    value.className = 'col-span-1 text-sm font-semibold text-right';
                    value.textContent = '0.0%';
                    wrapper.appendChild(value);

                    gridMixSlidersContainer.appendChild(wrapper);
                });

                // Create storage section
                const storageHeader = document.createElement('h3');
                storageHeader.className = 'text-lg font-lora font-semibold mt-6 mb-2 text-gray-800';
                storageHeader.textContent = 'Installed Storage Capacity';
                storageCapacityDisplayContainer.appendChild(storageHeader);

                const storageTypes = [
                    { id: 'battery4hr', name: '4-hr Battery' },
                    { id: 'battery8hr', name: '8-hr Battery' },
                    { id: 'longduration', name: '24-hr Storage' }
                ];

                storageTypes.forEach(type => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'grid grid-cols-6 gap-2 items-center';

                    const checkboxContainer = document.createElement('div');
                    checkboxContainer.className = "flex items-center justify-center";
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `toggle-${type.id}`;
                    checkbox.checked = true;
                    checkbox.className = "form-checkbox h-5 w-5 text-blue-600 rounded";
                    checkbox.addEventListener('change', () => {
                        enabledTechnologies[type.id] = checkbox.checked;
                        runSimulation();
                        saveState();
                    });
                    checkboxContainer.appendChild(checkbox);
                    wrapper.appendChild(checkboxContainer);

                    const label = document.createElement('label');
                    label.textContent = type.name;
                    label.className = 'col-span-2 text-sm font-medium text-gray-700';
                    wrapper.appendChild(label);

                    const value = document.createElement('span');
                    value.id = `storage-capacity-${type.id}`;
                    value.className = 'col-span-3 text-sm font-semibold text-right';
                    value.textContent = '0.00 GW / 0.00 GWh';
                    wrapper.appendChild(value);

                    storageCapacityDisplayContainer.appendChild(wrapper);
                });
            }

            // --- GENERATION MIX SLIDER ---
            function updateGenerationMixSlider(generation, defaultMix, curtailmentBySource) {
                yearlyGenerationTotalsGWh = {}; // Clear previous totals
                let totalGeneration = 0;

                const gridTechs = ['coal', 'naturalGas', 'hydro', 'geothermal', 'biomass', 'rng', 'hydrogen', 'nuclear', 'solar', 'wind', 'offshoreWind', 'storage'];
                gridTechs.forEach(tech => {
                    // Calculate yearly total by multiplying each hour by days in that month
                    let techTotal = 0;
                    (generation[tech] || []).forEach((value, i) => {
                        const monthIndex = Math.floor(i / 24) % 12;
                        techTotal += value * DAYS_IN_MONTH[monthIndex];
                    });
                    yearlyGenerationTotalsGWh[tech] = techTotal;
                    totalGeneration += techTotal;
                });

                if (totalGeneration > 0) {
                    gridTechs.forEach(tech => {
                        const percentage = (yearlyGenerationTotalsGWh[tech] / totalGeneration) * 100;
                        const fillEl = document.getElementById(`gen-mix-fill-${tech}`);
                        const valueEl = document.getElementById(`gen-mix-value-${tech}`);
                        const outlineEl = document.getElementById(`gen-mix-default-outline-${tech}`);

                        if (fillEl && valueEl) {
                            fillEl.style.width = `${percentage}%`;
                            valueEl.textContent = `${percentage.toFixed(1)}%`;
                        }
                        if (outlineEl && defaultMix[tech] !== undefined) {
                            outlineEl.style.width = `${defaultMix[tech]}%`;
                        }
                    });
                } else {
                    gridTechs.forEach(tech => {
                        const fillEl = document.getElementById(`gen-mix-fill-${tech}`);
                        const valueEl = document.getElementById(`gen-mix-value-${tech}`);
                        if (fillEl && valueEl) {
                            fillEl.style.width = '0%';
                            valueEl.textContent = '0.0%';
                        }
                    });
                }

                const curtailmentTrack = document.getElementById('gen-mix-track-curtailment');
                const curtailmentValue = document.getElementById('gen-mix-value-curtailment');
                curtailmentTrack.innerHTML = '';

                // Calculate yearly curtailment by multiplying each hour by days in that month
                let totalCurtailed = 0;
                (generation.curtailment || []).forEach((value, i) => {
                    const monthIndex = Math.floor(i / 24) % 12;
                    totalCurtailed += value * DAYS_IN_MONTH[monthIndex];
                });
                yearlyGenerationTotalsGWh['curtailment'] = totalCurtailed;

                // Calculate yearly storage charging
                let solarToStorageTotal = 0, windToStorageTotal = 0, offshoreWindToStorageTotal = 0;
                (generation.solarToStorage || []).forEach((value, i) => {
                    const monthIndex = Math.floor(i / 24) % 12;
                    solarToStorageTotal += value * DAYS_IN_MONTH[monthIndex];
                });
                (generation.windToStorage || []).forEach((value, i) => {
                    const monthIndex = Math.floor(i / 24) % 12;
                    windToStorageTotal += value * DAYS_IN_MONTH[monthIndex];
                });
                (generation.offshoreWindToStorage || []).forEach((value, i) => {
                    const monthIndex = Math.floor(i / 24) % 12;
                    offshoreWindToStorageTotal += value * DAYS_IN_MONTH[monthIndex];
                });

                let totalPotentialGeneration = totalGeneration + totalCurtailed + solarToStorageTotal + windToStorageTotal + offshoreWindToStorageTotal;

                if (totalPotentialGeneration > 0) {
                    const overallCurtailmentPercent = (totalCurtailed / totalPotentialGeneration) * 100;
                    curtailmentValue.textContent = `${overallCurtailmentPercent.toFixed(1)}%`;

                    if (totalCurtailed > 0) {
                        // Calculate yearly curtailment by source
                        let solarCurtail = 0, windCurtail = 0, offshoreWindCurtail = 0;
                        (curtailmentBySource.solar || []).forEach((value, i) => {
                            const monthIndex = Math.floor(i / 24) % 12;
                            solarCurtail += value * DAYS_IN_MONTH[monthIndex];
                        });
                        (curtailmentBySource.wind || []).forEach((value, i) => {
                            const monthIndex = Math.floor(i / 24) % 12;
                            windCurtail += value * DAYS_IN_MONTH[monthIndex];
                        });
                        (curtailmentBySource.offshoreWind || []).forEach((value, i) => {
                            const monthIndex = Math.floor(i / 24) % 12;
                            offshoreWindCurtail += value * DAYS_IN_MONTH[monthIndex];
                        });

                        const techWithCurtailment = [{ tech: 'solar', val: solarCurtail }, { tech: 'wind', val: windCurtail }, { tech: 'offshoreWind', val: offshoreWindCurtail }];

                        techWithCurtailment.forEach(item => {
                            if (item.val > 0) {
                                const contributionPercent = (item.val / totalCurtailed);
                                const segmentWidth = 100 * contributionPercent;

                                const segment = document.createElement('div');
                                segment.className = 'h-full';
                                segment.style.backgroundColor = COLORS[item.tech];
                                segment.style.width = `${segmentWidth}%`;
                                segment.style.float = 'left';
                                curtailmentTrack.appendChild(segment);
                            }
                        });
                        curtailmentTrack.parentElement.style.width = `${overallCurtailmentPercent}%`;
                    } else {
                        curtailmentTrack.parentElement.style.width = `0%`;
                    }
                } else {
                    curtailmentValue.textContent = '0.0%';
                    curtailmentTrack.parentElement.style.width = `0%`;
                }
            }

            function createGenerationMixSliders() {
                const techOrder = ['coal', 'naturalGas', 'solar', 'hydro', 'wind', 'offshoreWind', 'nuclear', 'geothermal', 'biomass', 'rng', 'hydrogen', 'storage'];
                techOrder.forEach(tech => {
                    let name = tech.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                    if (tech === 'wind') name = 'Onshore Wind';
                    if (tech === 'offshoreWind') name = 'Offshore Wind';
                    if (tech === 'rng') name = 'RNG (Biogas)';
                    if (tech === 'hydrogen') name = 'Hydrogen';
                    const color = COLORS[tech] || '#ccc';

                    const wrapper = document.createElement('div');
                    wrapper.className = 'grid grid-cols-5 gap-2 items-center mix-slider-row';
                    wrapper.dataset.tech = tech;

                    const label = document.createElement('label');
                    label.textContent = name;
                    label.className = 'col-span-1 text-sm font-medium text-gray-700';
                    wrapper.appendChild(label);

                    const sliderContainer = document.createElement('div');
                    sliderContainer.className = 'col-span-3';
                    const track = document.createElement('div');
                    track.className = 'mix-slider-track';
                    const fill = document.createElement('div');
                    fill.id = `gen-mix-fill-${tech}`;
                    fill.className = 'mix-slider-fill';
                    fill.style.backgroundColor = color;
                    const outline = document.createElement('div');
                    outline.id = `gen-mix-default-outline-${tech}`;
                    outline.className = 'mix-slider-default-outline';
                    track.appendChild(fill);
                    track.appendChild(outline);
                    sliderContainer.appendChild(track);
                    wrapper.appendChild(sliderContainer);

                    const value = document.createElement('span');
                    value.id = `gen-mix-value-${tech}`;
                    value.className = 'col-span-1 text-sm font-semibold text-right';
                    value.textContent = '0.0%';
                    wrapper.appendChild(value);

                    generationMixSlidersContainer.appendChild(wrapper);
                });

                const wrapper = document.createElement('div');
                wrapper.className = 'grid grid-cols-5 gap-2 items-center mix-slider-row';
                wrapper.dataset.tech = 'curtailment';
                const label = document.createElement('label');
                label.textContent = 'Curtailment';
                label.className = 'col-span-1 text-sm font-medium text-gray-700';
                wrapper.appendChild(label);
                const sliderContainer = document.createElement('div');
                sliderContainer.className = 'col-span-3';
                const outerTrack = document.createElement('div');
                outerTrack.className = 'mix-slider-track';
                const innerTrack = document.createElement('div');
                innerTrack.id = 'gen-mix-track-curtailment';
                innerTrack.className = 'h-full w-full';
                outerTrack.appendChild(innerTrack);
                sliderContainer.appendChild(outerTrack);
                wrapper.appendChild(sliderContainer);
                const value = document.createElement('span');
                value.id = `gen-mix-value-curtailment`;
                value.className = 'col-span-1 text-sm font-semibold text-right';
                value.textContent = '0.0%';
                wrapper.appendChild(value);
                generationMixSlidersContainer.appendChild(wrapper);
            }

            // --- HELPER: Calculate minimum demand based on inflexible baseload ---
            function calculateMinimumDemand() {
                const INFLEXIBLE_SOURCES = ['nuclear', 'geothermal', 'biomass', 'rng', 'hydrogen'];
                const currentValues = {};
                for (const key in sliders) {
                    currentValues[key] = parseFloat(sliders[key].value);
                }

                let minDemand = 0;
                INFLEXIBLE_SOURCES.forEach(tech => {
                    const baselineCapacity = currentCountryInstalledCapacity[tech] || 0;
                    const newCapacity = currentValues[tech] || 0;
                    const totalCapacity = baselineCapacity + newCapacity;
                    const cf = COST_DATA.capacity_factor[tech] || 0;
                    minDemand += totalCapacity * cf;
                });
                return minDemand;
            }

            // --- DEMAND EDIT MODE ---
            function setDemandEditMode(enabled) {
                isDemandEditMode = enabled;
                const demandDatasetIndex = generationChart.data.datasets.findIndex(ds => ds.label === 'Demand');

                if (enabled) {
                    if (editDemandBtn) editDemandBtn.classList.add('hidden');
                    if (confirmDemandBtn) confirmDemandBtn.classList.remove('hidden');
                    if (revertDemandBtn) revertDemandBtn.classList.remove('hidden');
                    if (demandPresetsDiv) demandPresetsDiv.classList.remove('hidden');

                    document.querySelectorAll('#demand-presets button').forEach(btn => {
                        btn.classList.remove('preset-active');
                        if (btn.id === `preset-demand-${currentDemandProfileName.toLowerCase().replace(' ', '-')}`) {
                            btn.classList.add('preset-active');
                        }
                    });

                    generationChart.data.datasets.forEach((dataset, index) => {
                        if (index !== demandDatasetIndex) {
                            dataset.hidden = true;
                        } else {
                            dataset.borderWidth = 4;
                            dataset.pointRadius = 6;
                            dataset.pointHoverRadius = 8;
                            dataset.pointBackgroundColor = 'rgba(17, 24, 39, 1)';
                            dataset.pointBorderColor = 'white';
                            dataset.pointBorderWidth = 2;
                        }
                    });

                    generationChart.options.plugins.dragData = {
                        round: 1,
                        showTooltip: true,
                        onDrag: function (e, datasetIndex, index, value) {
                            // Enforce constraints DURING dragging for real-time feedback
                            const minDemand = calculateMinimumDemand();

                            if (value < minDemand) {
                                return minDemand;
                            }
                            if (value < 0) {
                                return 0;
                            }
                            return value;
                        },
                        onDragEnd: function (e, datasetIndex, index, value) {
                            const chart = e.chart;
                            let updatedValue = value;

                            // Calculate minimum demand based on inflexible baseload
                            const minDemand = calculateMinimumDemand();

                            // Enforce minimum demand constraint
                            if (updatedValue < minDemand) {
                                updatedValue = minDemand;
                            }

                            // Enforce non-negative constraint
                            if (updatedValue < 0) {
                                updatedValue = 0;
                            }

                            chart.data.datasets[datasetIndex].data[index] = updatedValue;
                            generationChart.update('none');
                        }
                    };
                    generationChart.options.plugins.dragData.enabled = true;
                    generationChart.options.scales.y.stacked = false;
                    generationChart.update();

                } else {
                    if (editDemandBtn) editDemandBtn.classList.remove('hidden');
                    if (confirmDemandBtn) confirmDemandBtn.classList.add('hidden');
                    if (revertDemandBtn) revertDemandBtn.classList.add('hidden');
                    if (demandPresetsDiv) demandPresetsDiv.classList.add('hidden');

                    generationChart.data.datasets.forEach((dataset, index) => {
                        dataset.hidden = false;
                        if (index === demandDatasetIndex) {
                            dataset.borderWidth = 3;
                            dataset.pointRadius = 0;
                            dataset.pointHoverRadius = 0;
                        }
                    });

                    if (generationChart.options.plugins.dragData) {
                        generationChart.options.plugins.dragData.enabled = false;
                        generationChart.options.plugins.dragData.onDragEnd = null;
                    }
                    generationChart.options.scales.y.stacked = true;
                    generationChart.update();
                }
            }

            // --- CF EDIT MODE ---
            function setCFEditMode(enabled) {
                isCFEditMode = enabled;

                if (enabled) {
                    if (editCFBtn) editCFBtn.classList.add('hidden');
                    if (confirmCFBtn) confirmCFBtn.classList.remove('hidden');
                    if (revertCFBtn) revertCFBtn.classList.remove('hidden');
                    capacityFactorChart.data.datasets.forEach(dataset => {
                        dataset.pointRadius = 6;
                        dataset.pointHoverRadius = 8;
                        dataset.pointBorderColor = 'white';
                        dataset.pointBorderWidth = 2;
                        dataset.dragData = true;
                    });

                } else {
                    if (editCFBtn) editCFBtn.classList.remove('hidden');
                    if (confirmCFBtn) confirmCFBtn.classList.add('hidden');
                    if (revertCFBtn) revertCFBtn.classList.add('hidden');

                    capacityFactorChart.data.datasets.forEach(dataset => {
                        dataset.pointRadius = 0;
                        dataset.dragData = false;
                    });
                }
                capacityFactorChart.update();
            }

            // --- NEW: Function to set the baseline from the current state ---
            // Returns the simulation result to avoid running the simulation twice
            function setNewBaselineFromCurrentState() {
                const currentValues = {};
                for (const key in sliders) {
                    currentValues[key] = parseFloat(sliders[key].value);
                }

                let activePotentialGeneration = JSON.parse(JSON.stringify(BASELINE_POTENTIAL_GENERATION));
                for (const tech in enabledTechnologies) {
                    if (!enabledTechnologies[tech]) {
                        activePotentialGeneration[tech] = Array(24).fill(0);
                    }
                }

                const newBaselineResult = getSimulationResult(
                    {
                        capacity: {
                            solar: currentValues.solar, wind: currentValues.wind, offshoreWind: currentValues.offshoreWind,
                            geothermal: currentValues.geothermal, nuclear: currentValues.nuclear,
                            biomass: currentValues.biomass, rng: currentValues.rng, hydrogen: currentValues.hydrogen,
                            battery4hr: currentValues.battery4hr, battery8hr: currentValues.battery8hr,
                            longduration: currentValues.longduration, dac: currentValues.dac,
                            demandflex: currentValues.demandflex,
                        },
                        incentives: {
                            solar: currentValues.solarIncentive, wind: currentValues.windIncentive, offshoreWind: currentValues.offshoreWindIncentive,
                            geothermal: currentValues.geothermalIncentive, nuclear: currentValues.nuclearIncentive,
                            biomass: currentValues.biomassIncentive, rng: currentValues.rngIncentive, hydrogen: currentValues.hydrogenIncentive,
                            storage: currentValues.storageIncentive, dac: currentValues.dacIncentive,
                            carbonTax: currentValues.carbonTax,
                            exportPrice: currentValues.exportPrice,
                        }
                    },
                    currentSolarCFProfile,
                    currentWindCFProfile,
                    currentOffshoreWindCFProfile,
                    activePotentialGeneration,
                    currentBaselineStorage,
                    currentHydroCF,
                    countrySelect.value
                );

                customBaselineSystemCost = newBaselineResult.systemCost;
                customBaselineConsumerCost = calculateAnnualConsumerCost(newBaselineResult.hourlyMarginalPrice, newBaselineResult.demand);
                // Calculate yearly CO2 by multiplying each hour by days in that month
                let co2Total = 0;
                newBaselineResult.emissions.forEach((value, i) => {
                    const monthIndex = Math.floor(i / 24) % 12;
                    co2Total += value * DAYS_IN_MONTH[monthIndex];
                });
                customBaselineTotalAnnualCO2 = co2Total;

                // Return the simulation result so we can display it without re-running
                return newBaselineResult;
            }

            // --- EVENT LISTENERS ---
            function updateUndoRedoButtons() {
                undoButton.disabled = historyIndex <= 0;
                redoButton.disabled = historyIndex >= stateHistory.length - 1;
            }

            function saveState() {
                const currentState = {};
                for (const key in sliders) {
                    currentState[key] = sliders[key].value;
                }
                currentState.enabledTech = { ...enabledTechnologies };
                currentState.demandProfile = [...currentDemand];
                currentState.solarCFProfile = [...currentSolarCFProfile];
                currentState.windCFProfile = [...currentWindCFProfile];
                currentState.offshoreWindCFProfile = [...currentOffshoreWindCFProfile];
                currentState.demandProfileName = currentDemandProfileName;
                currentState.cfProfileName = currentCFProfileName;
                currentState.hydroCF = currentHydroCF;

                stateHistory = stateHistory.slice(0, historyIndex + 1);
                stateHistory.push(currentState);
                historyIndex++;
                updateUndoRedoButtons();
            }

            function syncInputs(sourceElement, targetElement) {
                targetElement.value = sourceElement.value;
            }

            function setupInputSyncing() {
                for (const key in sliders) {
                    const slider = sliders[key];
                    const input = inputs[key];

                    // All sliders behave the same way - just run simulation
                    // Baseline only updates when "Make Default" is clicked
                    slider.addEventListener('input', () => {
                        syncInputs(slider, input);
                        runSimulation();
                    });

                    input.addEventListener('input', () => {
                        let value = parseFloat(input.value);
                        const min = parseFloat(slider.min);
                        const max = parseFloat(slider.max);
                        if (isNaN(value)) value = min;
                        if (value > max) value = max;
                        if (value < min) value = min;
                        input.value = value;
                        syncInputs(input, slider);
                        runSimulation();
                    });

                    slider.addEventListener('change', saveState);
                    input.addEventListener('change', saveState);
                }
            }


            function applySeason(profileName) {
                currentSystemDefaultProfileName = profileName;
                const nameParts = profileName.split('-');
                const baseSeason = nameParts[0];
                const profileDisplayName = nameParts.map(s => s.charAt(0).toUpperCase() + s.slice(1)).join(' ');

                currentDemandProfileName = profileDisplayName;
                if (currentDemandProfileText) currentDemandProfileText.textContent = currentDemandProfileName;

                const cfProfileDisplayName = baseSeason.charAt(0).toUpperCase() + baseSeason.slice(1);
                const seasonalMultipliers = SEASONAL_MULTIPLIERS[baseSeason];
                const baseSolarProfile = (countryProfiles[countrySelect.value] || countryProfiles.default).solar;
                const baseWindProfile = (countryProfiles[countrySelect.value] || countryProfiles.default).wind;
                const baseOffshoreWindProfile = (countryProfiles[countrySelect.value] || countryProfiles.default).offshoreWind;
                currentSolarCFProfile = baseSolarProfile.map(cf => Math.min(1, cf * seasonalMultipliers.solar));
                currentWindCFProfile = baseWindProfile.map(cf => Math.min(1, cf * seasonalMultipliers.wind));
                currentOffshoreWindCFProfile = baseOffshoreWindProfile.map(cf => Math.min(1, cf * seasonalMultipliers.offshoreWind));
                currentHydroCF = SEASONAL_HYDRO_CF[baseSeason];
                currentCFProfileName = cfProfileDisplayName;

                updateBaselineForCountry(countrySelect.value, profileName);

                setDemandEditMode(false);
                setCFEditMode(false);
                saveState();
            }



            if (editDemandBtn) {
                editDemandBtn.addEventListener('click', () => {
                    originalDemandBeforeEdit = [...currentDemand];
                    setDemandEditMode(true);
                });
            }

            if (revertDemandBtn) {
                revertDemandBtn.addEventListener('click', () => {
                    generationChart.data.datasets.find(ds => ds.label === 'Demand').data = [...originalDemandBeforeEdit];
                    generationChart.update('none');
                });
            }

            if (confirmDemandBtn) {
                confirmDemandBtn.addEventListener('click', () => {
                    currentDemand = [...generationChart.data.datasets.find(ds => ds.label === 'Demand').data];
                    currentDemandProfileName = "User Defined";
                    currentDemandProfileText.textContent = currentDemandProfileName;
                    setDemandEditMode(false);
                    runSimulation();
                    saveState();
                });
            }

            const demandProfiles = [
                'spring-typical', 'spring-high', 'summer-typical', 'summer-high',
                'fall-typical', 'fall-high', 'winter-typical', 'winter-high'
            ];
            demandProfiles.forEach(profile => {
                const btn = document.getElementById(`preset-demand-${profile}`);
                if (btn) btn.addEventListener('click', () => applySeason(profile));
            });

            ['spring', 'summer', 'fall', 'winter'].forEach(season => {
                const btn = document.getElementById(`preset-cf-${season}`);
                if (btn) btn.addEventListener('click', () => {
                    applySeason(`${season}-typical`);
                });
            });

            if (editCFBtn) {
                editCFBtn.addEventListener('click', () => {
                    originalSolarCFBeforeEdit = [...capacityFactorChart.data.datasets[0].data];
                    originalWindCFBeforeEdit = [...capacityFactorChart.data.datasets[1].data];
                    originalOffshoreWindCFBeforeEdit = [...capacityFactorChart.data.datasets[2].data];
                    setCFEditMode(true);
                });
            }

            if (revertCFBtn) {
                revertCFBtn.addEventListener('click', () => {
                    capacityFactorChart.data.datasets[0].data = [...originalSolarCFBeforeEdit];
                    capacityFactorChart.data.datasets[1].data = [...originalWindCFBeforeEdit];
                    capacityFactorChart.data.datasets[2].data = [...originalOffshoreWindCFBeforeEdit];
                    capacityFactorChart.update('none');
                });
            }

            if (confirmCFBtn) {
                confirmCFBtn.addEventListener('click', () => {
                    currentSolarCFProfile = [...capacityFactorChart.data.datasets[0].data];
                    currentWindCFProfile = [...capacityFactorChart.data.datasets[1].data];
                    currentOffshoreWindCFProfile = [...capacityFactorChart.data.datasets[2].data];
                    currentCFProfileName = "User Defined";

                    setCFEditMode(false);
                    runSimulation();
                    saveState();
                });
            }



            resetToZeroButton.addEventListener('click', () => {
                Object.keys(sliders).forEach(key => {
                    if (key === 'exportPrice') {
                        sliders[key].value = 20;
                        inputs[key].value = 20;
                    } else {
                        sliders[key].value = 0;
                        inputs[key].value = 0;
                    }
                });
                runSimulation();
                saveState();
            });

            makeDefaultButton.addEventListener('click', () => {
                userDefaultState = {};
                for (const key in sliders) {
                    userDefaultState[key] = sliders[key].value;
                }
                userDefaultState.enabledTech = { ...enabledTechnologies };
                userDefaultState.demandProfile = [...currentDemand];
                userDefaultState.solarCFProfile = [...currentSolarCFProfile];
                userDefaultState.windCFProfile = [...currentWindCFProfile];
                userDefaultState.offshoreWindCFProfile = [...currentOffshoreWindCFProfile];
                userDefaultState.demandProfileName = currentDemandProfileName;
                userDefaultState.cfProfileName = currentCFProfileName;
                userDefaultState.hydroCF = currentHydroCF;

                // Set the new baseline (runs simulation once)
                setNewBaselineFromCurrentState();

                userDefaultState.baselineCost = customBaselineSystemCost;
                userDefaultState.baselineCO2 = customBaselineTotalAnnualCO2;

                // Run normal simulation to update display
                // This may show 1-2% difference due to iterative optimization, which is acceptable
                runSimulation();

                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50';
                modal.innerHTML = `
                    <div class="bg-white p-6 rounded-lg shadow-2xl text-center">
                        <p class="text-lg font-semibold text-gray-800">Current settings saved as user default.</p>
                    </div>
                `;
                document.body.appendChild(modal);
                setTimeout(() => modal.remove(), 2500);
            });

            resetToDefaultButton.addEventListener('click', () => {
                const isUserDefaultAvailable = Object.keys(userDefaultState).length > 0;

                if (isUserDefaultAvailable) {
                    restoreState(userDefaultState);
                    saveState();
                } else {
                    applySeason(currentSystemDefaultProfileName);
                }
            });

            function restoreState(state) {
                currentDemand = [...state.demandProfile];
                currentSolarCFProfile = [...state.solarCFProfile];
                currentWindCFProfile = [...state.windCFProfile];
                currentOffshoreWindCFProfile = [...state.offshoreWindCFProfile];
                currentDemandProfileName = state.demandProfileName;
                currentCFProfileName = state.cfProfileName;
                currentHydroCF = state.hydroCF;
                currentDemandProfileText.textContent = currentDemandProfileName;

                for (const key in state) {
                    if (sliders[key] && inputs[key]) {
                        sliders[key].value = state[key];
                        inputs[key].value = state[key];
                    }
                }
                if (state.enabledTech) {
                    for (const tech in state.enabledTech) {
                        const checkbox = document.getElementById(`toggle-${tech}`);
                        if (checkbox) {
                            checkbox.checked = state.enabledTech[tech];
                            enabledTechnologies[tech] = state.enabledTech[tech];
                        }
                    }
                }
                runSimulation();
                updateUndoRedoButtons();
            }

            undoButton.addEventListener('click', () => {
                if (historyIndex > 0) {
                    historyIndex--;
                    restoreState(stateHistory[historyIndex]);
                }
            });

            redoButton.addEventListener('click', () => {
                if (historyIndex < stateHistory.length - 1) {
                    historyIndex++;
                    restoreState(stateHistory[historyIndex]);
                }
            });

            // --- INITIALIZATION & DYNAMIC CONTENT ---

            function populateCountryDropdown() {
                countrySelect.innerHTML = '';
                const caOption = document.createElement('option');
                caOption.value = "California";
                caOption.textContent = "California";
                countrySelect.appendChild(caOption);

                for (const country in countryGridMixData) {
                    if (country !== "California") {
                        const option = document.createElement('option');
                        option.value = country;
                        option.textContent = country;
                        countrySelect.appendChild(option);
                    }
                }
                countrySelect.value = "California";
            }

            function updateBaselineForCountry(countryName, profileName) {
                let newCarbonTax = 0;
                let countryData = countryGridMixData[countryName];

                if (!countryData) {
                    console.error(`No data for country: ${countryName}`);
                    return;
                }

                newCarbonTax = carbonTaxes[countryName] || 0;

                const nameParts = profileName.split('-');
                const baseSeason = nameParts[0];
                const profileType = nameParts[1];

                if (currentDemandProfileName !== 'User Defined') {
                    // For California, use JSON profiles directly (same calculation as Grid Dispatch Test)
                    if (countryName === 'California' && CALIFORNIA_PROFILES[profileName]) {
                        const profile = CALIFORNIA_PROFILES[profileName];
                        const peakMW = profile.peakMW;
                        const hourlyPercentages = profile.hourlyPercentages;

                        // Match tester's calculation: (pct / 100) * peakMW, then convert to GW
                        currentDemand = hourlyPercentages.map(pct => (pct / 100) * (peakMW / 1000));
                    } else {
                        // For other countries, use scaling approach
                        const TYPICAL_DAY_SCALING_FACTORS = {
                            spring: 0.79, summer: 0.82, fall: 0.77, winter: 0.73
                        };

                        const hourlyPercentages = SEASONAL_DEMAND_PROFILES[profileName] || SEASONAL_DEMAND_PROFILES[`${baseSeason}-high`];
                        const scalingFactor = profileType === 'typical' ? TYPICAL_DAY_SCALING_FACTORS[baseSeason] || 1.0 : 1.0;
                        const peakLoadMW = countryData.peakLoadsMW[baseSeason] || countryData.peakLoadsMW.summer;
                        const peakPercentage = Math.max(...hourlyPercentages);
                        currentDemand = hourlyPercentages.map(pct => (pct / peakPercentage) * (peakLoadMW / 1000) * scalingFactor);
                    }
                }

                currentCountryInstalledCapacity = {};
                for (const tech in COST_DATA.capacity_factor) {
                    const techCapacityGW = (countryData.totalCapacityMW / 1000) * ((countryData.mix[tech] || 0) / 100);
                    currentCountryInstalledCapacity[tech] = techCapacityGW;
                }

                currentBaselineStorage = countryData.storageGWh || {};

                // Get base 24-hour profiles for this country
                const baseProfiles24h = {
                    solar: (countryProfiles[countryName] || countryProfiles.default).solar,
                    wind: (countryProfiles[countryName] || countryProfiles.default).wind,
                    offshoreWind: (countryProfiles[countryName] || countryProfiles.default).offshoreWind
                };

                const potentialGeneration = {};
                for (const tech in currentCountryInstalledCapacity) {
                    potentialGeneration[tech] = Array(24).fill(0);
                    const cf = COST_DATA.capacity_factor[tech];
                    let capacity = currentCountryInstalledCapacity[tech];

                    if (tech === 'solar') {
                        for (let i = 0; i < 24; i++) potentialGeneration.solar[i] = capacity * baseProfiles24h.solar[i];
                    } else if (tech === 'wind') {
                        for (let i = 0; i < 24; i++) potentialGeneration.wind[i] = capacity * baseProfiles24h.wind[i];
                    } else if (tech === 'offshoreWind') {
                        for (let i = 0; i < 24; i++) potentialGeneration.offshoreWind[i] = capacity * baseProfiles24h.offshoreWind[i];
                    } else if (tech === 'hydro') {
                        for (let i = 0; i < 24; i++) potentialGeneration.hydro[i] = capacity;
                    } else if (tech === 'naturalGas' || tech === 'coal') {
                        for (let i = 0; i < 24; i++) potentialGeneration[tech][i] = capacity * 1.0;
                    } else {
                        for (let i = 0; i < 24; i++) potentialGeneration[tech][i] = capacity * cf;
                    }
                }
                BASELINE_POTENTIAL_GENERATION = potentialGeneration;

                Object.keys(sliders).forEach(key => {
                    sliders[key].value = 0;
                    inputs[key].value = 0;
                });

                sliders.carbonTax.value = newCarbonTax;
                inputs.carbonTax.value = newCarbonTax;

                const newExportPrice = countryData.defaultExportPrice ?? 20;
                sliders.exportPrice.value = newExportPrice;
                inputs.exportPrice.value = newExportPrice;

                const allTechs = [...Object.keys(COST_DATA.capacity_factor), 'battery4hr', 'battery8hr', 'longduration'];
                allTechs.forEach(tech => {
                    const checkbox = document.getElementById(`toggle-${tech}`);
                    if (checkbox) {
                        checkbox.checked = true;
                        enabledTechnologies[tech] = true;
                    }
                });

                // Construct 12-month profiles for baseline calculation (matching runSimulation logic)
                const baseProfiles = {
                    solar: (countryProfiles[countryName] || countryProfiles.default).solar,
                    wind: (countryProfiles[countryName] || countryProfiles.default).wind,
                    offshoreWind: (countryProfiles[countryName] || countryProfiles.default).offshoreWind
                };

                const fullSolarProfile = [];
                const fullWindProfile = [];
                const fullOffshoreWindProfile = [];
                const fullDemand = [];
                let fullPotentialGeneration = {};
                for (const tech in BASELINE_POTENTIAL_GENERATION) {
                    fullPotentialGeneration[tech] = [];
                }

                const userSeasonMap = [
                    'winter', 'winter', 'spring', 'spring', 'spring',
                    'summer', 'summer', 'summer', 'summer', 'fall', 'fall', 'winter'
                ];

                const isHighDemand = profileName.toLowerCase().includes('high');

                for (let m = 0; m < 12; m++) {
                    const season = userSeasonMap[m];
                    const seasonalMultipliers = SEASONAL_MULTIPLIERS[season] || { solar: 1.0, wind: 1.0, offshoreWind: 1.0 };

                    const sSolar = baseProfiles.solar.map(cf => Math.min(1, cf * seasonalMultipliers.solar));
                    const sWind = baseProfiles.wind.map(cf => Math.min(1, cf * seasonalMultipliers.wind));
                    const sOffshoreWind = baseProfiles.offshoreWind.map(cf => Math.min(1, cf * seasonalMultipliers.offshoreWind));

                    fullSolarProfile.push(...sSolar);
                    fullWindProfile.push(...sWind);
                    fullOffshoreWindProfile.push(...sOffshoreWind);

                    const demandType = isHighDemand ? 'high' : 'typical';
                    const demandKey = `${season}-${demandType}`;
                    const sDemand = SEASONAL_DEMAND_PROFILES[demandKey] || SEASONAL_DEMAND_PROFILES[`${season}-high`] || Array(24).fill(30);
                    fullDemand.push(...sDemand);

                    // Duplicate potential generation for all 12 months
                    for (const tech in BASELINE_POTENTIAL_GENERATION) {
                        fullPotentialGeneration[tech].push(...(BASELINE_POTENTIAL_GENERATION[tech] || Array(24).fill(0)));
                    }
                }

                currentDemand = fullDemand; // Update global currentDemand

                const baselineResult = getSimulationResult(
                    {
                        capacity: { solar: 0, wind: 0, offshoreWind: 0, geothermal: 0, nuclear: 0, biomass: 0, rng: 0, hydrogen: 0, battery4hr: 0, battery8hr: 0, longduration: 0, dac: 0, demandflex: 0 },
                        incentives: { solar: 0, wind: 0, offshoreWind: 0, geothermal: 0, nuclear: 0, biomass: 0, rng: 0, hydrogen: 0, storage: 0, dac: 0, carbonTax: newCarbonTax, exportPrice: newExportPrice }
                    },
                    fullSolarProfile,
                    fullWindProfile,
                    fullOffshoreWindProfile,
                    fullPotentialGeneration,
                    currentBaselineStorage,
                    currentHydroCF,
                    countryName
                );
                customBaselineSystemCost = baselineResult.systemCost;
                customBaselineConsumerCost = calculateAnnualConsumerCost(baselineResult.hourlyMarginalPrice, baselineResult.demand); // NEW
                // Calculate yearly CO2 by multiplying each hour by days in that month
                let co2Total = 0;
                baselineResult.emissions.forEach((value, i) => {
                    const monthIndex = Math.floor(i / 24) % 12;
                    co2Total += value * DAYS_IN_MONTH[monthIndex];
                });
                customBaselineTotalAnnualCO2 = co2Total;

                systemDefaultState = {};
                for (const key in sliders) {
                    systemDefaultState[key] = sliders[key].value;
                }
                systemDefaultState.enabledTech = { ...enabledTechnologies };
                userDefaultState = {};

                let totalDefaultCapacity = 0;
                for (const tech in currentCountryInstalledCapacity) {
                    defaultCapacityMix[tech] = currentCountryInstalledCapacity[tech];
                    totalDefaultCapacity += currentCountryInstalledCapacity[tech];
                }

                if (totalDefaultCapacity > 0) {
                    for (const tech in defaultCapacityMix) {
                        defaultCapacityMix[tech] = (defaultCapacityMix[tech] / totalDefaultCapacity) * 100;
                    }
                }

                let totalDefaultGeneration = 0;
                for (const tech in baselineResult.generation) {
                    if (tech !== 'curtailment' && !tech.includes('ToStorage')) {
                        // Calculate yearly generation by multiplying each hour by days in that month
                        let gen = 0;
                        baselineResult.generation[tech].forEach((value, i) => {
                            const monthIndex = Math.floor(i / 24) % 12;
                            gen += value * DAYS_IN_MONTH[monthIndex];
                        });
                        defaultGenerationMix[tech] = gen;
                        totalDefaultGeneration += gen;
                    }
                }
                if (totalDefaultGeneration > 0) {
                    for (const tech in defaultGenerationMix) {
                        defaultGenerationMix[tech] = (defaultGenerationMix[tech] / totalDefaultGeneration) * 100;
                    }
                }
                runSimulation();
            }

            countrySelect.addEventListener('change', (e) => {
                applySeason(currentSystemDefaultProfileName);
            });

            document.addEventListener('mousemove', (e) => {
                hoverTooltip.style.left = e.pageX + 15 + 'px';
                hoverTooltip.style.top = e.pageY + 15 + 'px';
            });

            gridMixSlidersContainer.addEventListener('mouseover', (e) => {
                const row = e.target.closest('.mix-slider-row');
                if (!row) return;
                const tech = row.dataset.tech;
                if (!tech) return;

                const baselineCapacity = currentCountryInstalledCapacity[tech] || 0;
                const newCapacity = (sliders[tech] ? parseFloat(sliders[tech].value) : 0) || 0;
                const totalCapacity = baselineCapacity + newCapacity;

                hoverTooltip.innerHTML = `Total Capacity: ${totalCapacity.toFixed(2)} GW`;
                hoverTooltip.classList.remove('hidden');
            });
            gridMixSlidersContainer.addEventListener('mouseout', () => {
                hoverTooltip.classList.add('hidden');
            });

            generationMixSlidersContainer.addEventListener('mouseover', (e) => {
                const row = e.target.closest('.mix-slider-row');
                if (!row) return;
                const tech = row.dataset.tech;
                if (!tech || yearlyGenerationTotalsGWh[tech] === undefined) return;

                const totalGWh = yearlyGenerationTotalsGWh[tech];
                const label = tech === 'curtailment' ? 'Total Yearly Curtailment' : 'Total Yearly Generation';
                hoverTooltip.innerHTML = `${label}: ${totalGWh.toFixed(2)} GWh`;
                hoverTooltip.classList.remove('hidden');
            });
            generationMixSlidersContainer.addEventListener('mouseout', () => {
                hoverTooltip.classList.add('hidden');
            });


            // --- INPUT SYNCING ---
            // This function connects sliders and input boxes to runSimulation
            function setupInputSyncing() {
                console.log('DEBUG: setupInputSyncing called');
                console.log('DEBUG: sliders object has keys:', Object.keys(sliders));

                // Debounce function to limit how often simulation runs during rapid slider movements
                let debounceTimeout = null;
                const debouncedRunSimulation = () => {
                    if (debounceTimeout) clearTimeout(debounceTimeout);
                    debounceTimeout = setTimeout(() => {
                        console.log('DEBUG: Running simulation after debounce');
                        runSimulation();
                    }, 150); // 150ms debounce - adjust as needed for responsiveness
                };

                // Connect each slider and input pair
                let connectedCount = 0;
                for (const key in sliders) {
                    if (sliders[key] && inputs[key]) {
                        connectedCount++;
                        // Slider -> Input sync + run simulation
                        sliders[key].addEventListener('input', (e) => {
                            inputs[key].value = e.target.value;
                            debouncedRunSimulation();
                        });

                        // Input -> Slider sync + run simulation  
                        inputs[key].addEventListener('input', (e) => {
                            // Handle empty or invalid input - treat as 0
                            const value = parseFloat(e.target.value);
                            if (isNaN(value) || e.target.value === '') {
                                sliders[key].value = 0;
                            } else {
                                sliders[key].value = value;
                            }
                            debouncedRunSimulation();
                        });

                        // On blur (focus lost), save state for undo/redo
                        sliders[key].addEventListener('change', () => {
                            saveState();
                        });
                        inputs[key].addEventListener('change', () => {
                            saveState();
                        });
                    } else {
                        console.warn(`DEBUG: Missing element for key "${key}": slider=${!!sliders[key]}, input=${!!inputs[key]}`);
                    }
                }
                console.log(`DEBUG: Connected ${connectedCount} slider/input pairs`);
            }

            // --- TUTORIAL LOGIC ---
            const tutorialSteps = [
                {
                    title: 'Welcome to the Grid Simulator!',
                    text: 'This interactive tool lets you explore pathways to a zero-carbon electricity grid. Let\'s take a quick tour of the main features.',
                    position: 'center'
                },
                {
                    element: '#tutorial-step-2',
                    title: 'Live Simulation Charts',
                    text: 'These charts show the real-time results of your decisions. See how the generation mix and CO2 emissions change as you adjust the levers.',
                    position: 'right',
                    highlightClass: 'rounded-lg'
                },
                {
                    element: '#tutorial-step-3',
                    title: 'Your Control Panel',
                    text: 'This is where you make things happen! Use these sliders to deploy new technologies, set government incentives, and choose a starting grid mix.',
                    position: 'left',
                    highlightClass: 'rounded-lg'
                },
                {
                    element: '#tutorial-step-4',
                    title: 'Manage Existing Resources',
                    text: 'Use these checkboxes to turn off an existing resource type and watch the impact it has on emissions and costs.',
                    position: 'right',
                    highlightClass: 'rounded-lg'
                },
                {
                    element: '#make-default-button',
                    title: 'Save Your Scenario',
                    text: 'Once you find a set of policies you like, you can save them as your new default. The cost metrics will then be calculated relative to this new baseline.',
                    position: 'top',
                    highlightClass: 'rounded-full'
                },
                {
                    element: '#tutorial-step-5',
                    title: 'Key Outcome Metrics',
                    text: 'Your goal is to get CO2 emissions to zero while keeping costs low. These cards show the impact on electricity bills and the cost of avoiding CO2.',
                    position: 'bottom',
                    highlightClass: 'rounded-lg'
                },
                {
                    element: '#edit-demand-btn',
                    title: 'Customize Demand',
                    text: 'Click the edit icon to create your own custom daily demand profile, or select a seasonal preset.',
                    position: 'left',
                    highlightClass: 'rounded-full'
                },
                {
                    element: '#edit-cf-btn',
                    title: 'Customize Weather',
                    text: 'Click this edit icon to change the hourly performance of solar and wind to simulate different weather conditions.',
                    position: 'top',
                    highlightClass: 'rounded-full'
                }
            ];

            let currentStep = 0;
            const overlay = document.getElementById('tutorial-overlay');
            const popover = document.getElementById('tutorial-popover');
            const titleEl = document.getElementById('tutorial-title');
            const textEl = document.getElementById('tutorial-text');
            const prevBtn = document.getElementById('tutorial-prev');
            const nextBtn = document.getElementById('tutorial-next');
            const skipBtn = document.getElementById('tutorial-skip');
            let highlightedElement = null;

            function startTutorial() {
                if (localStorage.getItem('gridSimulatorTutorialSeen')) {
                    return;
                }
                document.body.classList.add('tutorial-active');
                currentStep = 0;
                showTutorialStep(currentStep);
            }

            function endTutorial() {
                document.body.classList.remove('tutorial-active');
                overlay.style.display = 'none';
                popover.style.display = 'none';
                if (highlightedElement) {
                    highlightedElement.classList.remove('tutorial-highlight-active', 'rounded-full', 'rounded-lg');
                }
                localStorage.setItem('gridSimulatorTutorialSeen', 'true');
            }

            function positionPopover(targetElement, popoverEl, position) {
                popoverEl.style.visibility = 'hidden';
                popoverEl.style.display = 'block';

                const popoverRect = popoverEl.getBoundingClientRect();
                const margin = 15;

                if (position === 'center' || !targetElement) {
                    popoverEl.style.left = '50%';
                    popoverEl.style.top = '50%';
                    popoverEl.style.transform = 'translate(-50%, -50%)';
                    popoverEl.style.visibility = 'visible';
                    return;
                }

                const targetRect = targetElement.getBoundingClientRect();
                let top, left;

                switch (position) {
                    case 'top':
                        top = targetRect.top - popoverRect.height - margin;
                        left = targetRect.left + (targetRect.width / 2) - (popoverRect.width / 2);
                        break;
                    case 'bottom':
                        top = targetRect.bottom + margin;
                        left = targetRect.left + (targetRect.width / 2) - (popoverRect.width / 2);
                        break;
                    case 'left':
                        top = targetRect.left - popoverRect.width - margin;
                        left = targetRect.top + (targetRect.height / 2) - (popoverRect.height / 2);
                        break;
                    case 'right':
                    default:
                        top = targetRect.top + (targetRect.height / 2) - (popoverRect.height / 2);
                        left = targetRect.right + margin;
                        break;
                }

                if (top < margin) top = margin;
                if (left < margin) left = margin;
                if (left + popoverRect.width > window.innerWidth - margin) {
                    left = window.innerWidth - popoverRect.width - margin;
                }
                if (top + popoverRect.height > window.innerHeight - margin) {
                    top = window.innerHeight - popoverRect.height - margin;
                }

                popoverEl.style.top = `${top}px`;
                popoverEl.style.left = `${left}px`;
                popoverEl.style.transform = 'none';
                popoverEl.style.visibility = 'visible';
            }

            function showTutorialStep(stepIndex) {
                if (stepIndex < 0 || stepIndex >= tutorialSteps.length) {
                    endTutorial();
                    return;
                }

                const step = tutorialSteps[stepIndex];

                if (highlightedElement) {
                    highlightedElement.classList.remove('tutorial-highlight-active', 'rounded-full', 'rounded-lg');
                    highlightedElement = null;
                }

                titleEl.textContent = step.title;
                textEl.textContent = step.text;

                let targetElement;
                if (step.element) {
                    targetElement = document.querySelector(step.element);
                }

                if (targetElement) {
                    overlay.style.display = 'none';
                    highlightedElement = targetElement;
                    highlightedElement.classList.add('tutorial-highlight-active');
                    if (step.highlightClass) {
                        highlightedElement.classList.add(step.highlightClass);
                    }

                    highlightedElement.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });

                    setTimeout(() => {
                        positionPopover(highlightedElement, popover, step.position);
                    }, 400);
                } else {
                    overlay.style.display = 'block';
                    positionPopover(null, popover, 'center');
                }

                prevBtn.style.display = stepIndex === 0 ? 'none' : 'inline-block';
                nextBtn.textContent = stepIndex === tutorialSteps.length - 1 ? 'Finish' : 'Next';
            }

            nextBtn.addEventListener('click', () => {
                currentStep++;
                showTutorialStep(currentStep);
            });

            prevBtn.addEventListener('click', () => {
                currentStep--;
                showTutorialStep(currentStep);
            });

            skipBtn.addEventListener('click', endTutorial);

            startTutorialBtn.addEventListener('click', () => {
                localStorage.removeItem('gridSimulatorTutorialSeen');
                startTutorial();
            });


            // ============================================
            // CAPACITY EXPANSION OPTIMIZATION MODULE
            // ============================================

            // ===== OPTIMIZATION CONFIGURATION =====
            const OPTIMIZATION_CONFIG = {
                MAX_ITERATIONS: 1000,         // Increased from 500 for better convergence
                NUM_CANDIDATES: 5,
                TECHNOLOGIES: ['solar', 'wind', 'offshoreWind', 'nuclear', 'geothermal', 'biomass', 'rng', 'hydrogen',
                    'battery4hr', 'battery8hr', 'longduration', 'dac'],
                BOUNDS: {
                    solar: [0, 100],          // GW
                    wind: [0, 80],            // GW
                    offshoreWind: [0, 50],    // GW
                    nuclear: [0, 30],         // GW
                    geothermal: [0, 20],      // GW
                    biomass: [0, 20],         // GW
                    rng: [0, 20],             // GW
                    hydrogen: [0, 20],        // GW
                    battery4hr: [0, 100],     // GWh
                    battery8hr: [0, 100],     // GWh
                    longduration: [0, 200],   // GWh
                    dac: [0, 10000]           // tons/hr
                },
                RESERVE_MARGIN_TARGET: 0.20,  // 20% reserve margin (Flexible capacity > 120% of Peak)
                MAX_CURTAILMENT_RATE: 0.20,   // 20% (matches UI checkbox)
                CO2_TOLERANCE: 0.02,          // 2% tolerance for CO2 constraint (relaxed from 1%)
                MIN_DISPATCHABLE_CAPACITY: 10 // GW - minimum firm capacity (relaxed from 15)
            };

            // ===== HELPER FUNCTIONS =====

            /**
             * Enforce capacity bounds for all technologies
             */
            function enforceCapacityBounds(solution, checkOnly = false) {
                const bounded = checkOnly ? true : {};
                let allValid = true;

                for (const tech of OPTIMIZATION_CONFIG.TECHNOLOGIES) {
                    const value = solution[tech] || 0;
                    const [min, max] = OPTIMIZATION_CONFIG.BOUNDS[tech];

                    if (value < min || value > max) {
                        allValid = false;
                    }

                    if (!checkOnly) {
                        bounded[tech] = Math.max(min, Math.min(max, value));
                    }
                }

                return checkOnly ? allValid : bounded;
            }

            /**
             * Calculate reserve margin (dispatchable capacity / peak demand)
             */
            function calculateReserveMargin(capacity, demandData, baselineCapacity, baselineStorage = {}) {
                const peakDemand = Math.max(...demandData);

                // Helper to safely ensure we get a number, ignoring arrays/objects
                const getVal = (obj, key) => {
                    if (!obj) return 0;
                    const val = obj[key];
                    if (typeof val === 'number') return val;
                    if (typeof val === 'string') return parseFloat(val) || 0;
                    return 0; // Arrays and objects return 0
                };

                // User-defined Flexible Resources:
                // RNG, Hydrogen, Hydro, Natural Gas, Storage
                // EXCLUDED: Solar, Wind, Offshore Wind, Nuclear, Geothermal, Coal, Biomass

                const flexibleCapacity =
                    // NEW flexible generation
                    getVal(capacity, 'rng') +
                    getVal(capacity, 'hydrogen') +
                    getVal(capacity, 'naturalGas') +
                    getVal(capacity, 'hydro') +
                    // NEW storage (power capacity)
                    (getVal(capacity, 'battery4hr') / 4) +
                    (getVal(capacity, 'battery8hr') / 8) +
                    (getVal(capacity, 'longduration') / 24) +
                    // BASELINE flexible generation
                    getVal(baselineCapacity, 'rng') +
                    getVal(baselineCapacity, 'hydrogen') +
                    getVal(baselineCapacity, 'naturalGas') +
                    getVal(baselineCapacity, 'hydro') +
                    // BASELINE storage (power capacity)
                    (getVal(baselineStorage, 'battery4hr') / 4) +
                    (getVal(baselineStorage, 'battery8hr') / 8) +
                    (getVal(baselineStorage, 'longduration') / 24);

                return (flexibleCapacity / peakDemand) - 1.0;
            }

            /**
             * Calculate annual CO2 emissions from generation profile
             */
            function calculateAnnualCO2(emissionsProfile) {
                let totalCO2 = 0;
                const hoursPerMonth = 24;

                for (let i = 0; i < emissionsProfile.length; i++) {
                    const monthIndex = Math.floor(i / hoursPerMonth) % 12;
                    totalCO2 += emissionsProfile[i] * DAYS_IN_MONTH[monthIndex];
                }

                return totalCO2;  // in kg CO2
            }

            /**
             * Calculate curtailment rate from simulation result
             */
            function calculateCurtailmentRate(simulationResult) {
                const hoursPerMonth = 24;
                let totalGeneration = 0;
                let totalCurtailment = 0;

                for (let i = 0; i < simulationResult.generation.solar.length; i++) {
                    const monthIndex = Math.floor(i / hoursPerMonth) % 12;
                    const daysInMonth = DAYS_IN_MONTH[monthIndex];

                    // Sum all generation (EXCLUDING curtailment which isn't generation)
                    for (const tech in simulationResult.generation) {
                        if (tech !== 'curtailment') {  // FIX: Don't include curtailment in generation sum
                            totalGeneration += simulationResult.generation[tech][i] * daysInMonth;
                        }
                    }

                    // Sum curtailment
                    totalCurtailment += simulationResult.generation.curtailment[i] * daysInMonth;
                }

                return totalCurtailment / (totalGeneration + totalCurtailment);
            }

            /**
             * Estimate current CO2 emissions from a capacity solution (quick approximation)
             */
            function estimateCurrentCO2(solution) {
                // Use full simulation (cached) for accurate CO2 estimate
                // This is critical for the "Capacity Removal" logic to work correctly
                if (!optimizationContext) return 38e9;

                // We use a dummy targetCO2 since we only want the absolute emission value
                const result = evaluateSolutionFull(solution, 0);
                return result.annualCO2;
            }

            /**
             * Get current curtailment rate from a solution (requires full simulation)
             */
            function getCurrentCurtailmentRate(solution) {
                // Run a quick simulation to get curtailment
                try {
                    if (!optimizationContext) return 0;

                    // Pass only NEW capacity (solution), not total
                    const capacityInputs = {
                        capacity: solution,
                        incentives: optimizationContext.incentives
                    };

                    const result = getSimulationResult(
                        capacityInputs,
                        optimizationContext.solarProfile,
                        optimizationContext.windProfile,
                        optimizationContext.offshoreWindProfile,
                        optimizationContext.potentialGen,
                        optimizationContext.baselineStorage,
                        optimizationContext.hydroCF,
                        optimizationContext.countryName
                    );

                    return calculateCurtailmentRate(result);
                } catch (error) {
                    console.warn('Error calculating curtailment rate:', error);
                    return 0;
                }
            }

            /**
             * Estimate baseline fossil CO2 emissions
             */
            function estimateBaselineFossilCO2() {
                // Get current emissions from the current state
                try {
                    if (!optimizationContext) return 38e9;  // Fallback if context not set

                    console.log('=== ESTIMATING BASELINE CO2 ===');
                    console.log('Baseline capacity:', JSON.stringify(optimizationContext.baselineCapacity));

                    // IMPORTANT: Pass ZERO new capacity to get baseline emissions
                    // The simulation adds potentialGen (baseline) + inputs.capacity (new)
                    // So to get just baseline, we pass zero for inputs.capacity
                    const zeroCapacity = {
                        solar: 0, wind: 0, offshoreWind: 0, nuclear: 0, geothermal: 0,
                        biomass: 0, rng: 0, hydrogen: 0, battery4hr: 0, battery8hr: 0,
                        longduration: 0, dac: 0, hydro: 0, naturalGas: 0, coal: 0, demandflex: 0
                    };

                    const result = getSimulationResult(
                        { capacity: zeroCapacity, incentives: optimizationContext.incentives },
                        optimizationContext.solarProfile,
                        optimizationContext.windProfile,
                        optimizationContext.offshoreWindProfile,
                        optimizationContext.potentialGen,
                        optimizationContext.baselineStorage,
                        optimizationContext.hydroCF,
                        optimizationContext.countryName
                    );

                    console.log('Baseline simulation emissions sample:', result.emissions?.slice(0, 10));
                    const annualCO2 = calculateAnnualCO2(result.emissions);
                    console.log('Baseline annual CO2:', annualCO2, 'kg =', (annualCO2 / 1e9).toFixed(2), 'million MT');
                    console.log('=== END BASELINE ESTIMATION ===');

                    return annualCO2;
                } catch (error) {
                    console.error('Error estimating baseline CO2:', error);
                    console.error('Stack:', error.stack);
                    // Fallback estimate
                    return 38e9;  // kg CO2/year (roughly California's grid emissions)
                }
            }

            /**
             * Perturb solution to escape local minimum
             */
            function perturbSolution(solution, iteration, targetCO2) {
                const perturbed = { ...solution };

                // Determine number of perturbations based on iteration
                const numPerturbs = Math.min(3, Math.floor(iteration / 100) + 1);

                for (let i = 0; i < numPerturbs; i++) {
                    // Filter out DAC using same logic as generateCandidates
                    const allowedTechs = OPTIMIZATION_CONFIG.TECHNOLOGIES.filter(t => {
                        // User disabled DAC entirely
                        if (t === 'dac' && window.optimizerOptions && !window.optimizerOptions.allowDAC) return false;

                        // Same logic as generateCandidates: skip DAC for easy targets
                        if (t === 'dac' && targetCO2) {
                            const baselineCO2 = estimateBaselineFossilCO2();
                            const targetDifficulty = targetCO2 / baselineCO2;
                            const currentCurtailment = getCurrentCurtailmentRate(solution);
                            const isAggressiveTarget = targetDifficulty < 0.60;
                            const isHittingCurtailmentLimit = currentCurtailment > 0.15;
                            if (!isAggressiveTarget && !isHittingCurtailmentLimit) return false;
                        }

                        return true;
                    });

                    if (allowedTechs.length === 0) {
                        console.log('[perturbSolution] No allowed technologies for perturbation!');
                        return perturbed;
                    }

                    const tech = allowedTechs[
                        Math.floor(Math.random() * allowedTechs.length)
                    ];

                    // Scaling factor for perturbation
                    // Use larger perturbation for DAC to avoid "dust"
                    let scale = 1.0;
                    if (tech === 'dac') scale = 20.0;
                    if (tech.includes('battery') || tech === 'longduration') scale = 2.0;

                    // Random perturbation Â±2 GW (scaled)
                    const delta = (Math.random() - 0.5) * 4.0 * scale;
                    perturbed[tech] = Math.max(0, (perturbed[tech] || 0) + delta);
                }

                return enforceCapacityBounds(perturbed);
            }

            // ===== SOLUTION EVALUATION =====

            // Cache for solution evaluations to avoid redundant calculations
            let solutionCache = new Map();
            let cacheHits = 0;
            let cacheMisses = 0;

            /**
             * Generate a hash key for a solution (for caching)
             */
            function hashSolution(solution) {
                // Round values to 0.1 precision for caching
                const rounded = {};
                for (const tech of OPTIMIZATION_CONFIG.TECHNOLOGIES) {
                    const value = solution[tech] || 0;
                    rounded[tech] = Math.round(value * 10) / 10;
                }
                return JSON.stringify(rounded);
            }

            /**
             * Clear the solution cache (call between optimization runs)
             */
            function clearSolutionCache() {
                solutionCache.clear();
                cacheHits = 0;
                cacheMisses = 0;
            }

            /**
             * Evaluate a capacity solution by running full dispatch simulation (with caching)
             */
            function evaluateSolutionFull(solution, targetCO2, useCache = true) {
                // Check cache first
                if (useCache) {
                    const hash = hashSolution(solution);
                    if (solutionCache.has(hash)) {
                        cacheHits++;
                        return solutionCache.get(hash);
                    }
                    cacheMisses++;
                }

                // Perform actual evaluation
                const result = evaluateSolutionFullUncached(solution, targetCO2);

                // Store in cache
                if (useCache) {
                    const hash = hashSolution(solution);
                    solutionCache.set(hash, result);
                }

                return result;
            }

            /**
             * Evaluate a capacity solution by running full dispatch simulation (no caching)
             */
            function evaluateSolutionFullUncached(solution, targetCO2) {
                try {
                    if (!optimizationContext) {
                        throw new Error('Optimization context not initialized');
                    }

                    // Build capacity object for existing simulation
                    // IMPORTANT: inputs.capacity should contain ONLY NEW capacity additions (solution)
                    // - potentialGen already contains baseline generation (line 2019: currentPotential = JSON.parse(JSON.stringify(potentialGen)))
                    // - Line 2042 ADDS inputs.capacity to currentPotential: currentPotential.solar[i] += inputs.capacity.solar * solarProfile[i]
                    // - Lines 2051 (hydro) and 2172 (naturalGas) also add currentCountryInstalledCapacity separately
                    // - Cost function expects capacity=NEW, baselineCapacity=baseline (line 1878-1880)
                    const capacityInputs = {
                        capacity: {
                            // ALL technologies: Pass only NEW capacity additions from optimization
                            solar: solution.solar || 0,
                            wind: solution.wind || 0,
                            offshoreWind: solution.offshoreWind || 0,
                            nuclear: solution.nuclear || 0,
                            geothermal: solution.geothermal || 0,
                            biomass: solution.biomass || 0,
                            rng: solution.rng || 0,
                            hydrogen: solution.hydrogen || 0,
                            battery4hr: solution.battery4hr || 0,
                            battery8hr: solution.battery8hr || 0,
                            longduration: solution.longduration || 0,
                            dac: solution.dac || 0,
                            hydro: solution.hydro || 0,
                            naturalGas: solution.naturalGas || 0,
                            coal: solution.coal || 0,
                            demandflex: solution.demandflex || 0
                        },
                        incentives: optimizationContext.incentives
                    };

                    // Debug: Log capacity object being passed to simulation (first evaluation only)
                    if (!evaluateSolutionFullUncached.firstCallLogged) {
                        console.log('First evaluation - Capacity object:', JSON.stringify(capacityInputs.capacity, null, 2));
                        console.log('- Hydro:', capacityInputs.capacity.hydro);
                        console.log('- Natural Gas:', capacityInputs.capacity.naturalGas);
                        console.log('- Coal:', capacityInputs.capacity.coal);
                        console.log('- Solar:', capacityInputs.capacity.solar);
                        console.log('- Wind:', capacityInputs.capacity.wind);
                        evaluateSolutionFullUncached.firstCallLogged = true;
                    }

                    // DEBUG: Log optimization simulation inputs (first call only)
                    if (!evaluateSolutionFullUncached.firstSimInputsLogged) {
                        console.log('=== OPTIMIZATION MODE SIMULATION INPUTS ===');
                        console.log('NEW Capacity passed:', capacityInputs.capacity);
                        console.log('Solar profile length:', optimizationContext.solarProfile.length);
                        console.log('Solar profile sample (first 10):');
                        optimizationContext.solarProfile.slice(0, 10).forEach((val, i) => console.log(`  Hour ${i}: ${val.toFixed(4)}`));
                        console.log('Wind profile length:', optimizationContext.windProfile.length);
                        console.log('Wind profile sample (first 10):');
                        optimizationContext.windProfile.slice(0, 10).forEach((val, i) => console.log(`  Hour ${i}: ${val.toFixed(4)}`));
                        console.log('Demand length:', optimizationContext.demand.length);
                        console.log('Demand sample (first 10):');
                        optimizationContext.demand.slice(0, 10).forEach((val, i) => console.log(`  Hour ${i}: ${val.toFixed(2)} GW`));
                        console.log('Baseline storage:', optimizationContext.baselineStorage);
                        console.log('Baseline capacity:', optimizationContext.baselineCapacity);
                        console.log('potentialGen keys:', Object.keys(optimizationContext.potentialGen));
                        console.log('potentialGen.solar length:', optimizationContext.potentialGen.solar?.length);
                        console.log('potentialGen.solar sample (first 10):');
                        optimizationContext.potentialGen.solar?.slice(0, 10).forEach((val, i) => console.log(`  Hour ${i}: ${val.toFixed(4)} GW`));
                        console.log('potentialGen.wind sample (first 10):');
                        optimizationContext.potentialGen.wind?.slice(0, 10).forEach((val, i) => console.log(`  Hour ${i}: ${val.toFixed(4)} GW`));
                        console.log('potentialGen.hydro sample (first 10):');
                        optimizationContext.potentialGen.hydro?.slice(0, 10).forEach((val, i) => console.log(`  Hour ${i}: ${val.toFixed(4)} GW`));
                        console.log('potentialGen.naturalGas sample (first 10):');
                        optimizationContext.potentialGen.naturalGas?.slice(0, 10).forEach((val, i) => console.log(`  Hour ${i}: ${val.toFixed(4)} GW`));
                        evaluateSolutionFullUncached.firstSimInputsLogged = true;
                    }

                    // Run existing dispatch simulation
                    const simulationResult = getSimulationResult(
                        capacityInputs,
                        optimizationContext.solarProfile,
                        optimizationContext.windProfile,
                        optimizationContext.offshoreWindProfile,
                        optimizationContext.potentialGen,
                        optimizationContext.baselineStorage,
                        optimizationContext.hydroCF,
                        optimizationContext.countryName
                    );

                    // Debug: Check if simulation result is valid
                    if (!simulationResult || !simulationResult.emissions) {
                        console.error('Invalid simulation result:', simulationResult);
                        throw new Error('Simulation result missing emissions data');
                    }

                    // Debug: Log first few emissions values (first evaluation only)
                    if (!evaluateSolutionFullUncached.firstEmissionsLogged) {
                        console.log('First evaluation - Emissions sample:', simulationResult.emissions.slice(0, 10));
                        evaluateSolutionFullUncached.firstEmissionsLogged = true;
                    }

                    // Calculate system cost
                    const systemCost = calculateTotalAnnualSystemCost(
                        simulationResult.generation,
                        capacityInputs.capacity,
                        optimizationContext.incentives,
                        simulationResult.generation.curtailment,
                        optimizationContext.baselineCapacity,
                        optimizationContext.baselineStorage,
                        simulationResult.gasGenDetails
                    );

                    // Calculate metrics
                    const annualCO2 = calculateAnnualCO2(simulationResult.emissions);

                    // Debug: Check if CO2 calculation is valid
                    if (isNaN(annualCO2)) {
                        console.error('Annual CO2 is NaN. Emissions profile:', simulationResult.emissions.slice(0, 5));
                        throw new Error('CO2 calculation returned NaN');
                    }
                    const reserveMargin = calculateReserveMargin(capacityInputs.capacity, optimizationContext.demand, optimizationContext.baselineCapacity, optimizationContext.baselineStorage);
                    const curtailmentRate = calculateCurtailmentRate(simulationResult);

                    // Calculate unmet energy
                    let unmetEnergy = 0;
                    const hoursPerMonth = 24;
                    for (let i = 0; i < simulationResult.generation.solar.length; i++) {
                        const monthIndex = Math.floor(i / hoursPerMonth) % 12;
                        let totalGen = 0;
                        for (const tech in simulationResult.generation) {
                            if (tech !== 'curtailment') {
                                totalGen += simulationResult.generation[tech][i];
                            }
                        }
                        const deficit = Math.max(0, optimizationContext.demand[i] - totalGen);
                        unmetEnergy += deficit * DAYS_IN_MONTH[monthIndex];
                    }

                    // Check feasibility
                    const feasibility = checkFeasibility(
                        simulationResult,
                        capacityInputs.capacity,
                        annualCO2,
                        targetCO2
                    );

                    return {
                        systemCost,
                        annualCO2,
                        isFeasible: feasibility.isFeasible,
                        metrics: {
                            reserveMargin,
                            curtailmentRate,
                            unmetEnergy
                        },
                        feasibility: feasibility,
                        simulationResult
                    };
                } catch (error) {
                    console.error('Error evaluating solution:', error);
                    return {
                        systemCost: Infinity,
                        annualCO2: Infinity,
                        isFeasible: false,
                        metrics: {
                            reserveMargin: 0,
                            curtailmentRate: 0,
                            unmetEnergy: Infinity
                        },
                        error: error.message
                    };
                }
            }

            /**
             * Quick feasibility check before full evaluation (for performance)
             */
            function quickFeasibilityCheck(solution, targetCO2) {
                if (!optimizationContext) return false;

                // QUICK CHECK 1: Total capacity (NEW + BASELINE)
                // CRITICAL FIX: Must include baseline capacity, not just new capacity!
                const newCapacity = Object.values(solution).reduce((a, b) => (a || 0) + (b || 0), 0);
                const baselineCapacity = Object.values(optimizationContext.baselineCapacity || {}).reduce((a, b) => (a || 0) + (b || 0), 0);
                const totalCapacity = newCapacity + baselineCapacity;
                const peakDemand = Math.max(...optimizationContext.demand);

                if (totalCapacity < peakDemand * 0.3) {
                    return false;  // Obviously insufficient (relaxed from 0.5 to 0.3)
                }

                // QUICK CHECK 2: Don't make things worse
                // Only reject if estimated CO2 is WORSE than baseline (i.e., adding capacity increases emissions)
                // This was too strict before - it rejected candidates making progress toward target
                // Removed this check entirely to allow exploration

                // QUICK CHECK 3: Bounds check
                if (!enforceCapacityBounds(solution, true)) {
                    return false;  // Exceeds technology limits
                }

                return true;  // Passed quick checks, worth full evaluation
            }

            /**
             * Check if a solution meets all feasibility constraints
             */
            function checkFeasibility(simulationResult, capacity, annualCO2, targetCO2) {
                const checks = {
                    co2: false,
                    energyBalance: false,
                    reserveMargin: false,
                    curtailment: false
                };

                // 1. CO2 CONSTRAINT (HARD - User preference: must meet)
                checks.co2 = annualCO2 <= targetCO2 * (1 + OPTIMIZATION_CONFIG.CO2_TOLERANCE);

                // 2. ENERGY BALANCE (all hours)
                const hoursPerMonth = 24;
                let unmetEnergy = 0;
                for (let i = 0; i < simulationResult.generation.solar.length; i++) {
                    const monthIndex = Math.floor(i / hoursPerMonth) % 12;
                    let totalGen = 0;
                    for (const tech in simulationResult.generation) {
                        if (tech !== 'curtailment') {
                            totalGen += simulationResult.generation[tech][i];
                        }
                    }
                    const deficit = Math.max(0, optimizationContext.demand[i] - totalGen);
                    unmetEnergy += deficit * DAYS_IN_MONTH[monthIndex];
                }
                checks.energyBalance = unmetEnergy < 0.01;  // Negligible unmet (< 10 MWh/year)

                // 3. RESERVE MARGIN (20% flexible capacity above peak)
                const reserveMargin = calculateReserveMargin(capacity, optimizationContext.demand, optimizationContext.baselineCapacity, optimizationContext.baselineStorage);
                checks.reserveMargin = reserveMargin >= OPTIMIZATION_CONFIG.RESERVE_MARGIN_TARGET * 0.96;  // Allow 4% tolerance (19.2% minimum)

                // 4. CURTAILMENT (hard constraint only if user enabled it)
                const curtailmentRate = calculateCurtailmentRate(simulationResult);
                checks.curtailment = curtailmentRate <= OPTIMIZATION_CONFIG.MAX_CURTAILMENT_RATE * 1.05;  // 5% tolerance

                // Overall feasibility: Hard constraints must pass
                // Curtailment is only a hard constraint if respectCurtailment option is enabled
                const respectCurtailment = window.optimizerOptions?.respectCurtailment !== false;  // Default true for safety
                const isFeasible = checks.co2 && checks.energyBalance && checks.reserveMargin &&
                    (respectCurtailment ? checks.curtailment : true);

                const peakDemand = Math.max(...optimizationContext.demand);
                const dispatchableCapacity =
                    (capacity.nuclear || 0) +
                    (capacity.geothermal || 0) +
                    (optimizationContext.baselineCapacity.naturalGas || 0) +
                    (optimizationContext.baselineCapacity.hydro || 0) +
                    ((capacity.battery4hr || 0) / 4) +
                    ((capacity.battery8hr || 0) / 8);

                // DIAGNOSTIC: Log first infeasible solution to help debug re-optimization issues
                if (!isFeasible && !checkFeasibility.firstInfeasibleLogged) {
                    checkFeasibility.firstInfeasibleLogged = true;
                    console.log('=== FIRST INFEASIBLE SOLUTION DIAGNOSTICS ===');
                    console.log('Peak Demand:', peakDemand.toFixed(2), 'GW');
                    console.log('Reserve Margin:', (reserveMargin * 100).toFixed(1) + '%', '(Target: 20%)');
                    console.log('Flexible Capacity Breakdown (counts towards reserve margin):');
                    console.log('  - Baseline Natural Gas:', (optimizationContext.baselineCapacity.naturalGas || 0).toFixed(2), 'GW');
                    console.log('  - Baseline Hydro:', (optimizationContext.baselineCapacity.hydro || 0).toFixed(2), 'GW');
                    console.log('  - New RNG:', (capacity.rng || 0).toFixed(2), 'GW');
                    console.log('  - New Hydrogen:', (capacity.hydrogen || 0).toFixed(2), 'GW');
                    console.log('  - New Battery4hr:', (capacity.battery4hr || 0).toFixed(2), 'GWh â†’ ', ((capacity.battery4hr || 0) / 4).toFixed(2), 'GW');
                    console.log('  - New Battery8hr:', (capacity.battery8hr || 0).toFixed(2), 'GWh â†’ ', ((capacity.battery8hr || 0) / 8).toFixed(2), 'GW');
                    console.log('  - New Long Duration:', (capacity.longduration || 0).toFixed(2), 'GWh â†’ ', ((capacity.longduration || 0) / 24).toFixed(2), 'GW');
                    console.log('Non-Flexible Capacity (NOT counted in reserve margin):');
                    console.log('  - New Solar:', (capacity.solar || 0).toFixed(2), 'GW');
                    console.log('  - New Wind:', (capacity.wind || 0).toFixed(2), 'GW');
                    console.log('  - New Nuclear:', (capacity.nuclear || 0).toFixed(2), 'GW');
                    console.log('  - New Geothermal:', (capacity.geothermal || 0).toFixed(2), 'GW');
                    console.log('  - New Biomass:', (capacity.biomass || 0).toFixed(2), 'GW (excluded from flexibility calculation)');
                    console.log('Failed Checks:', Object.entries(checks).filter(([k, v]) => !v).map(([k]) => k).join(', '));
                    console.log('============================================');
                }

                return {
                    isFeasible,
                    checks,
                    reasons: {
                        co2: checks.co2 ? null : `CO2 ${(annualCO2 / 1e9).toFixed(1)} million MT exceeds target ${(targetCO2 / 1e9).toFixed(1)} million MT`,
                        energyBalance: checks.energyBalance ? null : `Unmet energy: ${unmetEnergy.toFixed(2)} GWh`,
                        reserveMargin: checks.reserveMargin ? null : `Reserve margin ${(reserveMargin * 100).toFixed(1)}% below ${(OPTIMIZATION_CONFIG.RESERVE_MARGIN_TARGET * 100).toFixed(0)}% target`,
                        curtailment: checks.curtailment ? null : `High curtailment: ${(curtailmentRate * 100).toFixed(1)}%`
                    }
                };
            }

            // ===== MARGINAL LCOE CALCULATION =====

            /**
             * Calculate marginal LCOE with system value adjustments
             * This guides the optimization by prioritizing technologies based on cost and system value
             */
            function calculateMarginalLCOEWithSystemValue(currentSolution, targetCO2, iteration = 0) {
                const baseLCOE = {};

                // Calculate base LCOE for each technology
                for (const tech of OPTIMIZATION_CONFIG.TECHNOLOGIES) {
                    if (tech === 'dac') {
                        // DAC has different cost structure ($/ton captured, not $/MWh)
                        // Estimate LCOE based on CO2 reduction value
                        const dacCapex = COST_DATA.capex.dac;  // $/ton/year capacity
                        const dacFixedOM = COST_DATA.fixed_om.dac;  // $/ton/year
                        const dacVariableOM = COST_DATA.variable_om.dac;  // $/ton captured
                        const lifetime = COST_DATA.lifetime.dac;
                        const CRF = (0.07 * Math.pow(1.07, lifetime)) / (Math.pow(1.07, lifetime) - 1);

                        // Cost per ton CO2 captured
                        const costPerTonCO2 = dacCapex * CRF + dacFixedOM + dacVariableOM;

                        // Convert to equivalent LCOE assuming carbon value
                        baseLCOE[tech] = costPerTonCO2 / 0.395;  // 395 kg CO2/MWh for NG â†’ $/MWh equivalent
                        continue;
                    }

                    const capex = COST_DATA.capex[tech];
                    const fixedOM = COST_DATA.fixed_om[tech];
                    const variableOM = COST_DATA.variable_om[tech];
                    const lifetime = COST_DATA.lifetime[tech];
                    const capacityFactor = COST_DATA.capacity_factor[tech];

                    if (!lifetime || !capacityFactor) continue;

                    const CRF = (0.07 * Math.pow(1.07, lifetime)) / (Math.pow(1.07, lifetime) - 1);

                    // For storage, use $/kWh capacity cost
                    if (tech.includes('battery') || tech === 'longduration') {
                        const duration = tech === 'longduration' ? 24 : parseInt(tech.match(/\d+/)[0]);
                        // Cost per kW of power capacity
                        const costPerKW = capex * duration;  // $/kWh * hours = $/kW
                        const annualDischarges = 250;  // Assume 250 cycles/year
                        const annualGenerationPerKW = annualDischarges * duration;  // kWh/kW-year

                        baseLCOE[tech] = (
                            (costPerKW * CRF + fixedOM) / annualGenerationPerKW +
                            variableOM / 1000
                        );
                    } else {
                        // Standard generation technologies
                        const annualGeneration = 8760 * capacityFactor;  // MWh/MW-year

                        baseLCOE[tech] = (
                            (capex * 1000 * CRF + fixedOM * 1000) / annualGeneration +
                            variableOM / 1000
                        );
                    }
                }

                // Adjust for system value (captures flexibility & timing)
                const adjustedLCOE = { ...baseLCOE };

                // Penalty for high curtailment sources
                const currentCurtailment = getCurrentCurtailmentRate(currentSolution);
                if (currentCurtailment > 0.10) {  // >10% curtailment
                    adjustedLCOE.solar *= (1 + currentCurtailment);
                    adjustedLCOE.wind *= (1 + currentCurtailment * 0.5);
                    adjustedLCOE.offshoreWind *= (1 + currentCurtailment * 0.3);
                }

                // Bonus for dispatchable/flexible capacity if reserve margin is low
                // Bonus for dispatchable/flexible capacity if reserve margin is low
                const reserveMargin = calculateReserveMargin(currentSolution, optimizationContext.demand, optimizationContext.baselineCapacity, optimizationContext.baselineStorage);
                if (reserveMargin < OPTIMIZATION_CONFIG.RESERVE_MARGIN_TARGET) {
                    // CRITICAL PRIORITY: If margin is unsafe (e.g. < 15%), we MUST build flexible capacity
                    // Heavily discount LCOE to force selection
                    // NOTE: Biomass is NOT considered flexible for reserve margin purposes
                    const flexibleTechs = ['battery4hr', 'battery8hr', 'longduration', 'hydrogen', 'rng'];
                    flexibleTechs.forEach(tech => {
                        if (adjustedLCOE[tech]) {
                            adjustedLCOE[tech] *= 0.1; // 90% discount to force selection
                        }
                    });
                    // Also slightly discount firm baseload as it helps too (though less efficiently for peaking)
                    adjustedLCOE.geothermal *= 0.5;
                    adjustedLCOE.nuclear *= 0.5;
                }

                // Bonus for emissions reduction if far from target
                const currentCO2 = estimateCurrentCO2(currentSolution);
                const co2Gap = currentCO2 - targetCO2;
                if (co2Gap > 0) {
                    // Prioritize zero-carbon sources
                    const zeroCarbon = ['solar', 'wind', 'offshoreWind', 'nuclear', 'geothermal'];
                    zeroCarbon.forEach(tech => {
                        if (adjustedLCOE[tech]) {
                            adjustedLCOE[tech] *= 0.9;  // 10% discount
                        }
                    });

                    // Extra bonus for DAC only if VERY far from target and near tech limits
                    // (prevents DAC from being suggested for mild targets)
                    if (co2Gap > targetCO2 * 1.5) {
                        adjustedLCOE.dac *= 0.7;  // 30% discount for DAC
                        console.log(`[LCOE] DAC discount applied (far from target): ${(adjustedLCOE.dac / 0.7).toFixed(2)} â†’ ${adjustedLCOE.dac.toFixed(2)} $/MWh-eq`);
                    }
                }

                // LOG: Show adjusted LCOE ranking every 100 iterations to understand selection priorities
                if (!calculateMarginalLCOEWithSystemValue.lastLog ||
                    (iteration && iteration - calculateMarginalLCOEWithSystemValue.lastLog >= 100)) {

                    calculateMarginalLCOEWithSystemValue.lastLog = iteration;

                    console.log(`\n[Iter ${iteration}] ðŸ’° ADJUSTED LCOE RANKING (lower = better):`);
                    const sorted = Object.entries(adjustedLCOE)
                        .filter(([tech, lcoe]) => lcoe !== Infinity)
                        .sort(([, a], [, b]) => a - b)
                        .slice(0, 8);  // Top 8 cheapest

                    sorted.forEach(([tech, lcoe], idx) => {
                        const marker = tech === 'dac' ? 'âš ï¸ DAC' : tech;
                        console.log(`  ${idx + 1}. ${marker}: $${lcoe.toFixed(2)}/MWh-eq`);
                    });

                    // Show context
                    console.log(`  Context: CO2 gap=${((currentCO2 - targetCO2) / 1e9).toFixed(1)}MT, Reserve=${(reserveMargin * 100).toFixed(1)}%, Curtail=${(currentCurtailment * 100).toFixed(1)}%\n`);
                }

                return adjustedLCOE;
            }

            // ===== CANDIDATE GENERATION =====

            /**
             * Generate candidate solutions based on marginal LCOE and heuristics
             */
            function generateCandidates(currentSolution, marginalLCOE, iteration, targetCO2) {
                const candidates = [];

                // Refined step sizes for better convergence (scaled for 1000 iterations)
                // We go much finer in later iterations to allow Solar/Wind to fill small gaps
                // UPDATED: Use smaller initial steps (2.0 instead of 5.0) to avoid overshooting targets
                const baseStep = iteration < 200 ? 2.0 :
                    iteration < 400 ? 1.0 :
                        iteration < 600 ? 0.5 :
                            iteration < 800 ? 0.2 : 0.1;

                const techs = OPTIMIZATION_CONFIG.TECHNOLOGIES;

                // Helper to get tech-specific step size
                // Normalize economic impact of steps: 
                // 0.05 GW Solar (~$5M/yr) vs 0.05 t/hr DAC (~$0.2k/yr) -> DAC would always win tiny gaps
                // We scale DAC step up so its minimum chunk is economically significant (~1 t/hr)
                function getTechStep(tech) {
                    if (tech === 'dac') return baseStep * 20.0;
                    if (tech.includes('battery') || tech === 'longduration') return baseStep * 2.0;
                    return baseStep;
                }

                // 1. SYSTEMATIC NEIGHBORHOOD SEARCH
                for (const tech of techs) {
                    if (marginalLCOE[tech] === Infinity) continue;

                    // Respect usage constraints
                    if (tech === 'dac' && window.optimizerOptions && !window.optimizerOptions.allowDAC) continue;

                    // CRITICAL FIX: Don't allow DAC for "easy" targets that can be achieved with conventional clean tech
                    // DAC should only be used when we're truly constrained (very aggressive target or hitting curtailment limits)
                    // Rule: Only allow DAC if target is <60% of baseline (very aggressive) OR we're hitting high curtailment (>15%)
                    if (tech === 'dac') {
                        const baselineCO2 = estimateBaselineFossilCO2();
                        const targetDifficulty = targetCO2 / baselineCO2;  // 1.0 = no reduction, 0.0 = zero emissions
                        const currentCurtailment = getCurrentCurtailmentRate(currentSolution);

                        // Allow DAC only if:
                        // 1. Target is very aggressive (<60% of baseline, i.e., >40% reduction), OR
                        // 2. We're hitting curtailment limits (>15%)
                        const isAggressiveTarget = targetDifficulty < 0.60;
                        const isHittingCurtailmentLimit = currentCurtailment > 0.15;

                        if (!isAggressiveTarget && !isHittingCurtailmentLimit) {
                            // Log why we're skipping DAC (only once per optimization)
                            if (!generateCandidates.dacSkipLogged) {
                                console.log(`[Iter ${iteration}] âš ï¸ Skipping DAC: Target ${(targetCO2/1e9).toFixed(1)}MT (${(targetDifficulty*100).toFixed(0)}% of baseline ${(baselineCO2/1e9).toFixed(1)}MT) is achievable with conventional clean tech. Curtailment: ${(currentCurtailment*100).toFixed(1)}%`);
                                generateCandidates.dacSkipLogged = true;
                            }
                            continue;  // Skip DAC
                        }
                    }

                    const effectiveStep = getTechStep(tech);

                    // Option A: Add capacity
                    const cAdd = { ...currentSolution };
                    cAdd[tech] = (cAdd[tech] || 0) + effectiveStep;
                    candidates.push(enforceCapacityBounds(cAdd));

                    // LOG: Track when DAC candidates are generated
                    if (tech === 'dac' && effectiveStep > 0) {
                        if (!generateCandidates.lastDACLog || iteration - generateCandidates.lastDACLog >= 50) {
                            console.log(`[Iter ${iteration}] ðŸ” DAC CANDIDATE GENERATED: +${effectiveStep.toFixed(1)} t/hr (Current: ${(currentSolution.dac || 0).toFixed(1)} t/hr, Marginal LCOE: ${marginalLCOE.dac.toFixed(2)} $/MWh-equivalent)`);
                            generateCandidates.lastDACLog = iteration;
                        }
                    }

                    // Option B: Remove capacity (only if it exists)
                    if ((currentSolution[tech] || 0) > 0.001) {
                        const cRem = { ...currentSolution };
                        // If capacity is smaller than effectiveStep, remove ALL of it (fix for "orphaned" small capacities from perturbations)
                        // Otherwise, remove by step size
                        if ((cRem[tech] || 0) < effectiveStep) {
                            cRem[tech] = 0;
                        } else {
                            cRem[tech] = Math.max(0, (cRem[tech] || 0) - effectiveStep);
                        }
                        candidates.push(enforceCapacityBounds(cRem));
                    }
                }

                // 2. TARGET-SPECIFIC HEURISTICS
                const currentCO2 = estimateCurrentCO2(currentSolution);

                // If we're significantly BELOW the CO2 target, try to reduce expensive capacity to lower cost
                // while allowing CO2 to increase towards the target
                if (targetCO2 && currentCO2 < targetCO2 * 0.95) {
                    // Calculate how much CO2 "room" we have
                    const co2Gap = targetCO2 - currentCO2;
                    const co2GapPercent = (co2Gap / targetCO2) * 100;

                    // Log this occasionally (every 50 iterations) to track reduction attempts
                    if (!generateCandidates.lastReductionLog || iteration - generateCandidates.lastReductionLog >= 50) {
                        console.log(`[Iter ${iteration}] Below target by ${co2GapPercent.toFixed(1)}% - generating candidates to cut NON-FLEXIBLE capacity`);
                        generateCandidates.lastReductionLog = iteration;
                    }

                    // CRITICAL: Only cut NON-FLEXIBLE technologies to avoid breaking reserve margin
                    // Flexible resources (batteries, RNG, hydrogen) are needed to meet 20% reserve margin
                    const flexibleTechs = ['battery4hr', 'battery8hr', 'longduration', 'rng', 'hydrogen', 'naturalGas', 'hydro'];
                    const nonFlexibleTechs = techs.filter(t => !flexibleTechs.includes(t));

                    // SMART CUTTING: Prioritize cutting clean baseload (nuclear, geothermal, biomass) over VRE (solar, wind)
                    // Baseload cuts are less likely to cause curtailment violations
                    const baseloadTechs = ['nuclear', 'geothermal', 'biomass'];
                    const vreTechs = ['solar', 'wind', 'offshoreWind'];

                    // Try cutting baseload first
                    const availableBaseload = nonFlexibleTechs
                        .filter(t => baseloadTechs.includes(t) && (currentSolution[t] || 0) > 0.5)
                        .sort((a, b) => (marginalLCOE[b] || 0) - (marginalLCOE[a] || 0));

                    // If no baseload available and we're far from target (>20%), try VRE
                    const availableVRE = (co2GapPercent > 20) ? nonFlexibleTechs
                        .filter(t => vreTechs.includes(t) && (currentSolution[t] || 0) > 1.0)
                        .sort((a, b) => (marginalLCOE[b] || 0) - (marginalLCOE[a] || 0)) : [];

                    const expensiveTechs = [...availableBaseload, ...availableVRE];

                    if (expensiveTechs.length === 0) {
                        // No non-flexible techs to cut - log and skip
                        if (!generateCandidates.lastNonFlexibleWarning || iteration - generateCandidates.lastNonFlexibleWarning >= 100) {
                            console.log(`[Iter ${iteration}] WARNING: Cannot reduce CO2 further - no cuttable non-flexible capacity`);
                            console.log(`  Baseload: ${baseloadTechs.map(t => `${t}=${(currentSolution[t] || 0).toFixed(1)}`).join(', ')}`);
                            console.log(`  VRE: ${vreTechs.map(t => `${t}=${(currentSolution[t] || 0).toFixed(1)}`).join(', ')}`);
                            generateCandidates.lastNonFlexibleWarning = iteration;
                        }
                    } else {
                        // Cut top 2 most expensive NON-FLEXIBLE techs with conservative step size
                        for (let i = 0; i < Math.min(2, expensiveTechs.length); i++) {
                            const tCut = expensiveTechs[i];
                            const cCut = { ...currentSolution };
                            // Conservative cut size to avoid constraint violations
                            const cutMultiplier = Math.min(5, 1 + (co2GapPercent / 10));  // Reduced from max=10
                            cCut[tCut] = Math.max(0, (cCut[tCut] || 0) - getTechStep(tCut) * cutMultiplier);
                            candidates.push(enforceCapacityBounds(cCut));
                        }
                    }
                }

                // 3. MINIMAL RANDOM EXPLORATION
                const allowedTechs = techs.filter(t => t !== 'dac' || (window.optimizerOptions && window.optimizerOptions.allowDAC));
                const randomTech = allowedTechs[Math.floor(Math.random() * allowedTechs.length)];

                if (randomTech) {
                    const cRand = { ...currentSolution };
                    const randStep = getTechStep(randomTech);
                    // Neutral bias (0.5) to avoid drift
                    cRand[randomTech] = Math.max(0, (cRand[randomTech] || 0) + (Math.random() - 0.5) * randStep);
                    candidates.push(enforceCapacityBounds(cRand));
                }

                return candidates;
            }

            // ===== LOCAL REFINEMENT (NELDER-MEAD) =====

            /**
             * Nelder-Mead simplex optimization for local refinement
             * Fine-tunes the solution found by heuristic search
             */
            function nelderMeadRefinement(initialSolution, targetCO2, options = {}) {
                const maxIterations = options.maxIterations || 50;
                const alpha = 1.0;   // Reflection coefficient
                const gamma = 2.0;   // Expansion coefficient
                const rho = 0.5;     // Contraction coefficient
                const sigma = 0.5;   // Shrink coefficient

                // Only optimize over technologies with non-zero capacity
                const activeTechs = OPTIMIZATION_CONFIG.TECHNOLOGIES.filter(tech =>
                    (initialSolution[tech] || 0) > 0.01
                );

                if (activeTechs.length === 0) {
                    return initialSolution;
                }

                console.log(`Nelder-Mead refinement starting with ${activeTechs.length} active technologies`);

                // Initialize simplex (N+1 points for N-dimensional space)
                // We create a local 'box' around the solution to find gradients in all directions
                const simplex = [];
                simplex.push({ solution: { ...initialSolution }, cost: null });

                // Create N additional points by perturbing each dimension
                // We alternate between perturbing UP and DOWN to avoid bias
                for (let i = 0; i < activeTechs.length; i++) {
                    const point = { ...initialSolution };
                    const tech = activeTechs[i];
                    // Smaller perturbation for batteries
                    const isStorage = tech.includes('battery') || tech === 'longduration';
                    const perturbation = (i % 2 === 0 ? 1.0 : -1.0) * (isStorage ? 2.0 : 0.5);

                    point[tech] = Math.max(0, point[tech] + perturbation);
                    simplex.push({ solution: point, cost: null });
                }

                // Evaluate all points in simplex
                for (let i = 0; i < simplex.length; i++) {
                    const result = evaluateSolutionFull(simplex[i].solution, targetCO2);
                    simplex[i].cost = result.isFeasible ? result.systemCost : Infinity;
                    simplex[i].isFeasible = result.isFeasible;
                }

                // Main Nelder-Mead loop
                for (let iter = 0; iter < maxIterations; iter++) {
                    // Sort by cost
                    simplex.sort((a, b) => a.cost - b.cost);

                    const best = simplex[0];
                    const worst = simplex[simplex.length - 1];
                    const secondWorst = simplex[simplex.length - 2];

                    // Check convergence (cost range < 1% of best)
                    if (best.cost < Infinity && worst.cost < Infinity) {
                        const costRange = worst.cost - best.cost;
                        if (costRange / best.cost < 0.01) {
                            console.log(`Nelder-Mead converged at iteration ${iter}`);
                            break;
                        }
                    }

                    // Calculate centroid (excluding worst point)
                    const centroid = {};
                    for (const tech of activeTechs) {
                        centroid[tech] = 0;
                        for (let i = 0; i < simplex.length - 1; i++) {
                            centroid[tech] += (simplex[i].solution[tech] || 0);
                        }
                        centroid[tech] /= (simplex.length - 1);
                    }

                    // REFLECTION
                    const reflected = {};
                    for (const tech of activeTechs) {
                        reflected[tech] = centroid[tech] + alpha * (centroid[tech] - (worst.solution[tech] || 0));
                    }
                    const reflectedBounded = enforceCapacityBounds(reflected);
                    const reflectedResult = evaluateSolutionFull(reflectedBounded, targetCO2);
                    const reflectedCost = reflectedResult.isFeasible ? reflectedResult.systemCost : Infinity;

                    if (reflectedCost < secondWorst.cost && reflectedCost >= best.cost) {
                        // Accept reflection
                        simplex[simplex.length - 1] = {
                            solution: reflectedBounded,
                            cost: reflectedCost,
                            isFeasible: reflectedResult.isFeasible
                        };
                        continue;
                    }

                    // EXPANSION
                    if (reflectedCost < best.cost) {
                        const expanded = {};
                        for (const tech of activeTechs) {
                            expanded[tech] = centroid[tech] + gamma * (reflectedBounded[tech] - centroid[tech]);
                        }
                        const expandedBounded = enforceCapacityBounds(expanded);
                        const expandedResult = evaluateSolutionFull(expandedBounded, targetCO2);
                        const expandedCost = expandedResult.isFeasible ? expandedResult.systemCost : Infinity;

                        if (expandedCost < reflectedCost) {
                            simplex[simplex.length - 1] = {
                                solution: expandedBounded,
                                cost: expandedCost,
                                isFeasible: expandedResult.isFeasible
                            };
                        } else {
                            simplex[simplex.length - 1] = {
                                solution: reflectedBounded,
                                cost: reflectedCost,
                                isFeasible: reflectedResult.isFeasible
                            };
                        }
                        continue;
                    }

                    // CONTRACTION
                    const contracted = {};
                    for (const tech of activeTechs) {
                        contracted[tech] = centroid[tech] + rho * ((worst.solution[tech] || 0) - centroid[tech]);
                    }
                    const contractedBounded = enforceCapacityBounds(contracted);
                    const contractedResult = evaluateSolutionFull(contractedBounded, targetCO2);
                    const contractedCost = contractedResult.isFeasible ? contractedResult.systemCost : Infinity;

                    if (contractedCost < worst.cost) {
                        simplex[simplex.length - 1] = {
                            solution: contractedBounded,
                            cost: contractedCost,
                            isFeasible: contractedResult.isFeasible
                        };
                        continue;
                    }

                    // SHRINK
                    for (let i = 1; i < simplex.length; i++) {
                        const shrunk = {};
                        for (const tech of activeTechs) {
                            shrunk[tech] = (best.solution[tech] || 0) + sigma * ((simplex[i].solution[tech] || 0) - (best.solution[tech] || 0));
                        }
                        const shrunkBounded = enforceCapacityBounds(shrunk);
                        const shrunkResult = evaluateSolutionFull(shrunkBounded, targetCO2);
                        simplex[i] = {
                            solution: shrunkBounded,
                            cost: shrunkResult.isFeasible ? shrunkResult.systemCost : Infinity,
                            isFeasible: shrunkResult.isFeasible
                        };
                    }
                }

                // Return best solution
                simplex.sort((a, b) => a.cost - b.cost);
                const initialCostEval = evaluateSolutionFull(initialSolution, targetCO2);
                console.log(`Nelder-Mead refinement: $${(initialCostEval.systemCost / 1e9).toFixed(2)}B â†’ $${(simplex[0].cost / 1e9).toFixed(2)}B`);
                return simplex[0].solution;
            }

            // ===== MAIN OPTIMIZATION FUNCTION =====

            /**
             * Main capacity expansion optimization function
             * Finds optimal capacity additions to meet CO2 target at minimum cost
             */
            async function optimizeCapacityExpansion(targetCO2, options = {}) {
                console.log('Starting capacity expansion optimization...');
                console.log('Target CO2:', (targetCO2 / 1e9).toFixed(2), 'million MT');
                console.log('Options:', { allowDAC: options.allowDAC, respectCurtailment: options.respectCurtailment });

                // CRITICAL FIX: Completely disable DAC for easy targets by removing it from TECHNOLOGIES list
                // This ensures it can NEVER enter the solution through any path (generation, perturbation, etc.)
                const initialBaselineCO2 = estimateBaselineFossilCO2();
                const targetDifficulty = targetCO2 / initialBaselineCO2;
                const isEasyTarget = targetDifficulty >= 0.60;  // Target is >60% of baseline (easy)

                // Save original TECHNOLOGIES list to restore later
                const originalTechnologies = [...OPTIMIZATION_CONFIG.TECHNOLOGIES];
                let dacWasDisabled = false;

                if (isEasyTarget && !options.forceAllowDAC) {
                    console.log(`ðŸš« DAC DISABLED: Target ${(targetCO2/1e9).toFixed(1)}MT is ${(targetDifficulty*100).toFixed(0)}% of baseline ${(initialBaselineCO2/1e9).toFixed(1)}MT (easy target, DAC not needed)`);
                    // Temporarily modify TECHNOLOGIES to exclude DAC
                    OPTIMIZATION_CONFIG.TECHNOLOGIES = OPTIMIZATION_CONFIG.TECHNOLOGIES.filter(t => t !== 'dac');
                    dacWasDisabled = true;
                } else if (!isEasyTarget) {
                    console.log(`âœ… DAC ENABLED: Target ${(targetCO2/1e9).toFixed(1)}MT is ${(targetDifficulty*100).toFixed(0)}% of baseline ${(initialBaselineCO2/1e9).toFixed(1)}MT (aggressive target)`);
                }

                // Store options globally for use in feasibility checks
                window.optimizerOptions = options;

                // Clear solution cache for this optimization run
                clearSolutionCache();

                // Reset the infeasible logging flag for this optimization run
                checkFeasibility.firstInfeasibleLogged = false;

                // Reset the reduction logging counters for this optimization run
                generateCandidates.lastReductionLog = undefined;
                generateCandidates.lastNonFlexibleWarning = undefined;
                generateCandidates.lastDACLog = undefined;
                generateCandidates.dacSkipLogged = undefined;

                // Reset LCOE logging counter
                calculateMarginalLCOEWithSystemValue.lastLog = undefined;

                // Initialize solution with smart starting point (not zero)
                // Calculate what we need to meet CO2 target
                const baselineCO2 = estimateBaselineFossilCO2();
                const co2Reduction = Math.max(0, baselineCO2 - targetCO2);
                console.log(`Need to reduce CO2 by ${(co2Reduction / 1e9).toFixed(1)} million MT`);

                // Initialize with a reasonable starting point
                let currentSolution = {};
                for (const tech of OPTIMIZATION_CONFIG.TECHNOLOGIES) {
                    currentSolution[tech] = 0;
                }

                // Add initial capacity to help algorithm get started
                // Heuristic based on empirical observation: ~1.1 million MT CO2 reduction per GW of clean capacity
                // (from test: 80 GW total â†’ 87 million MT reduction, so 1.09 million MT/GW)
                const totalCleanCapacityNeeded = co2Reduction / 1.1e9;  // GW needed (co2Reduction is in kg, 1.1e9 kg = 1.1 million MT)

                // Split 60/40 between solar and wind (solar is cheaper but more variable)
                const initialSolar = Math.min(100, totalCleanCapacityNeeded * 0.6);
                const initialWind = Math.min(80, totalCleanCapacityNeeded * 0.4);
                const initialBattery = Math.min(50, (initialSolar + initialWind) * 0.25);  // 25% of VRE capacity

                currentSolution.solar = initialSolar;
                currentSolution.wind = initialWind;
                currentSolution.battery4hr = initialBattery;

                // Check reserve margin requirement and add flexible capacity if needed
                const peakDemand = Math.max(...optimizationContext.demand);
                const requiredFlexibleCapacity = peakDemand * 1.2;  // 20% reserve margin means 1.2x peak
                const baselineFlexibleCapacity =
                    (optimizationContext.baselineCapacity.naturalGas || 0) +
                    (optimizationContext.baselineCapacity.hydro || 0) +
                    (optimizationContext.baselineCapacity.rng || 0) +
                    (optimizationContext.baselineCapacity.hydrogen || 0) +
                    ((optimizationContext.baselineStorage?.battery4hr || 0) / 4) +
                    ((optimizationContext.baselineStorage?.battery8hr || 0) / 8) +
                    ((optimizationContext.baselineStorage?.longduration || 0) / 24);

                const flexibleCapacityGap = requiredFlexibleCapacity - baselineFlexibleCapacity;

                if (flexibleCapacityGap > 0) {
                    console.log(`Reserve margin gap detected: need ${flexibleCapacityGap.toFixed(1)} GW more flexible capacity`);
                    console.log(`  Peak Demand: ${peakDemand.toFixed(1)} GW â†’ Required Flexible: ${requiredFlexibleCapacity.toFixed(1)} GW`);
                    console.log(`  Baseline Flexible Capacity: ${baselineFlexibleCapacity.toFixed(1)} GW`);
                    console.log(`  NOTE: Biomass is NOT counted as flexible capacity`);

                    // Add flexible resources to meet reserve margin
                    // Priority: Battery storage (most flexible) > RNG > Hydrogen
                    const additionalBattery = Math.min(100 - currentSolution.battery4hr, flexibleCapacityGap * 4 * 0.8);  // 80% as 4hr battery
                    const additionalRNG = Math.min(20, flexibleCapacityGap * 0.15);  // 15% as RNG
                    const additionalHydrogen = Math.min(20, flexibleCapacityGap * 0.05);  // 5% as Hydrogen

                    currentSolution.battery4hr += additionalBattery;
                    currentSolution.rng = additionalRNG;
                    currentSolution.hydrogen = additionalHydrogen;

                    console.log(`  Adding flexible resources: +${additionalBattery.toFixed(1)} GWh battery4hr, +${additionalRNG.toFixed(1)} GW RNG, +${additionalHydrogen.toFixed(1)} GW Hydrogen`);
                }

                console.log('CO2 reduction heuristic: need ' + totalCleanCapacityNeeded.toFixed(1) + ' GW total â†’ starting with ' + initialSolar.toFixed(1) + ' GW solar + ' + initialWind.toFixed(1) + ' GW wind');

                // ADAPTIVE INITIAL GUESS: If previous optimization was significantly below target, scale down
                // This prevents re-optimization from overshooting again
                // IMPORTANT: Only apply once - track with lastOptimizationWasScaled flag to prevent compounding
                const shouldApplyScaling = window.lastOptimizationCO2 &&
                                          window.lastOptimizationCO2 < targetCO2 * 0.95 &&
                                          !window.lastOptimizationWasScaled;  // Don't compound scaling

                if (shouldApplyScaling) {
                    const previousGap = targetCO2 - window.lastOptimizationCO2;
                    const previousGapPercent = (previousGap / targetCO2) * 100;
                    console.log(`âš ï¸  Previous optimization was ${previousGapPercent.toFixed(1)}% below target (${(window.lastOptimizationCO2 / 1e9).toFixed(2)} MT vs ${(targetCO2 / 1e9).toFixed(2)} MT target)`);
                    console.log(`Applying ONE-TIME adaptive scaling to avoid overshooting again...`);

                    // Scale down clean energy capacity proportionally (but not too aggressively)
                    // Limit scaling to max 50% reduction to avoid going too low
                    const scaleFactor = Math.max(0.5, 1.0 - (previousGapPercent / 100));
                    currentSolution.solar *= scaleFactor;
                    currentSolution.wind *= scaleFactor;
                    // Only scale down non-flexible capacity; keep flexible resources for reserve margin
                    // currentSolution.battery4hr *= scaleFactor;  // Keep battery to maintain flexibility
                    // if (currentSolution.rng) currentSolution.rng *= scaleFactor;  // Keep RNG for flexibility
                    // if (currentSolution.hydrogen) currentSolution.hydrogen *= scaleFactor;  // Keep hydrogen for flexibility

                    console.log(`Applied scale factor: ${scaleFactor.toFixed(2)}x to VRE (capped at 0.5 minimum)`);
                    console.log(`  â†’ Scaled Solar: ${currentSolution.solar.toFixed(1)} GW, Wind: ${currentSolution.wind.toFixed(1)} GW`);
                    console.log(`  â†’ Kept flexible resources unchanged: Battery ${currentSolution.battery4hr.toFixed(1)} GWh, RNG ${(currentSolution.rng || 0).toFixed(1)} GW, H2 ${(currentSolution.hydrogen || 0).toFixed(1)} GW`);

                    // Mark that scaling was applied to prevent compounding on next re-optimization
                    window.lastOptimizationWasScaled = true;
                } else {
                    // Scaling not applied - mark as false so next optimization can scale if needed
                    if (window.lastOptimizationWasScaled) {
                        console.log(`â„¹ï¸  Adaptive scaling already applied in previous run - using standard initial guess to avoid compounding`);
                    }
                    window.lastOptimizationWasScaled = false;
                }

                console.log('Starting with initial guess:', JSON.stringify(currentSolution));

                // Evaluate initial guess to see if it's in the right ballpark
                const initialEval = evaluateSolutionFull(currentSolution, targetCO2);
                console.log('Initial guess evaluation:', {
                    cost: (initialEval.systemCost / 1e9).toFixed(2) + 'B',
                    co2: (initialEval.annualCO2 / 1e6).toFixed(2) + ' MT',
                    target: (targetCO2 / 1e6).toFixed(2) + ' MT',
                    isFeasible: initialEval.isFeasible,
                    reasons: initialEval.feasibility?.reasons
                });

                let bestFeasibleSolution = null;
                let bestFeasibleCost = Infinity;
                let iteration = 0;
                let noImprovementCount = 0;
                let totalFeasibleFound = 0;

                // Progress tracking
                const startTime = Date.now();

                // Main optimization loop
                while (iteration < OPTIMIZATION_CONFIG.MAX_ITERATIONS) {
                    // Log progress every 25 iterations
                    if (iteration % 25 === 0 && bestFeasibleSolution) {
                        const co2Gap = targetCO2 - bestFeasibleSolution.co2;
                        const gapPercent = (co2Gap / targetCO2) * 100;
                        console.log(`[Iter ${iteration}] Best: Cost=${(bestFeasibleCost / 1e9).toFixed(2)}B, CO2=${(bestFeasibleSolution.co2 / 1e9).toFixed(2)}MT (target: ${(targetCO2 / 1e9).toFixed(2)}MT, gap: ${gapPercent.toFixed(1)}%)`);
                    }

                    // STEP 1: Calculate marginal LCOE with system value adjustments
                    const marginalLCOE = calculateMarginalLCOEWithSystemValue(
                        currentSolution,
                        targetCO2,
                        iteration
                    );

                    // STEP 2: Generate candidate solutions
                    const candidates = generateCandidates(
                        currentSolution,
                        marginalLCOE,
                        iteration,
                        targetCO2
                    );

                    // STEP 3: Quick feasibility pre-screening
                    const viableCandidates = candidates.filter(c =>
                        quickFeasibilityCheck(c, targetCO2)
                    );

                    // STEP 4: Full evaluation of viable candidates
                    const evaluatedCandidates = [];
                    let dacCandidatesThisIter = 0;
                    for (const candidate of viableCandidates) {
                        const result = evaluateSolutionFull(candidate, targetCO2);
                        evaluatedCandidates.push({
                            solution: candidate,
                            cost: result.systemCost,
                            co2: result.annualCO2,
                            isFeasible: result.isFeasible,
                            metrics: result.metrics,
                            feasibility: result.feasibility
                        });

                        // Track DAC candidates
                        if (candidate.dac && candidate.dac > 0.1) {
                            dacCandidatesThisIter++;
                        }
                    }

                    // LOG: Report if DAC candidates were evaluated
                    if (dacCandidatesThisIter > 0 && iteration % 50 === 0) {
                        console.log(`[Iter ${iteration}] Evaluated ${dacCandidatesThisIter} candidates with DAC out of ${evaluatedCandidates.length} total`);
                    }

                    // STEP 5: Select best feasible solution
                    const feasibleCandidates = evaluatedCandidates.filter(c => c.isFeasible);

                    if (feasibleCandidates.length > 0) {
                        totalFeasibleFound += feasibleCandidates.length;

                        // MODIFIED SELECTION CRITERION: When significantly below target, prefer solutions closer to target
                        // even if they cost slightly more. This prevents getting stuck at overly clean solutions.
                        let bestCandidate;
                        if (bestFeasibleSolution && bestFeasibleSolution.co2 < targetCO2 * 0.90) {
                            // We're significantly below target (>10% below) - use weighted objective
                            // Penalize being below target to push towards it
                            bestCandidate = feasibleCandidates.reduce((best, curr) => {
                                const co2GapBest = Math.abs(targetCO2 - best.co2) / targetCO2;
                                const co2GapCurr = Math.abs(targetCO2 - curr.co2) / targetCO2;

                                // Weighted objective: 70% cost, 30% proximity to target
                                const scoreBest = (best.cost / bestFeasibleCost) * 0.7 + co2GapBest * 0.3;
                                const scoreCurr = (curr.cost / bestFeasibleCost) * 0.7 + co2GapCurr * 0.3;

                                return scoreCurr < scoreBest ? curr : best;
                            });
                        } else {
                            // Normal operation - minimize cost
                            bestCandidate = feasibleCandidates.reduce((best, curr) =>
                                curr.cost < best.cost ? curr : best
                            );
                        }

                        const costImproved = bestCandidate.cost < bestFeasibleCost;
                        const co2Improved = bestFeasibleSolution && Math.abs(bestCandidate.co2 - targetCO2) < Math.abs(bestFeasibleSolution.co2 - targetCO2);

                        if (costImproved || co2Improved) {
                            // Determine if this is a meaningful improvement
                            let isMeaningfulImprovement = false;

                            if (costImproved && bestCandidate.cost < bestFeasibleCost * 0.9999) {
                                // Meaningful cost improvement (>0.01%)
                                isMeaningfulImprovement = true;
                            } else if (co2Improved && bestFeasibleSolution) {
                                // Check if CO2 improvement is meaningful (>1% reduction in gap)
                                const oldGap = Math.abs(bestFeasibleSolution.co2 - targetCO2);
                                const newGap = Math.abs(bestCandidate.co2 - targetCO2);
                                const gapReduction = (oldGap - newGap) / oldGap;

                                if (gapReduction > 0.01) {  // >1% reduction in CO2 gap
                                    isMeaningfulImprovement = true;
                                }
                            }

                            if (isMeaningfulImprovement) {
                                noImprovementCount = 0;
                            } else {
                                noImprovementCount++;
                            }

                            currentSolution = bestCandidate.solution;
                            bestFeasibleCost = bestCandidate.cost;
                            bestFeasibleSolution = bestCandidate;

                            // LOG: If DAC solution was selected, explain why
                            if (bestCandidate.solution.dac && bestCandidate.solution.dac > 0.1) {
                                console.log(`[Iter ${iteration}] âš ï¸ DAC SOLUTION SELECTED!`);
                                console.log(`  DAC Capacity: ${bestCandidate.solution.dac.toFixed(1)} t/hr`);
                                console.log(`  Cost: $${(bestCandidate.cost / 1e9).toFixed(2)}B/yr`);
                                console.log(`  CO2: ${(bestCandidate.co2 / 1e9).toFixed(2)} MT (target: ${(targetCO2 / 1e9).toFixed(2)} MT)`);
                                console.log(`  Reserve Margin: ${(bestCandidate.metrics.reserveMargin * 100).toFixed(1)}%`);
                                console.log(`  Curtailment: ${(bestCandidate.metrics.curtailmentRate * 100).toFixed(1)}%`);

                                // Compare to alternatives without DAC
                                const nonDACCandidates = feasibleCandidates.filter(c => !c.solution.dac || c.solution.dac < 0.1);
                                if (nonDACCandidates.length > 0) {
                                    const bestNonDAC = nonDACCandidates.reduce((best, curr) => curr.cost < best.cost ? curr : best);
                                    console.log(`  Best non-DAC alternative: Cost=$${(bestNonDAC.cost / 1e9).toFixed(2)}B, CO2=${(bestNonDAC.co2 / 1e9).toFixed(2)}MT`);
                                    console.log(`  Why DAC won: Cost ${bestCandidate.cost < bestNonDAC.cost ? 'LOWER' : 'HIGHER'} (Î”$${((bestCandidate.cost - bestNonDAC.cost) / 1e9).toFixed(2)}B)`);
                                } else {
                                    console.log(`  âŒ No non-DAC feasible alternatives found - DAC was only feasible option!`);

                                    // ENHANCED DIAGNOSTIC: Show WHY non-DAC candidates failed
                                    const nonDACEvaluated = evaluatedCandidates.filter(c => !c.solution.dac || c.solution.dac < 0.1);
                                    if (nonDACEvaluated.length > 0) {
                                        console.log(`  ðŸ“Š CONSTRAINT ANALYSIS: Why ${nonDACEvaluated.length} non-DAC candidates failed:`);

                                        // Aggregate constraint violations
                                        const violationCounts = {
                                            co2: 0,
                                            curtailment: 0,
                                            reserveMargin: 0,
                                            energyBalance: 0
                                        };

                                        nonDACEvaluated.forEach(cand => {
                                            if (cand.feasibility?.checks) {
                                                if (!cand.feasibility.checks.co2) violationCounts.co2++;
                                                if (!cand.feasibility.checks.curtailment) violationCounts.curtailment++;
                                                if (!cand.feasibility.checks.reserveMargin) violationCounts.reserveMargin++;
                                                if (!cand.feasibility.checks.energyBalance) violationCounts.energyBalance++;
                                            }
                                        });

                                        console.log(`     - CO2 violations: ${violationCounts.co2}/${nonDACEvaluated.length} (${(violationCounts.co2/nonDACEvaluated.length*100).toFixed(0)}%)`);
                                        console.log(`     - Curtailment violations: ${violationCounts.curtailment}/${nonDACEvaluated.length} (${(violationCounts.curtailment/nonDACEvaluated.length*100).toFixed(0)}%)`);
                                        console.log(`     - Reserve Margin violations: ${violationCounts.reserveMargin}/${nonDACEvaluated.length} (${(violationCounts.reserveMargin/nonDACEvaluated.length*100).toFixed(0)}%)`);
                                        console.log(`     - Energy Balance violations: ${violationCounts.energyBalance}/${nonDACEvaluated.length} (${(violationCounts.energyBalance/nonDACEvaluated.length*100).toFixed(0)}%)`);

                                        // Show a sample non-DAC candidate with full details
                                        const sampleNonDAC = nonDACEvaluated[0];
                                        console.log(`  ðŸ” Sample non-DAC candidate details:`);
                                        console.log(`     Technologies: ${JSON.stringify(sampleNonDAC.solution)}`);
                                        console.log(`     CO2: ${(sampleNonDAC.co2 / 1e9).toFixed(2)} MT (target: ${(targetCO2 / 1e9).toFixed(2)} MT) ${sampleNonDAC.feasibility?.checks?.co2 ? 'âœ“' : 'âœ—'}`);
                                        console.log(`     Curtailment: ${(sampleNonDAC.metrics.curtailmentRate * 100).toFixed(1)}% (max: 20%) ${sampleNonDAC.feasibility?.checks?.curtailment ? 'âœ“' : 'âœ—'}`);
                                        console.log(`     Reserve Margin: ${(sampleNonDAC.metrics.reserveMargin * 100).toFixed(1)}% (min: 20%) ${sampleNonDAC.feasibility?.checks?.reserveMargin ? 'âœ“' : 'âœ—'}`);
                                        console.log(`     Energy Balance: ${sampleNonDAC.feasibility?.checks?.energyBalance ? 'âœ“' : 'âœ—'}`);
                                        if (sampleNonDAC.feasibility?.reasons && sampleNonDAC.feasibility.reasons.length > 0) {
                                            console.log(`     Failure reasons: ${sampleNonDAC.feasibility.reasons.join('; ')}`);
                                        }
                                    } else {
                                        console.log(`  âš ï¸ No non-DAC candidates were even generated this iteration!`);
                                    }
                                }
                            }

                            // Log if we're significantly below target (potential for cost reduction)
                            if (bestCandidate.co2 < targetCO2 * 0.95) {
                                const co2Gap = targetCO2 - bestCandidate.co2;
                                console.log(`[Iteration ${iteration}] Solution below target: ${(bestCandidate.co2 / 1e9).toFixed(2)} MT (target: ${(targetCO2 / 1e9).toFixed(2)} MT, gap: ${(co2Gap / 1e9).toFixed(2)} MT) - exploring cost reduction opportunities`);
                            }
                        } else {
                            noImprovementCount++;
                        }
                    } else {
                        // FALBACK: If no feasible solution, move towards feasibility (minimize CO2)
                        // This prevents getting stuck in an infeasible local minimum
                        if (evaluatedCandidates.length > 0) {
                            // Find best infeasible candidate to move towards feasibility
                            // PRIORITY 1: If Reserve Margin is the issue, pick highest reserve margin
                            const currentMargin = calculateReserveMargin(currentSolution, optimizationContext.demand, optimizationContext.baselineCapacity, optimizationContext.baselineStorage);

                            let bestInfeasible;

                            if (currentMargin < OPTIMIZATION_CONFIG.RESERVE_MARGIN_TARGET) {
                                // We are failing on reliability -> Maximize Reserve Margin
                                bestInfeasible = evaluatedCandidates.reduce((best, curr) =>
                                    (curr.metrics.reserveMargin > best.metrics.reserveMargin) ? curr : best
                                );
                            } else {
                                // We are failing on CO2 -> Minimize CO2
                                bestInfeasible = evaluatedCandidates.reduce((best, curr) =>
                                    curr.co2 < best.co2 ? curr : best
                                );
                            }

                            // Update current solution to follow the gradient towards feasibility
                            currentSolution = bestInfeasible.solution;

                            // DEBUG: Log why we are stuck
                            if (iteration % 10 === 0) {
                                console.log(`Iter ${iteration} [INFEASIBLE]: Margin=${(currentMargin * 100).toFixed(1)}% (Target ${OPTIMIZATION_CONFIG.RESERVE_MARGIN_TARGET * 100}%), CO2=${(bestInfeasible.co2 / 1e6).toFixed(2)}M. Strategy: ${currentMargin < OPTIMIZATION_CONFIG.RESERVE_MARGIN_TARGET ? 'MAX_MARGIN' : 'MIN_CO2'}`);

                                // Log which constraints are failing
                                const failedChecks = Object.entries(bestInfeasible.feasibility.checks)
                                    .filter(([k, v]) => !v)
                                    .map(([k]) => k);
                                console.log('Failed constraints:', failedChecks.join(', '));
                                console.log('Failure reasons:', bestInfeasible.feasibility.reasons);

                                if (currentMargin < OPTIMIZATION_CONFIG.RESERVE_MARGIN_TARGET) {
                                    console.log('Best Margin Candidate:', (bestInfeasible.metrics.reserveMargin * 100).toFixed(1) + '%');
                                    console.log('Candidate Gen:', JSON.stringify(bestInfeasible.solution));
                                }
                            }

                            // PANIC MODE: If we are failing reserve margin for 20 iters, force add dispatchable
                            if (currentMargin < OPTIMIZATION_CONFIG.RESERVE_MARGIN_TARGET && noImprovementCount > 20) {
                                console.log('!!! PANIC MODE: FORCING FLEXIBLE CAPACITY ADDITION !!!');
                                // Force add 5 GW of battery/hydrogen randomly to break deadlock
                                const flex = ['battery4hr', 'longduration', 'hydrogen', 'geothermal'];
                                const pick = flex[Math.floor(Math.random() * flex.length)];
                                currentSolution[pick] = (currentSolution[pick] || 0) + 5.0;
                                noImprovementCount = 0; // Reset counter so we don't exit early
                            }
                        }

                        noImprovementCount++;

                        // Debug: Log why candidates are infeasible (more verbose at start)
                        if (iteration < 20 || (iteration < 100 && iteration % 10 === 0)) {
                            if (evaluatedCandidates.length > 0) {
                                const sample = evaluatedCandidates[0];
                                console.log(`Iteration ${iteration}: No feasible. Sample:`, {
                                    solution: JSON.stringify(sample.solution),
                                    co2: (sample.co2 / 1e6).toFixed(2) + ' MT',
                                    reasons: sample.feasibility?.reasons
                                });
                            } else if (viableCandidates.length === 0) {
                                console.log(`Iteration ${iteration}: No viable candidates passed quickFeasibilityCheck. Generated ${candidates.length} candidates from solution:`, JSON.stringify(currentSolution));
                            }
                        }
                    }

                    // STEP 6: Convergence detection and early stopping
                    // If the best cost hasn't improved by even 0.01% for 50 iterations, we've likely converged
                    // EXCEPTION: If we're significantly below target, allow MANY more iterations to find solutions closer to target
                    const isBelowTarget = bestFeasibleSolution && bestFeasibleSolution.co2 < targetCO2 * 0.90;
                    let convergenceThreshold = isBelowTarget ? 200 : 50;  // 4x threshold when below target (increased from 2x)

                    // Additional check: if we're below target but have <3 GW total non-flexible capacity left,
                    // we've hit a physical limit and should stop even if we haven't converged cost-wise
                    if (isBelowTarget && bestFeasibleSolution) {
                        const baseloadCapacityLeft = ['nuclear', 'geothermal', 'biomass']
                            .reduce((sum, tech) => sum + (bestFeasibleSolution.solution[tech] || 0), 0);
                        const nonFlexibleCapacityLeft = ['solar', 'wind', 'offshoreWind', 'nuclear', 'geothermal', 'biomass']
                            .reduce((sum, tech) => sum + (bestFeasibleSolution.solution[tech] || 0), 0);

                        if (baseloadCapacityLeft < 1.0 && nonFlexibleCapacityLeft < 8.0) {
                            // Very little baseload left AND low total non-flexible - accept solution
                            console.log(`[Iter ${iteration}] Near-minimum capacity (baseload: ${baseloadCapacityLeft.toFixed(1)} GW, total non-flex: ${nonFlexibleCapacityLeft.toFixed(1)} GW) - accepting current solution even though ${((targetCO2 - bestFeasibleSolution.co2) / targetCO2 * 100).toFixed(1)}% below target`);
                            convergenceThreshold = 50;  // Reduce threshold to accept solution sooner
                        }
                    }

                    if (bestFeasibleSolution && noImprovementCount > convergenceThreshold) {
                        const co2Gap = targetCO2 - bestFeasibleSolution.co2;
                        const gapPercent = (co2Gap / targetCO2) * 100;
                        if (isBelowTarget) {
                            console.log(`Convergence reached at iteration ${iteration} (extended threshold due to ${gapPercent.toFixed(1)}% below target)`);
                        } else {
                            console.log(`Convergence reached at iteration ${iteration}`);
                        }
                        break;
                    }

                    // STEP 6a: Adaptive exploration - perturb if stuck
                    if (noImprovementCount > 30) {
                        console.log(`Iteration ${iteration}: Perturbing solution to escape local minimum`);
                        currentSolution = perturbSolution(currentSolution, iteration, targetCO2);
                        // CRITICAL FIX: Do NOT reset noImprovementCount here.
                        // This allows the optimizer to hit the failure threshold (50) and stop
                        // if the perturbation doesn't yield a better result quickly.
                    }

                    // STEP 7: Progress callback
                    if (options.progressCallback) {
                        options.progressCallback(
                            iteration,
                            bestFeasibleCost,
                            bestFeasibleSolution?.co2 || null
                        );
                    }

                    iteration++;

                    // Yield control periodically to prevent browser freeze and allow UI updates
                    // Yield every iteration to ensure the user sees 1, 2, 3... count
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                const elapsedTime = (Date.now() - startTime) / 1000;
                console.log(`Optimization complete in ${elapsedTime.toFixed(1)}s (${iteration} iterations)`);

                // STEP 8: Return results
                if (!bestFeasibleSolution) {
                    console.error('No feasible solution found after', iteration, 'iterations');
                    console.error('Total feasible candidates found:', totalFeasibleFound);
                    console.error('Target CO2:', (targetCO2 / 1e9).toFixed(2), 'million MT');
                    console.error('Baseline CO2:', (baselineCO2 / 1e9).toFixed(2), 'million MT');

                    // Try to diagnose the issue
                    const testSolution = {
                        solar: 50,
                        wind: 30,
                        nuclear: 10,
                        battery4hr: 20,
                        geothermal: 5
                    };
                    console.log('Testing a large solution to diagnose:');
                    const testResult = evaluateSolutionFull(testSolution, targetCO2);
                    console.log('Test result:', {
                        cost: (testResult.systemCost / 1e9).toFixed(2) + 'B',
                        co2: (testResult.annualCO2 / 1e9).toFixed(2) + ' million MT',
                        isFeasible: testResult.isFeasible,
                        reasons: testResult.feasibility?.reasons
                    });

                    return {
                        success: false,
                        message: "Could not find solution meeting CO2 target. Try: (1) Relax target, (2) Enable DAC, (3) Check if target is achievable. See console for diagnostics.",
                        targetCO2: targetCO2,
                        iterations: iteration,
                        diagnostics: testResult
                    };
                }

                // STEP 8a: Local refinement with Nelder-Mead
                console.log('Applying Nelder-Mead local refinement...');
                const refinedSolution = nelderMeadRefinement(
                    bestFeasibleSolution.solution,
                    targetCO2,
                    { maxIterations: 150 }  // Increased from 100 for better fine-tuning
                );

                // Final evaluation to get complete results
                const finalEvaluation = evaluateSolutionFull(refinedSolution, targetCO2);

                // Store optimization results globally for comparison
                window.lastOptimizationCO2 = finalEvaluation.annualCO2;
                window.lastOptimizationCurtailment = finalEvaluation.metrics.curtailmentRate;
                window.lastOptimizationCost = finalEvaluation.systemCost;
                // Note: window.lastOptimizationWasScaled is already set earlier in the function (true if scaled, stays false/undefined otherwise)

                console.log('Optimal solution found (after refinement):');
                console.log('- Cost:', (finalEvaluation.systemCost / 1e9).toFixed(2), 'billion $/year');
                console.log('- CO2:', (finalEvaluation.annualCO2 / 1e9).toFixed(2), 'million MT', `(target: ${(targetCO2 / 1e9).toFixed(2)} MT)`);

                // Highlight if solution is significantly below target
                if (finalEvaluation.annualCO2 < targetCO2 * 0.95) {
                    const co2Gap = targetCO2 - finalEvaluation.annualCO2;
                    const gapPercent = (co2Gap / targetCO2 * 100).toFixed(1);
                    console.log(`  âš ï¸  Solution is ${gapPercent}% below target (${(co2Gap / 1e9).toFixed(2)} MT gap)`);
                    console.log('  â†’ This solution exceeds the CO2 target. A less expensive solution closer to the target may exist.');
                    console.log('  â†’ Consider running optimization again or adjusting capacity mix to get closer to target.');
                }

                console.log('- Reserve margin:', (finalEvaluation.metrics.reserveMargin * 100).toFixed(1), '%');
                console.log('- Curtailment:', (finalEvaluation.metrics.curtailmentRate * 100).toFixed(1), '%');

                // DEBUG: Detailed curtailment breakdown
                console.log('=== OPTIMIZATION MODE RESULT OBJECT ANALYSIS ===');
                console.log('Generation keys:', Object.keys(finalEvaluation.simulationResult.generation));
                console.log('Has curtailment key?', 'curtailment' in finalEvaluation.simulationResult.generation);
                console.log('Curtailment array length:', finalEvaluation.simulationResult.generation.curtailment?.length);
                console.log('Curtailment is all zeros?', finalEvaluation.simulationResult.generation.curtailment?.every(v => v === 0));

                const totalCurtailmentGWh = finalEvaluation.simulationResult.generation.curtailment.reduce((sum, val, i) => {
                    const monthIndex = Math.floor(i / 24) % 12;
                    return sum + val * DAYS_IN_MONTH[monthIndex];
                }, 0);
                console.log('Optimization mode total curtailment:', totalCurtailmentGWh.toFixed(2), 'GWh/year');
                console.log('Optimization mode curtailment sample (hours 10-20, peak solar):');
                const optCurtSample = finalEvaluation.simulationResult.generation.curtailment.slice(10, 20);
                optCurtSample.forEach((val, i) => console.log(`  Hour ${i + 10}: ${val.toFixed(4)} GW`));
                console.log('Optimization mode curtailment all hours sum check:');
                const optCurtAllHours = finalEvaluation.simulationResult.generation.curtailment.reduce((sum, val) => sum + val, 0);
                console.log(`  Total hourly curtailment (not annualized): ${optCurtAllHours.toFixed(2)} GWh`);

                // Find WHICH hours have non-zero curtailment in optimization
                const optHoursWithCurtailment = [];
                finalEvaluation.simulationResult.generation.curtailment.forEach((val, i) => {
                    if (val > 0.001) {
                        optHoursWithCurtailment.push({ hour: i, value: val.toFixed(4), month: Math.floor(i / 24) });
                    }
                });
                console.log(`Found ${optHoursWithCurtailment.length} hours with curtailment > 0:`, optHoursWithCurtailment.slice(0, 20));

                // Check solar + wind generation
                const optSolarGen = finalEvaluation.simulationResult.generation.solar?.slice(10, 20).reduce((sum, v) => sum + v, 0);
                const optWindGen = finalEvaluation.simulationResult.generation.wind?.slice(10, 20).reduce((sum, v) => sum + v, 0);
                console.log(`Optimization mode solar gen (hours 10-20): ${optSolarGen?.toFixed(2)} GWh`);
                console.log(`Optimization mode wind gen (hours 10-20): ${optWindGen?.toFixed(2)} GWh`);
                console.log('Capacity additions:');
                for (const tech of OPTIMIZATION_CONFIG.TECHNOLOGIES) {
                    const capacity = refinedSolution[tech];
                    if (capacity > 0.1) {
                        const unit = tech === 'dac' ? 't/hr' :
                            (tech.includes('battery') || tech === 'longduration') ? 'GWh' : 'GW';
                        console.log(`  - ${tech}: +${capacity.toFixed(1)} ${unit}`);
                    }
                }

                // Performance statistics
                const totalEvaluations = cacheHits + cacheMisses;
                const cacheHitRate = totalEvaluations > 0 ? (cacheHits / totalEvaluations * 100).toFixed(1) : 0;
                console.log('Performance:');
                console.log(`- Total evaluations: ${totalEvaluations}`);
                console.log(`- Cache hits: ${cacheHits} (${cacheHitRate}% hit rate)`);
                console.log(`- Cache misses: ${cacheMisses}`);

                // Restore TECHNOLOGIES list if we modified it
                if (dacWasDisabled) {
                    OPTIMIZATION_CONFIG.TECHNOLOGIES = originalTechnologies;
                    console.log('âœ… DAC re-enabled in TECHNOLOGIES list for future optimizations');
                }

                return {
                    success: true,
                    solution: refinedSolution,
                    cost: finalEvaluation.systemCost,
                    co2: finalEvaluation.annualCO2,
                    targetCO2: targetCO2,  // Include target for display
                    metrics: finalEvaluation.metrics,
                    feasibility: finalEvaluation.feasibility,
                    iterations: iteration,
                    elapsedTime: elapsedTime
                };
            }


            // ============================================
            // COST EDITOR LOGIC
            // ============================================
            function setupCostEditor() {
                const editor = document.getElementById('cost-editor-container');
                const toggleBtn = document.getElementById('toggle-costs-btn');
                const resetBtn = document.getElementById('reset-costs-btn');
                const tableBody = document.getElementById('cost-table-body');
                const discInput = document.getElementById('cost-discount-rate');

                if (!editor || !toggleBtn || !resetBtn || !tableBody || !discInput) return;

                toggleBtn.addEventListener('click', () => {
                    editor.classList.toggle('hidden');
                    if (!editor.classList.contains('hidden')) {
                        renderCostInputs();
                    }
                });

                resetBtn.addEventListener('click', () => {
                    if (confirm('Reset all cost assumptions to default?')) {
                        COST_DATA = JSON.parse(JSON.stringify(DEFAULT_COST_DATA));
                        renderCostInputs();
                        console.log('Cost assumptions reset to defaults');
                    }
                });

                discInput.addEventListener('change', (e) => {
                    const val = parseFloat(e.target.value);
                    if (!isNaN(val) && val >= 0 && val <= 1) {
                        COST_DATA.discount_rate = val;
                        console.log('Updated discount rate:', val);
                    }
                });

                function renderCostInputs() {
                    tableBody.innerHTML = '';
                    discInput.value = COST_DATA.discount_rate;

                    // Comprehensive list of relevant technologies
                    const techs = [
                        'solar', 'wind', 'offshoreWind',
                        'nuclear', 'geothermal',
                        'biomass', 'rng', 'hydrogen',
                        'battery4hr', 'battery8hr', 'longduration',
                        'dac',
                        'naturalGas', 'coal', 'hydro',
                        'naturalGasCCGT', 'naturalGasCT'
                    ];

                    techs.forEach(tech => {
                        const row = document.createElement('tr');
                        row.className = 'hover:bg-gray-50';

                        // Name cell
                        const nameCell = document.createElement('td');
                        nameCell.className = 'px-3 py-2 font-medium text-gray-900 border-b border-gray-100';
                        nameCell.textContent = formatTechName(tech);
                        row.appendChild(nameCell);

                        // CAPEX
                        row.appendChild(createInputCell(tech, 'capex'));
                        // Fixed O&M
                        row.appendChild(createInputCell(tech, 'fixed_om'));
                        // Variable O&M (special handling for NG objects)
                        row.appendChild(createInputCell(tech, 'variable_om'));
                        // Lifetime
                        row.appendChild(createInputCell(tech, 'lifetime'));

                        tableBody.appendChild(row);
                    });
                }

                function createInputCell(tech, category) {
                    const cell = document.createElement('td');
                    cell.className = 'px-2 py-1 border-b border-gray-100';

                    // Check if value exists
                    let val = COST_DATA[category]?.[tech];

                    if (category === 'variable_om' && (tech === 'naturalGasCCGT' || tech === 'naturalGasCT')) {
                        // Handle object {start, end}
                        if (val && typeof val === 'object') {
                            val = `${val.start}-${val.end}`;
                        }
                    }

                    if (val === undefined) {
                        cell.textContent = '-';
                        cell.className += ' text-gray-400 text-center';
                        return cell;
                    }

                    const input = document.createElement('input');
                    input.type = 'text'; // use text to allow for ranges like "35-80"
                    input.value = val;
                    input.className = 'w-full text-xs border border-gray-300 rounded px-1 py-0.5 focus:ring-1 focus:ring-blue-500';

                    input.addEventListener('change', (e) => {
                        let newVal = e.target.value;

                        if (category === 'variable_om' && (tech === 'naturalGasCCGT' || tech === 'naturalGasCT')) {
                            // Parse range "35-80"
                            if (newVal.includes('-')) {
                                const parts = newVal.split('-').map(s => parseFloat(s.trim()));
                                if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                                    COST_DATA[category][tech] = { start: parts[0], end: parts[1] };
                                    console.log(`Updated ${tech} ${category}:`, COST_DATA[category][tech]);
                                    input.classList.remove('border-red-500');
                                } else {
                                    input.classList.add('border-red-500');
                                }
                            } else {
                                // Single value fallback (start=end)
                                const num = parseFloat(newVal);
                                if (!isNaN(num)) {
                                    COST_DATA[category][tech] = { start: num, end: num };
                                    console.log(`Updated ${tech} ${category}:`, COST_DATA[category][tech]);
                                    input.classList.remove('border-red-500');
                                } else {
                                    input.classList.add('border-red-500');
                                }
                            }
                        } else {
                            // Standard number
                            const num = parseFloat(newVal);
                            if (!isNaN(num)) {
                                COST_DATA[category][tech] = num;
                                console.log(`Updated ${tech} ${category}:`, num);
                                input.classList.remove('border-red-500');
                            } else {
                                input.classList.add('border-red-500');
                            }
                        }
                    });

                    cell.appendChild(input);
                    return cell;
                }

                function formatTechName(tech) {
                    const map = {
                        'solar': 'Solar PV',
                        'wind': 'Onshore Wind',
                        'offshoreWind': 'Offshore Wind',
                        'battery4hr': 'Battery (4hr)',
                        'battery8hr': 'Battery (8hr)',
                        'longduration': 'Long Duration Storage',
                        'naturalGas': 'Natural Gas (Capacity)',
                        'naturalGasCCGT': 'Natural Gas CCGT',
                        'naturalGasCT': 'Natural Gas CT',
                        'coal': 'Coal',
                        'hydro': 'Hydro',
                        'nuclear': 'Nuclear',
                        'geothermal': 'Geothermal',
                        'biomass': 'Biomass',
                        'rng': 'RNG',
                        'hydrogen': 'Hydrogen',
                        'dac': 'Direct Air Capture'
                    };
                    return map[tech] || tech;
                }
            }

            // Initialize editor
            setupCostEditor();

            // --- MAIN INITIALIZATION FUNCTION ---
            async function initialize() {
                // Load California seasonal profiles from JSON
                try {
                    const response = await fetch('../grid-operator/seasonal_profiles.json');
                    const profilesData = await response.json();
                    CALIFORNIA_PROFILES = profilesData.california.profiles;
                    console.log('Loaded California profiles from JSON:', Object.keys(CALIFORNIA_PROFILES));
                } catch (error) {
                    console.error('Error loading California profiles from JSON:', error);
                    console.log('Falling back to scaling method for California');
                }

                try {
                    await signInAnonymously(auth);
                    console.log("Firebase authentication successful.");
                } catch (error) {
                    console.error("Firebase authentication failed:", error);
                    visitorCountEl.textContent = "Auth Failed";
                    return;
                }

                const counterRef = doc(db, `artifacts/${appId}/public/data/counters/visitor_counter`);
                try {
                    const newCount = await runTransaction(db, async (transaction) => {
                        const counterDoc = await transaction.get(counterRef);
                        if (!counterDoc.exists()) {
                            transaction.set(counterRef, { count: 1 });
                            return 1;
                        }
                        const newCount = counterDoc.data().count + 1;
                        transaction.update(counterRef, { count: newCount });
                        return newCount;
                    });
                    visitorCountEl.textContent = newCount.toLocaleString();
                } catch (e) {
                    console.error("Firestore transaction failed: ", e);
                    visitorCountEl.textContent = "DB Error";
                }

                createGridMixSliders();
                createGenerationMixSliders();
                populateCountryDropdown();
                applySeason('spring-typical');
                setupInputSyncing();

                setTimeout(startTutorial, 500);
            }

            await initialize();

            // ============================================
            // OPTIMIZE TAB UI EVENT HANDLERS
            // ============================================

            // Update baseline CO2 display after initialization
            // Use the customBaselineTotalAnnualCO2 which is set during system initialization
            function updateBaselineCO2Display() {
                const baselineCO2Display = document.getElementById('baseline-co2');
                if (baselineCO2Display && customBaselineTotalAnnualCO2 > 0) {
                    baselineCO2Display.textContent = (customBaselineTotalAnnualCO2 / 1e9).toFixed(2);
                    console.log('Baseline CO2 display updated:', (customBaselineTotalAnnualCO2 / 1e9).toFixed(2), 'million MT');
                }
            }

            setTimeout(updateBaselineCO2Display, 2000);  // Increased delay to ensure initialization completes

            // ===== TAB SWITCHING =====
            const tabManual = document.getElementById('tab-manual');
            const tabOptimize = document.getElementById('tab-optimize');
            const manualContent = document.getElementById('manual-mode-content');
            const optimizeContent = document.getElementById('optimize-mode-content');

            tabManual.addEventListener('click', () => {
                tabManual.classList.add('tab-active');
                tabOptimize.classList.remove('tab-active');
                manualContent.classList.remove('hidden');
                optimizeContent.classList.add('hidden');
            });

            tabOptimize.addEventListener('click', () => {
                tabOptimize.classList.add('tab-active');
                tabManual.classList.remove('tab-active');
                optimizeContent.classList.remove('hidden');
                manualContent.classList.add('hidden');
            });

            // ===== RESET SCALING FLAG WHEN TARGET CHANGES =====
            const co2TargetInput = document.getElementById('co2-target-input');
            co2TargetInput.addEventListener('change', function() {
                // Reset scaling flag when user manually changes the target
                // This allows adaptive scaling to work again for the new target
                if (window.lastOptimizationWasScaled !== undefined) {
                    console.log('CO2 target changed - resetting adaptive scaling flag');
                    window.lastOptimizationWasScaled = false;
                }
            });

            // ===== OPTIMIZATION TRIGGER =====
            const runOptimizationBtn = document.getElementById('run-optimization-btn');
            runOptimizationBtn.addEventListener('click', async function () {
                const targetCO2Input = parseFloat(document.getElementById('co2-target-input').value) * 1e9; // Convert million MT to kg (1 million MT = 1e9 kg)
                const allowDAC = document.getElementById('allow-dac').checked;
                const respectCurtailment = document.getElementById('respect-curtailment').checked;

                console.log('=== OPTIMIZATION BUTTON CLICKED ===');
                console.log('Target CO2 from input field:', (targetCO2Input / 1e9).toFixed(2), 'million MT');
                console.log('Options: allowDAC =', allowDAC, ', respectCurtailment =', respectCurtailment);

                // Validate input
                if (isNaN(targetCO2Input) || targetCO2Input <= 0) {
                    alert('Please enter a valid CO2 target');
                    return;
                }

                // Disable button during optimization
                this.disabled = true;
                this.textContent = 'Optimizing...';
                this.classList.add('opacity-50', 'cursor-not-allowed');

                // Show progress section
                document.getElementById('optimization-progress').classList.remove('hidden');
                document.getElementById('optimization-results-container').innerHTML = '';

                // Reset progress
                document.getElementById('progress-bar').style.width = '0%';
                document.getElementById('iter-count').textContent = '0';
                document.getElementById('best-cost').textContent = '--';
                document.getElementById('current-co2').textContent = '--';

                // Build optimization context with all necessary data
                const currentValues = {};
                for (const key in sliders) {
                    currentValues[key] = parseFloat(sliders[key].value);
                }

                // Reconstruct CF profiles for optimization
                const selectedCountry = countrySelect.value;
                const baseProfiles = {
                    solar: countryProfiles[selectedCountry]?.solar || countryProfiles['default'].solar,
                    wind: countryProfiles[selectedCountry]?.wind || countryProfiles['default'].wind,
                    offshoreWind: countryProfiles[selectedCountry]?.offshoreWind || countryProfiles['default'].offshoreWind
                };

                const profilesForOptimization = {
                    solar: [],
                    wind: [],
                    offshoreWind: []
                };

                // CRITICAL FIX: Check if user has edited CF profiles (same logic as manual mode)
                if (currentCFProfileName === "User Defined" &&
                    currentSolarCFProfile.length === 288 &&
                    currentWindCFProfile.length === 288 &&
                    currentOffshoreWindCFProfile.length === 288) {
                    // Use the saved user-defined profiles directly
                    profilesForOptimization.solar = [...currentSolarCFProfile];
                    profilesForOptimization.wind = [...currentWindCFProfile];
                    profilesForOptimization.offshoreWind = [...currentOffshoreWindCFProfile];
                    console.log('Using USER-DEFINED capacity factor profiles for optimization');
                } else {
                    // Build profiles from base with seasonal multipliers
                    const userSeasonMap = [
                        'winter', 'winter',
                        'spring', 'spring', 'spring',
                        'summer', 'summer', 'summer', 'summer',
                        'fall', 'fall',
                        'winter'
                    ];

                    for (let m = 0; m < 12; m++) {
                        const season = userSeasonMap[m];
                        const seasonalMultipliers = SEASONAL_MULTIPLIERS[season] || { solar: 1.0, wind: 1.0, offshoreWind: 1.0 };

                        const sSolar = baseProfiles.solar.map(cf => Math.min(1, cf * seasonalMultipliers.solar));
                        const sWind = baseProfiles.wind.map(cf => Math.min(1, cf * seasonalMultipliers.wind));
                        const sOffshoreWind = baseProfiles.offshoreWind.map(cf => Math.min(1, cf * seasonalMultipliers.offshoreWind));

                        profilesForOptimization.solar.push(...sSolar);
                        profilesForOptimization.wind.push(...sWind);
                        profilesForOptimization.offshoreWind.push(...sOffshoreWind);
                    }
                    console.log('Using BASE country profiles with seasonal multipliers for optimization');
                }

                // Get baseline storage
                const baselineStorageForOpt = {
                    battery4hr: currentBaselineStorage.battery4hr || 0,
                    battery8hr: currentBaselineStorage.battery8hr || 0,
                    longduration: currentBaselineStorage.longduration || 0
                };

                // Build potential generation object for 12 months
                // BASELINE_POTENTIAL_GENERATION contains simple 24-hour profiles, not seasonal structure
                const potentialGenForOpt = {};
                if (typeof BASELINE_POTENTIAL_GENERATION !== 'undefined') {
                    for (const tech in BASELINE_POTENTIAL_GENERATION) {
                        potentialGenForOpt[tech] = [];
                        // Duplicate the 24-hour baseline profile for all 12 months
                        for (let m = 0; m < 12; m++) {
                            potentialGenForOpt[tech].push(...(BASELINE_POTENTIAL_GENERATION[tech] || Array(24).fill(0)));
                        }
                    }
                }

                // Set global optimization context for use by optimization functions
                // Use currentCountryInstalledCapacity for baseline (has actual installed capacity data)
                console.log('=== BUILDING OPTIMIZATION CONTEXT ===');
                console.log('Current slider values (should be ignored for baseline):');
                for (const tech of OPTIMIZATION_CONFIG.TECHNOLOGIES) {
                    if (currentValues[tech] && currentValues[tech] > 0.01) {
                        console.warn(`  ${tech}: ${currentValues[tech].toFixed(2)} GW (slider has non-zero value!)`);
                    }
                }
                console.log('Using currentCountryInstalledCapacity for baseline:', currentCountryInstalledCapacity);
                console.log('BASELINE_POTENTIAL_GENERATION.solar sample:', BASELINE_POTENTIAL_GENERATION.solar?.slice(0, 5));
                console.log('BASELINE_POTENTIAL_GENERATION.hydro sample:', BASELINE_POTENTIAL_GENERATION.hydro?.slice(0, 5));

                optimizationContext = {
                    baselineCapacity: currentCountryInstalledCapacity || {},
                    baselineStorage: baselineStorageForOpt,
                    demand: [...currentDemand],
                    solarProfile: profilesForOptimization.solar,
                    windProfile: profilesForOptimization.wind,
                    offshoreWindProfile: profilesForOptimization.offshoreWind,
                    potentialGen: potentialGenForOpt,
                    hydroCF: currentHydroCF || 0.45,
                    countryName: selectedCountry,
                    incentives: {
                        solar: currentValues.solarIncentive || 0,
                        wind: currentValues.windIncentive || 0,
                        offshoreWind: currentValues.offshoreWindIncentive || 0,
                        geothermal: currentValues.geothermalIncentive || 0,
                        nuclear: currentValues.nuclearIncentive || 0,
                        biomass: currentValues.biomassIncentive || 0,
                        rng: currentValues.rngIncentive || 0,
                        hydrogen: currentValues.hydrogenIncentive || 0,
                        storage: currentValues.storageIncentive || 0,
                        dac: currentValues.dacIncentive || 0,
                        carbonTax: currentValues.carbonTax || 0,
                        exportPrice: currentValues.exportPrice || -20
                    }
                };

                // Validate optimization context
                console.log('Optimization Context Validation:');
                console.log('- Demand length:', optimizationContext.demand.length);
                console.log('- Solar profile length:', optimizationContext.solarProfile.length);
                console.log('- Wind profile length:', optimizationContext.windProfile.length);
                console.log('- Baseline capacity:', JSON.stringify(optimizationContext.baselineCapacity));
                console.log('- Baseline hydro:', optimizationContext.baselineCapacity.hydro);
                console.log('- Baseline natural gas:', optimizationContext.baselineCapacity.naturalGas);
                console.log('- Baseline coal:', optimizationContext.baselineCapacity.coal);

                if (optimizationContext.demand.length !== 288) {
                    alert('Error: Invalid demand profile length. Expected 288 hours, got ' + optimizationContext.demand.length);
                    this.disabled = false;
                    this.textContent = 'Find Optimal Solution';
                    this.classList.remove('opacity-50', 'cursor-not-allowed');
                    return;
                }

                if (optimizationContext.solarProfile.length !== 288) {
                    alert('Error: Invalid solar profile length. Expected 288 hours, got ' + optimizationContext.solarProfile.length);
                    this.disabled = false;
                    this.textContent = 'Find Optimal Solution';
                    this.classList.remove('opacity-50', 'cursor-not-allowed');
                    return;
                }

                try {
                    const result = await optimizeCapacityExpansion(targetCO2Input, {
                        allowDAC,
                        respectCurtailment,
                        progressCallback: updateProgressUI,
                        context: optimizationContext
                    });

                    if (result.success) {
                        displayOptimizationResults(result);
                    } else {
                        alert(result.message);
                        document.getElementById('optimization-progress').classList.add('hidden');
                    }
                } catch (error) {
                    console.error('Optimization error:', error);
                    alert('Optimization failed: ' + error.message);
                    document.getElementById('optimization-progress').classList.add('hidden');
                } finally {
                    // Re-enable button
                    this.disabled = false;
                    this.textContent = 'Find Optimal Solution';
                    this.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            });

            // ===== PROGRESS UI UPDATE =====
            // ===== PROGRESS UI UPDATE =====
            function updateProgressUI(iteration, bestCost, currentCO2) {
                if (iteration !== 'DONE') {
                    document.getElementById('iter-count').textContent = iteration;
                } else {
                    // if DONE, leave the last iteration number or indicate finished
                    // document.getElementById('iter-count').textContent = 'Final';
                }
                document.getElementById('best-cost').textContent = (bestCost / 1e9).toFixed(2);

                // Show CO2 in Millions (if > 1M) or Thousands (if < 1M)
                // Note: currentCO2 is in kg/year.
                // 1 MMT = 1e9 kg
                if (currentCO2) {
                    if (currentCO2 > 1e9) {
                        // > 1 Million MT
                        document.getElementById('current-co2').textContent = (currentCO2 / 1e9).toFixed(2) + ' M';
                    } else if (currentCO2 > 1e6) {
                        // > 1000 MT
                        document.getElementById('current-co2').textContent = (currentCO2 / 1e6).toFixed(2) + ' k';
                    } else {
                        // < 1000 MT
                        document.getElementById('current-co2').textContent = (currentCO2 / 1e3).toFixed(2) + ' T';
                    }
                } else {
                    document.getElementById('current-co2').textContent = '--';
                }

                // If iteration is a special flag or we just want to force 100%
                if (iteration === 'DONE') {
                    document.getElementById('progress-bar').style.width = '100%';
                } else {
                    const progress = Math.min(100, (iteration / OPTIMIZATION_CONFIG.MAX_ITERATIONS) * 100);
                    document.getElementById('progress-bar').style.width = `${progress}%`;
                }

                // Update max iteration display
                if (document.getElementById('max-iter')) {
                    document.getElementById('max-iter').textContent = OPTIMIZATION_CONFIG.MAX_ITERATIONS;
                }
            }

            // ===== CALCULATE INCREMENTAL COSTS =====
            function calculateIncrementalCosts(solution) {
                let incrementalCAPEX = 0;
                let incrementalFixedOM = 0;
                const d = COST_DATA.discount_rate;

                for (const tech of OPTIMIZATION_CONFIG.TECHNOLOGIES) {
                    const newCapacityGW = solution[tech] || 0;
                    if (newCapacityGW <= 0) continue;

                    const newCapacityKW = newCapacityGW * 1000000;
                    const lifetime = COST_DATA.lifetime[tech] || 30;
                    const crf = (d * Math.pow(1 + d, lifetime)) / (Math.pow(1 + d, lifetime) - 1);

                    if (tech.includes('battery') || tech === 'longduration') {
                        // Storage: cost is per kWh of energy
                        const duration = tech === 'longduration' ? 24 : parseInt(tech.match(/\d+/)[0]);
                        const energyKWh = newCapacityGW * 1000000 * duration;
                        incrementalCAPEX += COST_DATA.capex[tech] * energyKWh * crf;
                        incrementalFixedOM += COST_DATA.fixed_om[tech] * newCapacityKW;
                    } else {
                        // Generation: cost is per kW of capacity
                        incrementalCAPEX += COST_DATA.capex[tech] * newCapacityKW * crf;
                        incrementalFixedOM += COST_DATA.fixed_om[tech] * newCapacityKW;
                    }
                }

                return {
                    capex: incrementalCAPEX,
                    fixedOM: incrementalFixedOM,
                    total: incrementalCAPEX + incrementalFixedOM
                };
            }

            // ===== CALCULATE BASELINE COST AND CO2 =====
            function getBaselineMetrics() {
                if (!optimizationContext) return null;

                // Evaluate baseline (zero new capacity)
                const zeroSolution = {};
                for (const tech of OPTIMIZATION_CONFIG.TECHNOLOGIES) {
                    zeroSolution[tech] = 0;
                }

                try {
                    const baselineEval = evaluateSolutionFull(zeroSolution, 999e9); // High CO2 target to be feasible
                    return {
                        cost: baselineEval.systemCost,
                        co2: baselineEval.annualCO2
                    };
                } catch (error) {
                    console.warn('Could not calculate baseline metrics:', error);
                    return null;
                }
            }

            // ===== RESULTS DISPLAY =====
            function displayOptimizationResults(result) {
                // Ensure progress bar shows 100%
                updateProgressUI('DONE', result.cost, result.co2);

                // --- CALCULATE MAX HOURLY SUPPLY FOR FOSSIL FUELS ---
                let maxOptimizedGas = 0;
                let maxOptimizedCoal = 0;
                let maxBaselineGas = 0;
                let maxBaselineCoal = 0;

                if (optimizationContext) {
                    try {
                        // 1. Optimized Result Simulation
                        const optimizedCapacityInputs = {
                            capacity: result.solution,
                            incentives: optimizationContext.incentives
                        };

                        const optimizedSim = getSimulationResult(
                            optimizedCapacityInputs,
                            optimizationContext.solarProfile,
                            optimizationContext.windProfile,
                            optimizationContext.offshoreWindProfile,
                            optimizationContext.potentialGen,
                            optimizationContext.baselineStorage,
                            optimizationContext.hydroCF,
                            optimizationContext.countryName
                        );

                        maxOptimizedGas = Math.max(
                            ...(optimizedSim.generation?.naturalGas || [0]).map((v, i) => v + (optimizedSim.generation?.naturalGasCCGT?.[i] || 0) + (optimizedSim.generation?.naturalGasCT?.[i] || 0))
                        );
                        maxOptimizedCoal = Math.max(...(optimizedSim.generation?.coal || [0]));

                        // 2. Baseline Simulation
                        const zeroSolution = {};
                        for (const tech of OPTIMIZATION_CONFIG.TECHNOLOGIES) zeroSolution[tech] = 0;

                        const baselineCapacityInputs = {
                            capacity: zeroSolution,
                            incentives: optimizationContext.incentives
                        };

                        const baselineSim = getSimulationResult(
                            baselineCapacityInputs,
                            optimizationContext.solarProfile,
                            optimizationContext.windProfile,
                            optimizationContext.offshoreWindProfile,
                            optimizationContext.potentialGen,
                            optimizationContext.baselineStorage,
                            optimizationContext.hydroCF,
                            optimizationContext.countryName
                        );

                        maxBaselineGas = Math.max(
                            ...(baselineSim.generation?.naturalGas || [0]).map((v, i) => v + (baselineSim.generation?.naturalGasCCGT?.[i] || 0) + (baselineSim.generation?.naturalGasCT?.[i] || 0))
                        );
                        maxBaselineCoal = Math.max(...(baselineSim.generation?.coal || [0]));

                    } catch (e) {
                        console.warn('Could not calc max supply profiles', e);
                    }
                }

                // console.clear(); // Commented out to preserve optimization logs
                console.log('\n========== OPTIMIZATION RESULTS ==========');
                console.log(`Target CO2: ${(result.targetCO2 / 1e9).toFixed(2)} million MT`);
                console.log(`Achieved CO2: ${(result.co2 / 1e9).toFixed(2)} million MT`);
                console.log(`System Cost: $${(result.cost / 1e9).toFixed(2)}B/year`);
                console.log('------------------------------------------');
                console.log('MAXIMUM HOURLY SUPPLY (GW):');
                console.log(`Natural Gas: ${maxBaselineGas.toFixed(2)} GW (Baseline) -> ${maxOptimizedGas.toFixed(2)} GW (Optimized)`);
                console.log(`Coal       : ${maxBaselineCoal.toFixed(2)} GW (Baseline) -> ${maxOptimizedCoal.toFixed(2)} GW (Optimized)`);
                console.log('------------------------------------------');


                // --- DETECT STRANDED ASSETS & OFFER RE-OPTIMIZATION ---
                const installedGas = (optimizationContext.baselineCapacity.naturalGas || 0) + (optimizationContext.baselineCapacity.naturalGasCCGT || 0) + (optimizationContext.baselineCapacity.naturalGasCT || 0);
                const installedCoal = optimizationContext.baselineCapacity.coal || 0;

                // Threshold: If we are using less than 80% of installed capacity at PEAK, suggest retirement
                const canRetireGas = maxOptimizedGas < installedGas * 0.8;
                const canRetireCoal = maxOptimizedCoal < installedCoal * 0.8;

                let retirementHTML = '';
                if (canRetireGas || canRetireCoal) {
                    retirementHTML = `
                     <div class="mb-6 p-4 bg-orange-50 rounded border border-orange-200">
                        <h4 class="font-semibold text-md mb-2 text-orange-900">ðŸ“‰ Opportunity to Retire Fossil Capacity</h4>
                        <p class="text-sm text-gray-700 mb-3">
                            The optimization found that we need significantly less fossil fuel capacity than currently installed. 
                            Retiring these plants will reduce Fixed O&M costs but might require more flexible renewable capacity to meet reliability constraints.
                        </p>
                        <div class="grid grid-cols-2 gap-4 text-sm mb-3">
                            ${canRetireGas ? `
                                <div>
                                    <p class="font-medium">Natural Gas Capacity:</p>
                                    <p class="text-gray-500">Installed: <b>${installedGas.toFixed(2)} GW</b></p>
                                    <p class="text-gray-500">Peak Usage: <b>${maxOptimizedGas.toFixed(2)} GW</b></p>
                                    <div class="mt-1 flex items-center">
                                         <label class="mr-2 text-xs">New Capacity (GW):</label>
                                         <input type="number" id="rerun-gas-cap" value="${(Math.ceil(maxOptimizedGas * 1.1)).toFixed(1)}" class="w-20 px-1 py-0.5 text-sm border rounded">
                                    </div>
                                </div>
                            ` : ''}
                            ${canRetireCoal ? `
                                <div>
                                    <p class="font-medium">Coal Capacity:</p>
                                    <p class="text-gray-500">Installed: <b>${installedCoal.toFixed(2)} GW</b></p>
                                    <p class="text-gray-500">Peak Usage: <b>${maxOptimizedCoal.toFixed(2)} GW</b></p>
                                    <div class="mt-1 flex items-center">
                                         <label class="mr-2 text-xs">New Capacity (GW):</label>
                                         <input type="number" id="rerun-coal-cap" value="${(Math.ceil(maxOptimizedCoal * 1.1)).toFixed(1)}" class="w-20 px-1 py-0.5 text-sm border rounded">
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                        <button id="reduce-fossil-btn" class="w-full py-2 bg-orange-600 hover:bg-orange-700 text-white font-medium rounded text-sm transition-colors shadow-sm">
                            Simulate with Reduced Fossil & Re-Optimize
                        </button>
                     </div>
                     `;
                }


                const curtailmentRate = result.metrics.curtailmentRate * 100;
                const reserveMargin = result.metrics.reserveMargin * 100;

                // Calculate incremental costs
                const incrementalCosts = calculateIncrementalCosts(result.solution);

                // Calculate baseline metrics for comparison
                const baseline = getBaselineMetrics();
                const costIncrease = baseline ? result.cost - baseline.cost : null;
                const co2Reduction = baseline ? baseline.co2 - result.co2 : null;
                const carbonTaxSavings = co2Reduction ? (co2Reduction / 1000) * (optimizationContext?.incentives?.carbonTax || 0) : null; // carbonTax is $/ton, co2Reduction is kg

                // Clean console output as requested
                // (Note: The maxHourly logging is already done above)
                console.log('Baseline cost:', baseline?.cost, '$/year');
                console.log('Result cost:', result.cost, '$/year');

                if (co2Reduction > 0 && costIncrease > 0) {
                    const co2ReductionMT = co2Reduction / 1e3;
                    const abatementCost = costIncrease / co2ReductionMT;
                    console.log(`Abatement Cost: $${abatementCost.toFixed(2)}/MT CO2`);
                }

                // Calculate Flexible Capacity Stats for Display
                const peakDemand = Math.max(...optimizationContext.demand);
                // Fix: Use result.metrics.reserveMargin (raw fraction, e.g. 0.2) instead of reserveMargin (percentage, e.g. 20)
                const flexibleCapacityGW = (result.metrics.reserveMargin + 1.0) * peakDemand;
                const flexShare = (flexibleCapacityGW / peakDemand) * 100;

                const resultHTML = `
                    <div class="optimization-results p-6 bg-green-50 rounded-lg border-2 border-green-200">
                        <h3 class="font-bold text-2xl mb-4 text-green-800">âœ“ Optimization Complete</h3>

                        ${retirementHTML}

                        <div class="grid grid-cols-2 gap-4 mb-6">
                            <div class="metric-card">
                                <p class="text-sm font-medium text-gray-600">Total System Cost</p>
                                <p class="text-3xl font-bold text-blue-600">
                                    $${(result.cost / 1e9).toFixed(2)}B/year
                                </p>
                            </div>

                            <div class="metric-card">
                                <p class="text-sm font-medium text-gray-600">Annual CO2 Emissions</p>
                                <p class="text-3xl font-bold text-green-600">
                                    ${(result.co2 / 1e9).toFixed(2)} million MT
                                </p>
                            </div>

                            <div class="metric-card">
                                <p class="text-sm font-medium text-gray-600" title="Flexible Capacity relative to Peak Demand">Reserve Margin (Flexible)</p>
                                <p class="text-2xl font-bold ${reserveMargin >= 0.15 ? 'text-green-600' : 'text-yellow-600'}">
                                    ${reserveMargin.toFixed(1)}%
                                </p>
                            </div>

                            <div class="metric-card">
                                <p class="text-sm font-medium text-gray-600">Flexible Capacity</p>
                                <p class="text-2xl font-bold text-blue-800">
                                    ${flexibleCapacityGW.toFixed(1)} GW
                                    <span class="text-sm font-normal text-gray-500 block">(${flexShare.toFixed(0)}% of Peak)</span>
                                </p>
                            </div>
                        </div>

                        <div class="mb-6">
                            <h4 class="font-semibold text-lg mb-3 text-gray-800">Recommended Capacity Additions:</h4>
                            <div class="grid grid-cols-2 gap-2">
                                ${formatCapacityAdditions(result.solution)}
                            </div>
                        </div>

                        <div class="mb-6 p-4 bg-blue-50 rounded border border-blue-200">
                            <h4 class="font-semibold text-md mb-2 text-blue-900">ðŸ’° Cost Breakdown</h4>
                            <div class="text-sm text-gray-700 space-y-2">
                                <div class="grid grid-cols-2 gap-4 mb-2">
                                    <div>
                                        <p class="font-semibold">Total System Cost:</p>
                                        <p class="text-2xl font-bold text-blue-600">$${(result.cost / 1e9).toFixed(2)}B/year</p>
                                    </div>
                                    ${baseline ? `
                                    <div>
                                        <p class="font-semibold">Baseline System Cost:</p>
                                        <p class="text-2xl font-bold text-gray-600">$${(baseline.cost / 1e9).toFixed(2)}B/year</p>
                                    </div>
                                    ` : ''}
                                </div>
                                ${costIncrease !== null ? `
                                <div class="p-3 bg-white rounded border border-blue-300">
                                    <p class="font-semibold text-blue-900">ðŸ’¡ Cost Impact:</p>
                                    <p class="text-lg">${costIncrease >= 0 ? '+' : ''}$${(costIncrease / 1e9).toFixed(2)}B/year (${((costIncrease / baseline.cost) * 100).toFixed(1)}% ${costIncrease >= 0 ? 'increase' : 'decrease'})</p>
                                </div>
                                ` : ''}
                                <div class="p-3 bg-white rounded border border-green-300">
                                    <p class="font-semibold text-green-900">ðŸ“Š Incremental NEW Capacity Costs:</p>
                                    <ul class="list-disc ml-5 space-y-1 mt-1">
                                        <li>Annualized CAPEX (7% discount): $${(incrementalCosts.capex / 1e9).toFixed(2)}B/year</li>
                                        <li>Fixed O&M: $${(incrementalCosts.fixedOM / 1e9).toFixed(2)}B/year</li>
                                        <li><strong>Total Incremental Cost: $${(incrementalCosts.total / 1e9).toFixed(2)}B/year</strong></li>
                                    </ul>
                                </div>
                                ${co2Reduction !== null && co2Reduction > 0 ? `
                                <div class="p-3 bg-green-100 rounded border border-green-400">
                                    <p class="font-semibold text-green-900">ðŸŒ± CO2 Reduction Benefits:</p>
                                    <ul class="list-disc ml-5 space-y-1 mt-1">
                                        <li>CO2 Reduction: ${(co2Reduction / 1e9).toFixed(2)} million MT/year</li>
                                        <li>Baseline: ${(baseline.co2 / 1e9).toFixed(2)} million MT â†’ Result: ${(result.co2 / 1e9).toFixed(2)} million MT</li>
                                        ${carbonTaxSavings && carbonTaxSavings > 0 ? `<li><strong>Carbon Tax Savings: $${(carbonTaxSavings / 1e9).toFixed(2)}B/year</strong> (at $${optimizationContext.incentives.carbonTax}/ton)</li>` : ''}
                                        ${costIncrease !== null && carbonTaxSavings ? `<li><strong>Net Cost After Carbon Savings: $${((costIncrease - carbonTaxSavings) / 1e9).toFixed(2)}B/year</strong></li>` : ''}
                                        ${co2Reduction > 0 && costIncrease > 0 ? `<li><strong>Abatement Cost: $${(costIncrease / (co2Reduction / 1e3)).toFixed(0)}/MT CO2</strong></li>` : ''}
                                    </ul>
                                </div>
                                ` : ''}
                            </div>
                        </div>

                        <div class="flex gap-3">
                            <button id="apply-solution-btn"
                                    class="btn btn-success flex-1">
                                Apply This Solution to Sliders
                            </button>
                            <button id="export-solution-btn"
                                    class="btn btn-secondary">
                                Export to CSV
                            </button>
                        </div>
                    </div>
                `;

                document.getElementById('optimization-results-container').innerHTML = resultHTML;

                // Wire up action buttons
                if (document.getElementById('reduce-fossil-btn')) {
                    document.getElementById('reduce-fossil-btn').addEventListener('click', () => {
                        const newGas = document.getElementById('rerun-gas-cap') ? parseFloat(document.getElementById('rerun-gas-cap').value) : null;
                        const newCoal = document.getElementById('rerun-coal-cap') ? parseFloat(document.getElementById('rerun-coal-cap').value) : null;

                        // Show custom modal instead of browser confirm
                        showConfirmationModal(() => {
                            console.log('=== STARTING RE-OPTIMIZATION WITH REDUCED FOSSIL CAPACITY ===');

                            // Store original values for logging
                            const oldGas = (optimizationContext.baselineCapacity.naturalGas || 0) +
                                         (optimizationContext.baselineCapacity.naturalGasCCGT || 0) +
                                         (optimizationContext.baselineCapacity.naturalGasCT || 0);
                            const oldCoal = optimizationContext.baselineCapacity.coal || 0;

                            // Update context
                            if (newGas !== null) {
                                // Simple heuristic: reduce all gas types proportionally or just set one type
                                // Let's set generic 'naturalGas' capacity to this value and zero out others to simplify
                                optimizationContext.baselineCapacity.naturalGas = newGas;
                                optimizationContext.baselineCapacity.naturalGasCCGT = 0;
                                optimizationContext.baselineCapacity.naturalGasCT = 0;
                                console.log('Updated Baseline Gas Capacity:', oldGas.toFixed(2), 'GW â†’', newGas, 'GW (Î”', (newGas - oldGas).toFixed(2), 'GW)');
                            }
                            if (newCoal !== null) {
                                optimizationContext.baselineCapacity.coal = newCoal;
                                console.log('Updated Baseline Coal Capacity:', oldCoal.toFixed(2), 'GW â†’', newCoal, 'GW (Î”', (newCoal - oldCoal).toFixed(2), 'GW)');
                            }

                            console.log('Note: Reducing flexible capacity will require additional battery storage, biomass, or other flexible resources to maintain reserve margin.');
                            console.log('===================================================');

                            // Re-run
                            document.getElementById('run-optimization-btn').click();
                        });
                    });
                }

                document.getElementById('apply-solution-btn').addEventListener('click', () => {
                    applyOptimalSolution(result.solution);
                });

                document.getElementById('export-solution-btn').addEventListener('click', () => {
                    exportSolutionToCSV(result);
                });
            }

            // ===== FORMAT CAPACITY ADDITIONS =====
            function formatCapacityAdditions(solution) {
                const items = [];

                const labels = {
                    solar: 'Solar',
                    wind: 'Onshore Wind',
                    offshoreWind: 'Offshore Wind',
                    nuclear: 'Nuclear',
                    geothermal: 'Geothermal',
                    biomass: 'Biomass',
                    rng: 'RNG (Biogas)',
                    hydrogen: 'Hydrogen',
                    battery4hr: '4-hr Battery',
                    battery8hr: '8-hr Battery',
                    longduration: 'Long-Duration Storage',
                    dac: 'Direct Air Capture'
                };

                for (const [tech, capacity] of Object.entries(solution)) {
                    if (capacity > 0.1) {  // Only show meaningful additions
                        const unit = tech === 'dac' ? 't/hr' :
                            (tech.includes('battery') || tech === 'longduration') ? 'GWh' : 'GW';
                        items.push(`
                            <div class="capacity-item">
                                <span class="font-medium text-gray-700">${labels[tech] || tech}:</span>
                                <span class="font-bold text-blue-700">+${capacity.toFixed(1)} ${unit}</span>
                            </div>
                        `);
                    }
                }

                return items.length > 0 ? items.join('') : '<p class="text-gray-500 italic">No capacity additions recommended</p>';
            }

            // ===== APPLY SOLUTION TO SLIDERS =====
            function applyOptimalSolution(solution) {
                // Switch to manual tab
                tabManual.click();

                // IMPORTANT: Sliders expect NEW capacity additions only (not total)
                // Manual mode adds baseline automatically through potentialGen
                // solution contains NEW capacity additions from optimization (which is what we want!)

                console.log('=== APPLYING OPTIMAL SOLUTION TO SLIDERS ===');
                console.log('Solution (NEW capacity additions):', JSON.stringify(solution, null, 2));

                // Store the expected results for comparison
                window.expectedOptimizationResults = {
                    solution: { ...solution },
                    timestamp: Date.now()
                };

                if (optimizationContext) {
                    console.log('Optimization context is available');
                    console.log('Expected baseline capacity:', optimizationContext.baselineCapacity);
                } else {
                    console.log('WARNING: Optimization context is NOT AVAILABLE');
                }

                // NOTE: High-precision mode disabled - user confirmed it's not the issue
                // The simulation differences are caused by something else, not slider rounding

                // First, reset ALL sliders to 0 (to clear any previous values)
                for (const key in sliders) {
                    // Only reset capacity sliders, not incentive sliders
                    if (!key.includes('Incentive') && key !== 'carbonTax' && key !== 'exportPrice') {
                        const slider = sliders[key];
                        if (slider && OPTIMIZATION_CONFIG.TECHNOLOGIES.includes(key)) {
                            slider.value = 0;
                        }
                    }
                }

                // Store optimization result for comparison
                window.lastOptimizationResult = {
                    solution: { ...solution },
                    co2: window.lastOptimizationCO2,
                    curtailment: window.lastOptimizationCurtailment,
                    cost: window.lastOptimizationCost
                };

                // Update sliders with NEW capacity only (rounded to 2 decimal places for usability)
                for (const [tech, newCapacity] of Object.entries(solution)) {
                    const slider = sliders[tech];
                    if (slider) {
                        const roundedValue = Math.round((newCapacity || 0) * 100) / 100;  // Round to 2 decimal places
                        console.log(`Setting ${tech} slider to ${roundedValue.toFixed(2)} GW (NEW capacity, rounded from ${newCapacity.toFixed(4)})`);
                        slider.value = roundedValue;
                        slider.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                }

                // Trigger simulation update directly (debouncedRunSimulation is scoped inside setupInputSyncing)
                console.log('Triggering manual mode simulation...');
                runSimulation();

                // Scroll to top
                window.scrollTo({ top: 0, behavior: 'smooth' });

                // Show notification
                showNotification('âœ“ Optimal solution applied to sliders');
            }

            // ===== EXPORT TO CSV =====
            function exportSolutionToCSV(result) {
                const rows = [
                    ['Technology', 'Capacity Addition', 'Unit'],
                    ['Solar', result.solution.solar || 0, 'GW'],
                    ['Onshore Wind', result.solution.wind || 0, 'GW'],
                    ['Offshore Wind', result.solution.offshoreWind || 0, 'GW'],
                    ['Nuclear', result.solution.nuclear || 0, 'GW'],
                    ['Geothermal', result.solution.geothermal || 0, 'GW'],
                    ['4-hr Battery', result.solution.battery4hr || 0, 'GWh'],
                    ['8-hr Battery', result.solution.battery8hr || 0, 'GWh'],
                    ['Long-Duration', result.solution.longduration || 0, 'GWh'],
                    ['DAC', result.solution.dac || 0, 'tons/hr'],
                    [],
                    ['Metric', 'Value', 'Unit'],
                    ['Total System Cost', (result.cost / 1e9).toFixed(2), 'Billion $/year'],
                    ['Annual CO2 Emissions', (result.co2 / 1e9).toFixed(2), 'Million MT'],
                    ['Reserve Margin', (result.metrics.reserveMargin * 100).toFixed(1), '%'],
                    ['Curtailment Rate', (result.metrics.curtailmentRate * 100).toFixed(1), '%']
                ];

                const csvContent = rows.map(row => row.join(',')).join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `optimization_results_${Date.now()}.csv`;
                a.click();

                URL.revokeObjectURL(url);

                showNotification('Results exported to CSV!');
            }

            // ===== SHOW CONFIRMATION MODAL =====
            function showConfirmationModal(onConfirm, message = 'This will modify the baseline capacity assumptions and re-run the optimization. Proceed?') {
                const modal = document.getElementById('confirmation-modal');
                const messageElement = document.getElementById('confirmation-modal-message');
                const okButton = document.getElementById('confirmation-modal-ok');
                const cancelButton = document.getElementById('confirmation-modal-cancel');

                // Set message
                messageElement.textContent = message;

                // Show modal
                modal.classList.remove('hidden');

                // Handle OK button
                const handleOk = () => {
                    modal.classList.add('hidden');
                    okButton.removeEventListener('click', handleOk);
                    cancelButton.removeEventListener('click', handleCancel);
                    if (onConfirm) onConfirm();
                };

                // Handle Cancel button
                const handleCancel = () => {
                    modal.classList.add('hidden');
                    okButton.removeEventListener('click', handleOk);
                    cancelButton.removeEventListener('click', handleCancel);
                };

                // Add event listeners
                okButton.addEventListener('click', handleOk);
                cancelButton.addEventListener('click', handleCancel);

                // Close on backdrop click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        handleCancel();
                    }
                });

                // Close on Escape key
                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        handleCancel();
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                document.addEventListener('keydown', handleEscape);
            }

            // ===== SHOW NOTIFICATION =====
            function showNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            }

            // ===== EXPOSE TEST FUNCTION TO WINDOW (for console debugging) =====
            window.testOptimization = async function (targetCO2MT = 30) {
                console.log('\n========== TESTING OPTIMIZATION ==========');
                console.log(`Target CO2: ${targetCO2MT} million MT`);

                if (!optimizationContext) {
                    console.error('ERROR: Optimization context not initialized. Please switch to Optimize tab first to initialize context.');
                    return;
                }

                const targetCO2 = targetCO2MT * 1e6; // Convert to kg

                try {
                    console.log('Starting optimization...');
                    const result = await optimizeCapacityExpansion(targetCO2, {
                        allowDAC: true,
                        respectCurtailment: true,
                        progressCallback: (iter, cost, co2) => {
                            if (iter % 50 === 0) {
                                console.log(`Iteration ${iter}: Cost = $${(cost / 1e9).toFixed(2)}B, CO2 = ${(co2 / 1e9).toFixed(2)} million MT`);
                            }
                        }
                    });

                    console.log('\n========== OPTIMIZATION RESULTS ==========');
                    if (result.success) {
                        console.log('âœ“ SUCCESS');
                        console.log('Total System Cost:', `$${(result.cost / 1e9).toFixed(2)}B/year`);
                        console.log('Annual CO2:', `${(result.co2 / 1e9).toFixed(2)} million MT`);
                        console.log('Reserve Margin:', `${(result.metrics.reserveMargin * 100).toFixed(1)}%`);
                        console.log('Curtailment Rate:', `${(result.metrics.curtailmentRate * 100).toFixed(1)}%`);
                        console.log('\nCapacity Additions:');
                        for (const [tech, capacity] of Object.entries(result.solution)) {
                            if (capacity > 0.1) {
                                const unit = tech.includes('battery') || tech === 'longduration' ? 'GWh' :
                                    tech === 'dac' ? 'tons/hr' : 'GW';
                                console.log(`  ${tech}: +${capacity.toFixed(2)} ${unit}`);
                            }
                        }
                    } else {
                        console.log('âœ— FAILED');
                        console.log('Message:', result.message);
                    }

                    return result;
                } catch (error) {
                    console.error('ERROR:', error);
                    console.error('Stack:', error.stack);
                    throw error;
                }
            };

            console.log('âœ“ Test function loaded. Run testOptimization(30) in console to test with 30 MT CO2 target.');

        });
    </script>

    <!-- Magnifying glass for capacity factor editing (positioned at body level for correct fixed positioning) -->
    <div id="cf-magnifier" class="hidden"
        style="position: fixed; pointer-events: none; z-index: 9999; width: 200px; height: 200px; border: 3px solid #4B5563; border-radius: 50%; overflow: hidden; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); background: white;">
        <canvas id="cf-magnifier-canvas" width="200" height="200"></canvas>
    </div>
</body>

</html>
