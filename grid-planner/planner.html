<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Planning Simulator | Dr. Eshan Singh</title>
    <link rel="icon" type="image/png" href="/assets/favicon.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-plugin-dragdata@2.2.1/dist/chartjs-plugin-dragdata.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Lora:wght@400;500;700&display=swap"
        rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #fcfcfc;
            color: #1f2937;
        }

        .font-lora {
            font-family: 'Lora', serif;
        }

        .glass-card {
            background-color: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 1rem;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
        }

        .mesh-gradient-container {
            position: relative;
            z-index: 1;
        }

        .mesh-gradient-1 {
            background-image: radial-gradient(at 40% 20%, hsla(28, 100%, 74%, 1) 0px, transparent 50%),
                radial-gradient(at 80% 20%, hsla(189, 100%, 56%, 1) 0px, transparent 50%),
                radial-gradient(at 0% 50%, hsla(355, 100%, 93%, 1) 0px, transparent 50%),
                radial-gradient(at 80% 50%, hsla(340, 100%, 76%, 1) 0px, transparent 50%),
                radial-gradient(at 0% 100%, hsla(22, 100%, 77%, 1) 0px, transparent 50%),
                radial-gradient(at 80% 100%, hsla(242, 100%, 70%, 1) 0px, transparent 50%);
            background-size: 100% 100%;
            filter: blur(25px) saturate(1.2);
            opacity: 0.15;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: -1;
            animation: pulse-bg 15s infinite alternate;
        }

        .tutorial-active .mesh-gradient-1 {
            animation: none !important;
        }

        .form-input {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 0.5rem;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 9999px;
            outline: none;
            border: 1px solid #e5e7eb;
            transition: background .2s;
        }

        .form-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 1.25rem;
            height: 1.25rem;
            background: #2563eb;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .form-input::-moz-range-thumb {
            width: 1.25rem;
            height: 1.25rem;
            background: #2563eb;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .mix-slider-track {
            background-color: #e5e7eb;
            border-radius: 9999px;
            height: 0.75rem;
            width: 100%;
            overflow: hidden;
            position: relative;
        }

        .mix-slider-fill {
            height: 100%;
            border-radius: 9999px;
            transition: width 0.2s ease-in-out;
        }

        .mix-slider-default-outline {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            border: 1px solid black;
            border-radius: 9999px;
            box-sizing: border-box;
            background: transparent;
        }

        .value-input {
            width: 6rem;
            /* Adjust width as needed */
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            border: 1px solid #d1d5db;
            text-align: right;
            background-color: rgba(255, 255, 255, 0.8);
        }

        /* Color-coded slider thumbs */
        .thumb-solar::-webkit-slider-thumb {
            background-color: rgba(251, 191, 36, 1);
        }

        .thumb-solar::-moz-range-thumb {
            background-color: rgba(251, 191, 36, 1);
        }

        .thumb-wind::-webkit-slider-thumb {
            background-color: rgba(52, 211, 153, 1);
        }

        /* Lighter green */
        .thumb-wind::-moz-range-thumb {
            background-color: rgba(52, 211, 153, 1);
        }

        /* Lighter green */
        .thumb-offshoreWind::-webkit-slider-thumb {
            background-color: rgba(12, 148, 103, 1);
        }

        .thumb-offshoreWind::-moz-range-thumb {
            background-color: rgba(12, 148, 103, 1);
        }

        .thumb-geothermal::-webkit-slider-thumb {
            background-color: rgba(120, 40, 40, 1);
        }

        .thumb-geothermal::-moz-range-thumb {
            background-color: rgba(120, 40, 40, 1);
        }

        .thumb-nuclear::-webkit-slider-thumb {
            background-color: rgba(239, 68, 68, 1);
        }

        .thumb-nuclear::-moz-range-thumb {
            background-color: rgba(239, 68, 68, 1);
        }

        .thumb-storage::-webkit-slider-thumb {
            background-color: rgba(168, 85, 247, 1);
        }

        .thumb-storage::-moz-range-thumb {
            background-color: rgba(168, 85, 247, 1);
        }

        .thumb-neutral::-webkit-slider-thumb {
            background-color: rgba(107, 114, 128, 1);
        }

        .thumb-neutral::-moz-range-thumb {
            background-color: rgba(107, 114, 128, 1);
        }

        .thumb-biomass::-webkit-slider-thumb {
            background-color: rgba(101, 67, 33, 1);
        }

        /* Brown color for biomass */
        .thumb-biomass::-moz-range-thumb {
            background-color: rgba(101, 67, 33, 1);
        }

        .thumb-rng::-webkit-slider-thumb {
            background-color: rgba(132, 204, 22, 1);
        }

        /* Lime green for RNG */
        .thumb-rng::-moz-range-thumb {
            background-color: rgba(132, 204, 22, 1);
        }

        .thumb-hydrogen::-webkit-slider-thumb {
            background-color: rgba(219, 39, 119, 1);
        }

        /* Pink/magenta for hydrogen */
        .thumb-hydrogen::-moz-range-thumb {
            background-color: rgba(219, 39, 119, 1);
        }

        /* Rainbow Border Animation */
        @keyframes rainbow-border {
            0% {
                background-position: 0% 50%;
            }

            100% {
                background-position: 200% 50%;
            }
        }

        .rainbow-glow {
            position: relative;
            background: linear-gradient(90deg, #ff0080, #ff8000, #ffff00, #80ff00, #00ff80, #0080ff, #8000ff, #ff0080);
            background-size: 200% 200%;
            animation: rainbow-border 2s linear infinite;
            padding: 2px;
            border-radius: 9999px;
        }

        .rainbow-glow .button-content {
            background: #f3f4f6;
            border-radius: 9999px;
            padding: 0.5rem 1rem;
            display: block;
            color: #374151;
            font-size: 0.875rem;
            font-weight: 500;
            transition: background-color 0.3s;
        }

        .rainbow-glow:hover .button-content {
            background: #e5e7eb;
        }

        /* Style for active season preset button */
        .preset-active {
            background-color: #4b5563 !important;
            /* A darker gray */
            color: #ffffff !important;
        }

        /* --- TUTORIAL STYLES --- */
        #tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 9998;
            display: none;
            /* Controlled by JS */
        }

        #tutorial-popover {
            position: fixed;
            background-color: white;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            z-index: 10001;
            width: 320px;
            max-width: 90vw;
            display: none;
            transition: top 0.3s ease-in-out, left 0.3s ease-in-out, transform 0.3s ease-in-out;
        }

        .tutorial-highlight-active {
            position: relative;
            z-index: 9999;
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.7),
                0 0 20px 10px rgba(59, 130, 246, 0.4),
                0 0 0 9999px rgba(0, 0, 0, 0.6);
            transition: box-shadow 0.3s ease-in-out;
        }

        .tutorial-highlight-active.rounded-full {
            border-radius: 9999px;
        }

        .tutorial-highlight-active.rounded-lg {
            border-radius: 1rem;
        }

        /* --- TAB STYLES --- */
        .tab-button {
            color: #6B7280;
            cursor: pointer;
        }

        .tab-button:hover {
            background-color: #F3F4F6;
        }

        .tab-button.tab-active {
            background-color: #3B82F6;
            color: white;
        }

        .tab-content {
            animation: fadeIn 0.3s ease-in;
        }

        .tab-content.hidden {
            display: none;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* --- OPTIMIZATION RESULTS STYLES --- */
        .optimization-results {
            animation: slideIn 0.4s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .metric-card {
            padding: 1rem;
            background-color: #F9FAFB;
            border-radius: 0.5rem;
        }

        .capacity-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem;
            background-color: #F3F4F6;
            border-radius: 0.375rem;
            margin-bottom: 0.5rem;
        }

        .capacity-item:hover {
            background-color: #E5E7EB;
        }

        /* --- BUTTON STYLES --- */
        .btn {
            display: inline-block;
            padding: 0.5rem 1rem;
            font-weight: 500;
            border-radius: 0.375rem;
            transition: all 0.2s;
            cursor: pointer;
            border: none;
        }

        .btn-success {
            background-color: #10B981;
            color: white;
        }

        .btn-success:hover {
            background-color: #059669;
        }

        .btn-secondary {
            background-color: #6B7280;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #4B5563;
        }

        /* --- NOTIFICATION STYLES --- */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #10B981;
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            z-index: 10000;
            animation: notificationSlide 0.3s ease-out;
        }

        @keyframes notificationSlide {
            from {
                transform: translateX(400px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>

<body class="antialiased">
    <!-- Custom Confirmation Modal -->
    <div id="confirmation-modal" class="hidden fixed inset-0 z-50 overflow-y-auto">
        <!-- Backdrop -->
        <div class="fixed inset-0 bg-black bg-opacity-50 transition-opacity"></div>

        <!-- Modal Content -->
        <div class="flex items-center justify-center min-h-screen p-4">
            <div class="relative bg-white rounded-lg shadow-xl max-w-md w-full p-6 transform transition-all">
                <!-- Icon -->
                <div class="flex items-center justify-center w-12 h-12 mx-auto mb-4 bg-orange-100 rounded-full">
                    <svg class="w-6 h-6 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z">
                        </path>
                    </svg>
                </div>

                <!-- Title -->
                <h3 class="text-lg font-semibold text-gray-900 text-center mb-2">Re-run Optimization?</h3>

                <!-- Message -->
                <p class="text-sm text-gray-600 text-center mb-6" id="confirmation-modal-message">
                    This will modify the baseline capacity assumptions and re-run the optimization. Proceed?
                </p>

                <!-- Buttons -->
                <div class="flex gap-3">
                    <button id="confirmation-modal-cancel"
                        class="flex-1 px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium rounded-lg transition-colors">
                        Cancel
                    </button>
                    <button id="confirmation-modal-ok"
                        class="flex-1 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg transition-colors">
                        OK
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Tooltip element -->
    <div id="hover-tooltip"
        class="absolute hidden bg-gray-800 text-white text-sm rounded-md px-2 py-1 z-50 pointer-events-none shadow-lg">
    </div>

    <!-- TUTORIAL HTML -->
    <div id="tutorial-overlay"></div>
    <div id="tutorial-popover">
        <h3 id="tutorial-title" class="text-xl font-lora font-bold mb-2 text-gray-800"></h3>
        <p id="tutorial-text" class="text-gray-600 mb-4"></p>
        <div class="flex justify-between items-center">
            <button id="tutorial-skip" class="text-sm text-gray-500 hover:text-gray-800">Skip Tour</button>
            <div>
                <button id="tutorial-prev"
                    class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-200 rounded-md hover:bg-gray-300 mr-2">Prev</button>
                <button id="tutorial-next"
                    class="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700">Next</button>
            </div>
        </div>
    </div>

    <div class="mesh-gradient-container">
        <div class="mesh-gradient-1"></div>

        <header class="p-8">
            <div class="container mx-auto flex justify-between items-center">
                <div class="flex flex-col">
                    <a href="/" class="font-lora text-2xl font-semibold">Dr. Eshan Singh</a>
                    <div class="text-sm text-gray-500 mt-1">
                        <span>Views: </span><span id="visitor-count">Loading...</span>
                    </div>
                </div>
                <nav class="flex items-center space-x-2">
                    <a href="/energy.html"
                        class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-full hover:bg-gray-200 transition-colors">Articles</a>
                    <a href="/transport-model/index.html" class="rainbow-glow">
                        <span class="button-content">Transport Model</span>
                    </a>
                    <a href="/grid-planner/index.html" class="rainbow-glow">
                        <span class="button-content">Grid Planner</span>
                    </a>
                    <a href="/grid-operator/index.html" class="rainbow-glow">
                        <span class="button-content">Grid Operator</span>
                    </a>
                    <a href="https://www.eshansingh.xyz/transmission/index.html" class="rainbow-glow">
                        <span class="button-content">CA Grid Map</span>
                    </a>
                    <a href="/musings.html"
                        class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-full hover:bg-gray-200 transition-colors">Musings</a>
                </nav>
            </div>
        </header>

        <div class="container mx-auto p-4 md:p-8 pt-0">

            <section id="tutorial-step-1" class="text-center mb-12">
                <h1 class="font-lora text-5xl md:text-6xl font-medium leading-tight text-gray-900">Grid Planning
                    Simulator</h1>
                <p class="mt-4 text-lg text-gray-600 max-w-3xl mx-auto">
                    Your challenge: Use policy levers for clean energy and direct air capture to eliminate CO2 emissions
                    from the electricity grid, while minimizing the impact on customer bill.
                </p>
                <div class="flex justify-center items-center space-x-4 mt-4">
                    <a href="grid-model-documentation.html"
                        class="inline-flex items-center px-4 py-2 bg-blue-100 text-blue-700 rounded-full hover:bg-blue-200 transition-colors text-sm font-medium">
                        ðŸ“– View Documentation
                    </a>
                    <button id="start-tutorial-btn"
                        class="inline-flex items-center px-4 py-2 bg-green-100 text-green-700 rounded-full hover:bg-green-200 transition-colors text-sm font-medium">
                        ðŸš€ Show Tutorial
                    </button>
                </div>
                <p class="mt-4 text-sm text-gray-600">
                    Send your queries at <a href="mailto:hello@eshansingh.xyz"
                        class="text-blue-600 hover:underline">hello@eshansingh.xyz</a>
                </p>
            </section>

            <!-- TAB NAVIGATION -->
            <div class="flex justify-center mb-8">
                <div class="inline-flex rounded-lg border border-gray-200 bg-white p-1 shadow-sm">
                    <button id="tab-manual"
                        class="tab-button tab-active px-6 py-2 rounded-md text-sm font-medium transition-colors">
                        Manual Mode
                    </button>
                    <button id="tab-optimize"
                        class="tab-button px-6 py-2 rounded-md text-sm font-medium transition-colors">
                        Optimize Mode
                    </button>
                </div>
            </div>

            <!-- MANUAL MODE TAB CONTENT -->
            <div id="manual-mode-content" class="tab-content">
                <!-- Full Width Charts Section - LOAD GENERATION, PRICE, CO2 -->
                <div class="space-y-8 mb-8">
                    <!-- Load Generation Chart -->
                    <div class="glass-card rounded-lg w-full">
                        <div class="mb-4 relative">
                            <div class="flex justify-between items-center mb-4">
                                <h2 class="text-2xl font-lora font-semibold text-gray-800">All Year - Hourly Electricity
                                    Generation (GWh)</h2>
                                <button id="downloadGenerationBtn" class="p-2 rounded-full hover:bg-gray-200"
                                    title="Download CSV">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none"
                                        viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                                    </svg>
                                </button>
                            </div>
                            <canvas id="generationMixChart" height="100"></canvas>
                        </div>
                    </div>

                    <!-- Marginal Price Chart -->
                    <div class="glass-card rounded-lg w-full">
                        <h2 class="text-2xl font-lora font-semibold mb-4 text-gray-800">All Year - Hourly Marginal Price
                            ($/MWh)</h2>
                        <canvas id="marginalPriceChart" height="100"></canvas>
                    </div>

                    <!-- Monthly CO2 Emissions Bar Chart -->
                    <div class="glass-card rounded-lg w-full">
                        <h2 class="text-2xl font-lora font-semibold mb-4 text-gray-800">Monthly Total CO2 Emissions
                            (Metric
                            Tons)</h2>
                        <canvas id="co2EmissionsChart" height="100"></canvas>
                    </div>
                </div>

                <!-- Row 1: Installed Capacity Mix | Generation Mix (Full Width) -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                    <!-- Installed Capacity Mix -->
                    <div id="tutorial-step-4" class="glass-card rounded-lg">
                        <h2 class="text-2xl font-lora font-semibold mb-4 text-gray-800">Installed Capacity Mix (%)</h2>
                        <div id="grid-mix-sliders" class="space-y-3">
                            <!-- Sliders will be dynamically inserted here -->
                        </div>
                        <!-- NEW: Container for storage capacity display -->
                        <div id="storage-capacity-display" class="mt-6"></div>
                    </div>

                    <!-- Generation Mix -->
                    <div class="glass-card rounded-lg">
                        <h2 class="text-2xl font-lora font-semibold mb-4 text-gray-800">Yearly Generation Mix (%)</h2>
                        <div id="generation-mix-sliders" class="space-y-3">
                            <!-- New chart sliders will be dynamically inserted here -->
                        </div>
                    </div>
                </div>

                <!-- Row 2: Policy Levers | (Metrics + Government Incentives) -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                    <!-- Left: Policy Levers -->
                    <div id="tutorial-step-3" class="glass-card space-y-6 rounded-lg">
                        <div class="mb-6">
                            <label for="country-select" class="block text-md font-medium text-gray-700 mb-2">Select
                                Default Grid Mix</label>
                            <select id="country-select"
                                class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 bg-white">
                                <!-- Options will be populated by JS -->
                            </select>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <div class="flex items-center justify-around">
                                <button id="undo-button"
                                    class="p-2 text-sm font-medium text-gray-700 bg-gray-200 rounded-full hover:bg-gray-300 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                                    title="Undo" disabled>
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                        fill="currentColor">
                                        <path fill-rule="evenodd"
                                            d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"
                                            clip-rule="evenodd" />
                                    </svg>
                                </button>
                                <button id="redo-button"
                                    class="p-2 text-sm font-medium text-gray-700 bg-gray-200 rounded-full hover:bg-gray-300 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                                    title="Redo" disabled>
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                        fill="currentColor">
                                        <path fill-rule="evenodd"
                                            d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"
                                            clip-rule="evenodd" />
                                    </svg>
                                </button>
                            </div>
                            <button id="make-default-button"
                                class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-200 rounded-full hover:bg-gray-300 transition-colors"
                                title="Set the current lever positions as your new default">Make Default</button>
                            <button id="reset-to-default-button"
                                class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-200 rounded-full hover:bg-gray-300 transition-colors"
                                title="Reset levers to the default for this grid mix">Reset to Default</button>
                            <button id="reset-to-zero-button"
                                class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-200 rounded-full hover:bg-gray-300 transition-colors"
                                title="Reset all policy and new capacity levers to zero">Reset to Zero</button>
                        </div>
                        <div>
                            <h2
                                class="text-2xl font-lora font-semibold mb-4 border-b border-t pt-4 border-gray-300 pb-4 text-gray-800">
                                Policy Levers</h2>
                            <div class="space-y-6 pt-4">
                                <!-- Levers -->
                                <div>
                                    <label for="solar-slider" class="block text-md font-medium text-gray-700">New Solar
                                        Capacity</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="solar-slider" min="0" max="200" step="0.01" value="0"
                                            class="w-full form-input thumb-solar">
                                        <input type="number" id="solar-input" min="0" max="200" step="0.01" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="solar-unit">GW</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="wind-slider" class="block text-md font-medium text-gray-700">New Onshore
                                        Wind Capacity</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="wind-slider" min="0" max="200" step="0.01" value="0"
                                            class="w-full form-input thumb-wind">
                                        <input type="number" id="wind-input" min="0" max="200" step="0.01" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="wind-unit">GW</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="offshoreWind-slider" class="block text-md font-medium text-gray-700">New
                                        Offshore Wind Capacity</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="offshoreWind-slider" min="0" max="200" step="0.01"
                                            value="0" class="w-full form-input thumb-offshoreWind">
                                        <input type="number" id="offshoreWind-input" min="0" max="200" step="0.01"
                                            value="0" class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="offshoreWind-unit">GW</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="geothermal-slider" class="block text-md font-medium text-gray-700">New
                                        Geothermal Capacity</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="geothermal-slider" min="0" max="50" step="0.01"
                                            value="0" class="w-full form-input thumb-geothermal">
                                        <input type="number" id="geothermal-input" min="0" max="50" step="0.01"
                                            value="0" class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="geothermal-unit">GW</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="nuclear-slider" class="block text-md font-medium text-gray-700">New
                                        Nuclear Capacity</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="nuclear-slider" min="0" max="50" step="0.01" value="0"
                                            class="w-full form-input thumb-nuclear">
                                        <input type="number" id="nuclear-input" min="0" max="50" step="0.01" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="nuclear-unit">GW</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="biomass-slider" class="block text-md font-medium text-gray-700">New
                                        Biomass Capacity</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="biomass-slider" min="0" max="50" step="1" value="0"
                                            class="w-full form-input thumb-biomass">
                                        <input type="number" id="biomass-input" min="0" max="50" step="1" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="biomass-unit">GW</span>
                                    </div>
                                </div>
                                <!-- NEW: RNG (Biogas) Slider -->
                                <div>
                                    <label for="rng-slider" class="block text-md font-medium text-gray-700">New RNG
                                        (Biogas) Capacity</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="rng-slider" min="0" max="50" step="1" value="0"
                                            class="w-full form-input thumb-rng">
                                        <input type="number" id="rng-input" min="0" max="50" step="1" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left" id="rng-unit">GW</span>
                                    </div>
                                </div>
                                <!-- NEW: Hydrogen Slider -->
                                <div>
                                    <label for="hydrogen-slider" class="block text-md font-medium text-gray-700">New
                                        Hydrogen Capacity</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="hydrogen-slider" min="0" max="50" step="1" value="0"
                                            class="w-full form-input thumb-hydrogen">
                                        <input type="number" id="hydrogen-input" min="0" max="50" step="1" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="hydrogen-unit">GW</span>
                                    </div>
                                </div>
                                <div class="border-t border-gray-300 pt-6">
                                    <label for="battery4hr-slider" class="block text-md font-medium text-gray-700">4-hr
                                        Battery Storage</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="battery4hr-slider" min="0" max="200" step="0.01"
                                            value="0" class="w-full form-input thumb-storage">
                                        <input type="number" id="battery4hr-input" min="0" max="200" step="0.01"
                                            value="0" class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="battery4hr-unit">GWh</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="battery8hr-slider" class="block text-md font-medium text-gray-700">8-hr
                                        Battery Storage</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="battery8hr-slider" min="0" max="200" step="0.01"
                                            value="0" class="w-full form-input thumb-storage">
                                        <input type="number" id="battery8hr-input" min="0" max="200" step="0.01"
                                            value="0" class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="battery8hr-unit">GWh</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="longduration-slider"
                                        class="block text-md font-medium text-gray-700">24-hr Long Duration
                                        Storage</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="longduration-slider" min="0" max="500" step="0.01"
                                            value="0" class="w-full form-input thumb-storage">
                                        <input type="number" id="longduration-input" min="0" max="500" step="0.01"
                                            value="0" class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="longduration-unit">GWh</span>
                                    </div>
                                </div>
                                <div class="border-t border-gray-300 pt-6">
                                    <label for="demandflex-slider"
                                        class="block text-md font-medium text-gray-700">Demand Flexibility</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="demandflex-slider" min="0" max="25" value="0"
                                            class="w-full form-input thumb-neutral">
                                        <input type="number" id="demandflex-input" min="0" max="25" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="demandflex-unit">%</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="dac-slider" class="block text-md font-medium text-gray-700">Direct Air
                                        Capture
                                        Deployment</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="dac-slider" min="0" max="10000" step="0.1" value="0"
                                            class="w-full form-input thumb-neutral">
                                        <input type="number" id="dac-input" min="0" max="10000" step="0.1" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="dac-unit">t/hr</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>


                    <!-- Right: Metrics + Government Incentives -->
                    <div class="space-y-8">
                        <div id="tutorial-step-5" class="glass-card rounded-lg sticky top-6 z-10">
                            <div class="grid grid-cols-2 gap-4 text-center">
                                <div
                                    title="Based on the average wholesale price of electricity&#10;Assuming natural gas plant on the margin drives the price">
                                    <h3 class="text-xl font-lora font-semibold text-gray-800">Marginal Price</h3>
                                    <p id="bill-impact" class="text-5xl font-bold text-blue-600 mt-2">0%</p>
                                </div>
                                <div title="Based on the total annualized cost to operate the grid">
                                    <h3 class="text-xl font-lora font-semibold text-gray-800">System Cost</h3>
                                    <p id="system-cost-impact" class="text-5xl font-bold text-blue-600 mt-2">0%</p>
                                </div>
                            </div>
                            <div class="text-center mt-2">
                                <p id="co2-avoided-text" class="text-md font-medium text-gray-700"></p>
                            </div>
                        </div>



                        <!-- Government Incentives Section -->
                        <div class="glass-card rounded-lg">
                            <h2
                                class="text-2xl font-lora font-semibold mb-4 border-b border-t border-gray-300 pt-4 pb-4 text-gray-800">
                                Government Incentives</h2>
                            <div class="space-y-6 pt-4">
                                <!-- Incentive levers -->
                                <div>
                                    <label for="carbon-tax-slider"
                                        class="block text-sm font-medium text-gray-700">Carbon Tax</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="carbon-tax-slider" min="0" max="200" value="0"
                                            class="w-full form-input thumb-neutral">
                                        <input type="number" id="carbon-tax-input" min="0" max="200" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="carbon-tax-unit">$/ton</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="export-price-slider"
                                        class="block text-sm font-medium text-gray-700">Export Price</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="export-price-slider" min="-100" max="100" value="-20"
                                            class="w-full form-input thumb-neutral">
                                        <input type="number" id="export-price-input" min="-100" max="100" value="-20"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="export-price-unit">$/MWh</span>
                                    </div>
                                </div>
                                <div class="border-t border-gray-300 pt-6">
                                    <label for="solar-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">Solar (PTC)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="solar-incentive-slider" min="0" max="50" value="0"
                                            class="w-full form-input thumb-solar">
                                        <input type="number" id="solar-incentive-input" min="0" max="50" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="solar-incentive-unit">$/MWh</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="wind-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">Onshore Wind (PTC)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="wind-incentive-slider" min="0" max="50" value="0"
                                            class="w-full form-input thumb-wind">
                                        <input type="number" id="wind-incentive-input" min="0" max="50" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="wind-incentive-unit">$/MWh</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="offshoreWind-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">Offshore Wind (PTC)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="offshoreWind-incentive-slider" min="0" max="50"
                                            value="0" class="w-full form-input thumb-offshoreWind">
                                        <input type="number" id="offshoreWind-incentive-input" min="0" max="50"
                                            value="0" class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="offshoreWind-incentive-unit">$/MWh</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="geothermal-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">Geothermal (PTC)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="geothermal-incentive-slider" min="0" max="50" value="0"
                                            class="w-full form-input thumb-geothermal">
                                        <input type="number" id="geothermal-incentive-input" min="0" max="50" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="geothermal-incentive-unit">$/MWh</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="nuclear-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">Nuclear (PTC)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="nuclear-incentive-slider" min="0" max="50" value="0"
                                            class="w-full form-input thumb-nuclear">
                                        <input type="number" id="nuclear-incentive-input" min="0" max="50" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="nuclear-incentive-unit">$/MWh</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="biomass-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">Biomass (PTC)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="biomass-incentive-slider" min="0" max="50" value="0"
                                            class="w-full form-input thumb-biomass">
                                        <input type="number" id="biomass-incentive-input" min="0" max="50" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="biomass-incentive-unit">$/MWh</span>
                                    </div>
                                </div>
                                <!-- NEW: RNG (Biogas) Incentive Slider -->
                                <div>
                                    <label for="rng-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">RNG (Biogas) (PTC)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="rng-incentive-slider" min="0" max="50" value="0"
                                            class="w-full form-input thumb-rng">
                                        <input type="number" id="rng-incentive-input" min="0" max="50" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="rng-incentive-unit">$/MWh</span>
                                    </div>
                                </div>
                                <!-- NEW: Hydrogen Incentive Slider -->
                                <div>
                                    <label for="hydrogen-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">Hydrogen (PTC)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="hydrogen-incentive-slider" min="0" max="50" value="0"
                                            class="w-full form-input thumb-hydrogen">
                                        <input type="number" id="hydrogen-incentive-input" min="0" max="50" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="hydrogen-incentive-unit">$/MWh</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="storage-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">Storage (ITC)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="storage-incentive-slider" min="0" max="100" value="0"
                                            class="w-full form-input thumb-storage">
                                        <input type="number" id="storage-incentive-input" min="0" max="100" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="storage-incentive-unit">$/kWh</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="dac-incentive-slider"
                                        class="block text-sm font-medium text-gray-700">Direct Air Capture (45Q)</label>
                                    <div class="flex items-center space-x-2 mt-2">
                                        <input type="range" id="dac-incentive-slider" min="0" max="200" value="0"
                                            class="w-full form-input thumb-neutral">
                                        <input type="number" id="dac-incentive-input" min="0" max="200" value="0"
                                            class="value-input">
                                        <span class="font-semibold text-gray-900 w-12 text-left"
                                            id="dac-incentive-unit">$/ton</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>


                <!-- Hourly Capacity Factors Chart -->
                <div class="grid grid-cols-1 gap-8 mb-8">
                    <div id="tutorial-step-2" class="glass-card rounded-lg w-full">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-2xl font-lora font-semibold text-gray-800">Hourly Capacity Factors</h2>
                            <div class="flex items-center space-x-2">
                                <div id="cf-edit-controls" class="flex items-center space-x-1">
                                    <button id="edit-cf-btn" class="p-2 rounded-full hover:bg-gray-200"
                                        title="Edit capacity factor profiles">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                            fill="currentColor">
                                            <path
                                                d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" />
                                            <path fill-rule="evenodd"
                                                d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z"
                                                clip-rule="evenodd" />
                                        </svg>
                                    </button>
                                    <button id="revert-cf-btn" class="p-2 rounded-full hover:bg-gray-200 hidden"
                                        title="Revert to original capacity factor profiles">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-700"
                                            viewBox="0 0 20 20" fill="currentColor">
                                            <path fill-rule="evenodd"
                                                d="M7.707 3.293a1 1 0 010 1.414L5.414 7H11a7 7 0 017 7v2a1 1 0 11-2 0v-2a5 5 0 00-5-5H5.414l2.293 2.293a1 1 0 11-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"
                                                clip-rule="evenodd" />
                                        </svg>
                                    </button>
                                    <button id="confirm-cf-btn" class="p-2 rounded-full hover:bg-gray-200 hidden"
                                        title="Confirm changes to capacity factors">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-500"
                                            viewBox="0 0 20 20" fill="currentColor">
                                            <path fill-rule="evenodd"
                                                d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
                                                clip-rule="evenodd" />
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <canvas id="capacityFactorChart" height="100"></canvas>
                    </div>
                </div>

            </div>
        </div>
    </div>
    </div>
    </div>

    <!-- END MANUAL MODE CONTENT -->
    </div>

    <!-- OPTIMIZE MODE TAB CONTENT -->
    <div id="optimize-mode-content" class="tab-content hidden">
        <div class="max-w-4xl mx-auto">
            <div class="glass-card rounded-lg p-8">
                <h2 class="text-3xl font-lora font-semibold mb-2 text-gray-900">Capacity Expansion Optimization</h2>
                <p class="text-gray-600 mb-8">
                    Let the algorithm find the optimal mix of generation and storage capacity to meet your CO2 emissions
                    target at minimum cost.
                </p>

                <!-- Input Section -->
                <div class="space-y-6 mb-8">
                    <!-- CO2 Target Input -->
                    <div>
                        <label for="co2-target-input" class="block text-sm font-medium text-gray-700 mb-2">
                            CO2 Emissions Target (million metric tons/year)
                        </label>
                        <input type="number" id="co2-target-input" value="30.0" min="0" max="100" step="1"
                            class="w-full px-4 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                        <p class="mt-2 text-sm text-gray-500">
                            Current baseline: <span id="baseline-co2" class="font-semibold text-gray-700">38.09</span>
                            million MT
                        </p>
                    </div>

                    <!-- Options Checkboxes -->
                    <div class="space-y-3">
                        <label class="flex items-center">
                            <input type="checkbox" id="allow-dac" checked
                                class="mr-2 form-checkbox h-4 w-4 text-blue-600">
                            <span class="text-sm text-gray-700">
                                Allow Direct Air Capture (DAC) <span class="text-gray-500">- Enable CO2 removal
                                    technology if needed</span>
                            </span>
                        </label>

                        <label class="flex items-center">
                            <input type="checkbox" id="respect-curtailment" checked
                                class="mr-2 form-checkbox h-4 w-4 text-blue-600">
                            <span class="text-sm text-gray-700">
                                Limit curtailment to 20% <span class="text-gray-500">- Prevents excessive renewable
                                    overbuild</span>
                            </span>
                        </label>
                    </div>

                    <!-- Documentation Link -->
                    <a href="optimizer-documentation.html" target="_blank"
                        class="inline-flex items-center px-4 py-2 bg-blue-100 text-blue-700 rounded-full hover:bg-blue-200 transition-colors text-sm font-medium">
                        ðŸ“– Optimizer Documentation
                    </a>
                </div>

                <!-- Cost Assumptions Edit Section -->
                <div class="mb-6">
                    <button id="toggle-costs-btn"
                        class="text-blue-600 hover:text-blue-800 text-sm font-medium flex items-center focus:outline-none transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20"
                            fill="currentColor">
                            <path
                                d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" />
                        </svg>
                        Edit Cost & Performance Assumptions
                    </button>

                    <!-- Cost Assumptions Editor (Hidden) -->
                    <div id="cost-editor-container"
                        class="hidden mt-3 p-4 bg-gray-50 rounded-lg border border-gray-200 shadow-inner">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="font-semibold text-gray-800 text-sm">Technology Cost Assumptions</h3>
                            <button id="reset-costs-btn"
                                class="text-xs text-red-600 hover:text-red-800 border border-red-200 px-2 py-1 rounded bg-white hover:bg-red-50 transition-colors">
                                Reset to Defaults
                            </button>
                        </div>

                        <!-- Global Params -->
                        <div class="mb-4">
                            <label class="block text-xs font-medium text-gray-500 mb-1">Discount Rate (decimal)</label>
                            <input type="number" id="cost-discount-rate" step="0.01" min="0" max="0.2"
                                class="w-32 text-sm border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500">
                        </div>

                        <!-- Table -->
                        <div class="overflow-x-auto">
                            <table class="min-w-full text-xs text-left bg-white rounded border border-gray-200">
                                <thead>
                                    <tr class="bg-gray-100 border-b border-gray-200">
                                        <th class="px-3 py-2 font-medium text-gray-700">Technology</th>
                                        <th class="px-2 py-2 font-medium text-gray-700">CAPEX<br><span
                                                class="font-normal text-gray-400 text-[10px]">$/kW</span></th>
                                        <th class="px-2 py-2 font-medium text-gray-700">Fixed O&M<br><span
                                                class="font-normal text-gray-400 text-[10px]">$/kW-yr</span></th>
                                        <th class="px-2 py-2 font-medium text-gray-700">Var O&M<br><span
                                                class="font-normal text-gray-400 text-[10px]">$/MWh</span></th>
                                        <th class="px-2 py-2 font-medium text-gray-700">Life<br><span
                                                class="font-normal text-gray-400 text-[10px]">yrs</span></th>
                                    </tr>
                                </thead>
                                <tbody id="cost-table-body" class="divide-y divide-gray-200">
                                    <!-- Rows injected by JS -->
                                </tbody>
                            </table>
                        </div>
                        <p class="text-xs text-gray-500 mt-2 italic">* Storage CAPEX is $/kWh. DAC CAPEX is $/ton/yr. NG
                            Variable O&M shows start-end range implies ramp.</p>

                        <!-- Supply Curves Section -->
                        <div class="mt-6 pt-6 border-t border-gray-300">
                            <h4 class="font-semibold text-gray-800 text-sm mb-3">Supply Curves (Resource-Constrained Technologies)</h4>
                            <p class="text-xs text-gray-600 mb-3">CAPEX multipliers increase as deployment grows. Base CAPEX (from table above) Ã— multiplier = effective CAPEX.</p>

                            <!-- Geothermal Supply Curve -->
                            <div class="mb-4 bg-blue-50 rounded p-3 border border-blue-200">
                                <label class="block text-xs font-semibold text-gray-700 mb-2">Geothermal Supply Curve</label>
                                <div class="grid grid-cols-3 gap-2 text-xs">
                                    <div>
                                        <label class="block text-[10px] text-gray-500 mb-1">0-2 GW Multiplier</label>
                                        <input type="number" id="geo-mult-1" step="0.1" min="0.5" max="3.0"
                                            class="w-full text-xs border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                    </div>
                                    <div>
                                        <label class="block text-[10px] text-gray-500 mb-1">2-4 GW Multiplier</label>
                                        <input type="number" id="geo-mult-2" step="0.1" min="0.5" max="3.0"
                                            class="w-full text-xs border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                    </div>
                                    <div>
                                        <label class="block text-[10px] text-gray-500 mb-1">4-5 GW Multiplier</label>
                                        <input type="number" id="geo-mult-3" step="0.1" min="0.5" max="3.0"
                                            class="w-full text-xs border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                    </div>
                                </div>
                            </div>

                            <!-- Biomass Supply Curve -->
                            <div class="mb-4 bg-green-50 rounded p-3 border border-green-200">
                                <label class="block text-xs font-semibold text-gray-700 mb-2">Biomass Supply Curve</label>
                                <div class="grid grid-cols-2 gap-2 text-xs">
                                    <div>
                                        <label class="block text-[10px] text-gray-500 mb-1">0-1.5 GW Multiplier</label>
                                        <input type="number" id="bio-mult-1" step="0.1" min="0.5" max="3.0"
                                            class="w-full text-xs border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                    </div>
                                    <div>
                                        <label class="block text-[10px] text-gray-500 mb-1">1.5-3 GW Multiplier</label>
                                        <input type="number" id="bio-mult-2" step="0.1" min="0.5" max="3.0"
                                            class="w-full text-xs border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Capacity Bounds Section -->
                        <div class="mt-6 pt-6 border-t border-gray-300">
                            <h4 class="font-semibold text-gray-800 text-sm mb-3">Capacity Bounds (Max New Additions)</h4>
                            <p class="text-xs text-gray-600 mb-3">Maximum capacity additions for each technology. Generation in GW, Storage in GWh.</p>

                            <div class="grid grid-cols-2 md:grid-cols-3 gap-3 text-xs">
                                <div>
                                    <label class="block text-[10px] text-gray-500 mb-1">Solar Max (GW)</label>
                                    <input type="number" id="bound-solar" step="5" min="0" max="500"
                                        class="w-full text-xs border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div>
                                    <label class="block text-[10px] text-gray-500 mb-1">Wind Max (GW)</label>
                                    <input type="number" id="bound-wind" step="5" min="0" max="500"
                                        class="w-full text-xs border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div>
                                    <label class="block text-[10px] text-gray-500 mb-1">Offshore Max (GW)</label>
                                    <input type="number" id="bound-offshoreWind" step="5" min="0" max="200"
                                        class="w-full text-xs border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div>
                                    <label class="block text-[10px] text-gray-500 mb-1">Nuclear Max (GW)</label>
                                    <input type="number" id="bound-nuclear" step="5" min="0" max="100"
                                        class="w-full text-xs border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div class="bg-blue-50 border border-blue-200">
                                    <label class="block text-[10px] text-gray-500 mb-1 px-2 pt-1">Geothermal Max (GW)</label>
                                    <input type="number" id="bound-geothermal" step="1" min="0" max="20"
                                        class="w-full text-xs border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500 px-2 pb-1">
                                </div>
                                <div class="bg-green-50 border border-green-200">
                                    <label class="block text-[10px] text-gray-500 mb-1 px-2 pt-1">Biomass Max (GW)</label>
                                    <input type="number" id="bound-biomass" step="0.5" min="0" max="10"
                                        class="w-full text-xs border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500 px-2 pb-1">
                                </div>
                                <div>
                                    <label class="block text-[10px] text-gray-500 mb-1">RNG Max (GW)</label>
                                    <input type="number" id="bound-rng" step="5" min="0" max="50"
                                        class="w-full text-xs border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div>
                                    <label class="block text-[10px] text-gray-500 mb-1">Hydrogen Max (GW)</label>
                                    <input type="number" id="bound-hydrogen" step="5" min="0" max="50"
                                        class="w-full text-xs border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div>
                                    <label class="block text-[10px] text-gray-500 mb-1">Battery 4hr Max (GWh)</label>
                                    <input type="number" id="bound-battery4hr" step="10" min="0" max="500"
                                        class="w-full text-xs border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div>
                                    <label class="block text-[10px] text-gray-500 mb-1">Battery 8hr Max (GWh)</label>
                                    <input type="number" id="bound-battery8hr" step="10" min="0" max="500"
                                        class="w-full text-xs border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div>
                                    <label class="block text-[10px] text-gray-500 mb-1">Long-Duration Max (GWh)</label>
                                    <input type="number" id="bound-longduration" step="10" min="0" max="1000"
                                        class="w-full text-xs border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div>
                                    <label class="block text-[10px] text-gray-500 mb-1">DAC Max (tons/hr)</label>
                                    <input type="number" id="bound-dac" step="1000" min="0" max="50000"
                                        class="w-full text-xs border-gray-300 rounded shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                </div>
                            </div>
                            <p class="text-xs text-gray-500 mt-2 italic">Bounds represent maximum new capacity additions (not total installed capacity).</p>
                        </div>

                        <!-- How the Optimizer Uses These Values -->
                        <div class="mt-6 pt-6 border-t border-gray-300 bg-gray-50 rounded p-4">
                            <h4 class="font-semibold text-gray-800 text-sm mb-2">How the Optimizer Uses These Parameters</h4>
                            <div class="text-xs text-gray-700 space-y-2">
                                <p><strong>Base CAPEX & O&M:</strong> Used to calculate annualized costs for each technology. The optimizer minimizes total system cost while meeting demand and CO2 targets.</p>
                                <p><strong>Supply Curves:</strong> For geothermal and biomass, costs increase with deployment. The optimizer sees: Base CAPEX Ã— multiplier = effective cost. This reflects resource quality degradation as the best sites are used first.</p>
                                <p><strong>Capacity Bounds:</strong> Hard constraints on maximum deployments. When a technology hits its bound, the optimizer explores alternative solutions. Tighter bounds force more diverse technology portfolios.</p>
                                <p class="italic text-gray-600">ðŸ’¡ Tip: Geothermal and biomass are resource-constrained (tightened bounds + supply curves) to reflect realistic deployment limits in California.</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Run Optimization Button -->
                <button id="run-optimization-btn"
                    class="w-full px-6 py-3 bg-blue-600 text-white font-medium rounded-lg hover:bg-blue-700 transition-colors shadow-md">
                    Find Optimal Solution
                </button>

                <!-- Progress Display -->
                <div id="optimization-progress" class="hidden mt-8">
                    <h3 class="font-semibold text-lg mb-3 text-gray-800">Optimization Progress</h3>

                    <!-- Phase Label + Progress Percent -->
                    <div class="flex justify-between items-center mb-2">
                        <span id="progress-phase-label" class="text-sm font-medium text-blue-700">Phase: Finding
                            Feasible Solution</span>
                        <span id="progress-percent" class="text-sm font-bold text-gray-700">0%</span>
                    </div>

                    <!-- Progress Bar -->
                    <div class="w-full bg-gray-200 rounded-full h-3 mb-4 overflow-hidden">
                        <div id="progress-bar"
                            class="bg-gradient-to-r from-blue-500 via-green-500 to-emerald-400 h-3 rounded-full transition-all duration-300"
                            style="width: 0%"></div>
                    </div>

                    <!-- Stats Grid -->
                    <div class="grid grid-cols-3 gap-4 text-center">
                        <div class="bg-gray-50 rounded-lg p-3">
                            <p class="text-xs text-gray-600 mb-1">CO2 Gap to Target</p>
                            <p class="text-xl font-bold text-gray-900"><span id="co2-gap-display">--</span></p>
                        </div>
                        <div class="bg-gray-50 rounded-lg p-3">
                            <p class="text-xs text-gray-600 mb-1">Best Cost</p>
                            <p class="text-xl font-bold text-blue-600">$<span id="best-cost">--</span>B/yr</p>
                        </div>
                        <div class="bg-gray-50 rounded-lg p-3">
                            <p class="text-xs text-gray-600 mb-1">CO2 Level</p>
                            <p class="text-xl font-bold text-green-600"><span id="current-co2">--</span> MT</p>
                        </div>
                    </div>
                </div>

                <!-- Results Display Container -->
                <div id="optimization-results-container" class="mt-8">
                    <!-- Results will be inserted here via JavaScript -->
                </div>
            </div>
        </div>
    </div>
    <!-- END OPTIMIZE MODE CONTENT -->

    <!-- Copyright Footer -->
    <footer class="container mx-auto p-4 mt-12 text-center border-t border-gray-200">
        <p class="text-sm text-gray-600">
            Â© 2025 <a href="https://eshansingh.xyz" class="font-medium text-gray-800 hover:text-blue-600">Dr. Eshan
                Singh</a>. All rights reserved.
        </p>
        <p class="text-xs text-gray-500 mt-1">
            For licensing inquiries: <a href="mailto:hello@eshansingh.xyz"
                class="text-blue-600 hover:text-blue-700 underline">hello@eshansingh.xyz</a>
        </p>
    </footer>
    <script type="module">
        // --- FIREBASE IMPORTS ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, runTransaction, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- HARDCODED FIREBASE CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyCdEeu0VugTfZD-R-62pFvBdb313TeM4xs",
            authDomain: "grid-decarbonization.firebaseapp.com",
            projectId: "grid-decarbonization",
            storageBucket: "grid-decarbonization.appspot.com",
            messagingSenderId: "902419724670",
            appId: "1:902419724670:web:b636a75ea44325946a9b2f",
            measurementId: "G-3Q9HE19CGN"
        };

        // --- INITIALIZE FIREBASE & DEFINE KEY VARIABLES ---
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const appId = firebaseConfig.appId;

        // --- MODEL PARAMETERS & DATA (GLOBAL SCOPE) ---
        const MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        const HOURS = [];
        MONTHS.forEach(m => {
            Array.from({ length: 24 }, (_, i) => HOURS.push(`${m} ${i}:00`));
        });

        const countryGridMixData = {
            "California": {
                totalCapacityMW: 92323,
                peakLoadsMW: { summer: 52061, winter: 47500, fall: 46000, spring: 41000 },
                mix: { coal: 0.1, naturalGas: 43.4, hydro: 15.7, wind: 7.1, offshoreWind: 0, solar: 28.6, nuclear: 2.7, geothermal: 3.0, biomass: 1.0, rng: 0.4 },
                storageGWh: { battery4hr: 62.8 },
                defaultExportPrice: -20
            },
            "China": {
                totalCapacityMW: 3400000,
                peakLoadsMW: { summer: 1340000, winter: 1206000, fall: 1179200, spring: 1072000 },
                mix: { coal: 40.0, naturalGas: 8.0, hydro: 12.5, wind: 14.0, offshoreWind: 1.6, solar: 20.0, nuclear: 2.5, geothermal: 0.1, biomass: 0.9, rng: 0.4 },
                storageGWh: { battery4hr: 222 }
            },
            "United States": {
                totalCapacityMW: 1275000,
                peakLoadsMW: { summer: 800000, winter: 720000, fall: 704000, spring: 640000 },
                mix: { coal: 15.0, naturalGas: 48.0, hydro: 7.8, wind: 11.5, offshoreWind: 0.2, solar: 9.0, nuclear: 8.0, geothermal: 0.3, biomass: 0.8, rng: 0.4 },
                storageGWh: { battery4hr: 95 }
            },
            "India": {
                totalCapacityMW: 476000,
                peakLoadsMW: { summer: 243000, winter: 206550, fall: 213840, spring: 194400 },
                mix: { coal: 50.0, naturalGas: 6.0, hydro: 10.0, wind: 9.5, offshoreWind: 0, solar: 18.0, nuclear: 1.8, geothermal: 0.0, biomass: 1.9, rng: 0.8 },
                storageGWh: { battery4hr: 1 }
            },
            "Japan": {
                totalCapacityMW: 295000,
                peakLoadsMW: { summer: 181000, winter: 162900, fall: 159280, spring: 144800 },
                mix: { coal: 20.0, naturalGas: 35.0, hydro: 17.0, wind: 1.6, offshoreWind: 0.1, solar: 15.5, nuclear: 10.5, geothermal: 0.2, biomass: 1.1, rng: 0.5 },
                storageGWh: { battery4hr: 1.2 }
            },
            "Russia": {
                totalCapacityMW: 248000,
                peakLoadsMW: { winter: 160000, summer: 144000, fall: 140800, spring: 128000 },
                mix: { coal: 15.0, naturalGas: 52.0, hydro: 20.0, wind: 0.9, offshoreWind: 0, solar: 0.8, nuclear: 11.3, geothermal: 0.0, biomass: 0.1, rng: 0.1 }
            },
            "Brazil": {
                totalCapacityMW: 180000,
                peakLoadsMW: { summer: 101860, winter: 91674, fall: 89637, spring: 81488 },
                mix: { coal: 2.0, naturalGas: 18.0, hydro: 59.0, wind: 10.5, offshoreWind: 0, solar: 9.5, nuclear: 1.0, geothermal: 0.0, biomass: 5.6, rng: 2.4 }
            },
            "Germany": {
                totalCapacityMW: 210000,
                peakLoadsMW: { winter: 84000, summer: 75600, fall: 73920, spring: 67200 },
                mix: { coal: 14.0, naturalGas: 38.0, hydro: 4.0, wind: 22.0, offshoreWind: 4.0, solar: 12.0, nuclear: 5.0, geothermal: 0.0, biomass: 4.2, rng: 1.8 },
                storageGWh: { battery4hr: 22.1 }
            },
            "Canada": {
                totalCapacityMW: 165000,
                peakLoadsMW: { winter: 140000, summer: 126000, fall: 123200, spring: 112000 },
                mix: { coal: 4.5, naturalGas: 13.5, hydro: 57.0, wind: 8.5, offshoreWind: 0, solar: 2.5, nuclear: 14.0, geothermal: 0.0, biomass: 1.4, rng: 0.6 },
                storageGWh: { battery4hr: 1 }
            },
            "South Korea": {
                totalCapacityMW: 125000,
                peakLoadsMW: { summer: 93000, winter: 83700, fall: 81840, spring: 74400 },
                mix: { coal: 34.0, naturalGas: 20.0, hydro: 5.0, wind: 1.4, offshoreWind: 0.1, solar: 12.5, nuclear: 27.0, geothermal: 0.0, biomass: 0.7, rng: 0.3 },
                storageGWh: { battery4hr: 9 }
            },
            "France": {
                totalCapacityMW: 115000,
                peakLoadsMW: { winter: 102000, summer: 91800, fall: 89760, spring: 81600 },
                mix: { coal: 1.0, naturalGas: 10.0, hydro: 10.0, wind: 8.0, offshoreWind: 0.5, solar: 6.0, nuclear: 64.0, geothermal: 0.0, biomass: 0.3, rng: 0.1 },
                storageGWh: { battery4hr: 1.0 }
            },
            "United Kingdom": {
                totalCapacityMW: 78000,
                peakLoadsMW: { winter: 60000, summer: 54000, fall: 52800, spring: 48000 },
                mix: { coal: 1.0, naturalGas: 38.0, hydro: 2.0, wind: 15.0, offshoreWind: 14.0, solar: 19.0, nuclear: 9.0, geothermal: 0.0, biomass: 4.2, rng: 1.8 },
                storageGWh: { battery4hr: 16.0 }
            },
            "Australia": {
                totalCapacityMW: 65000,
                peakLoadsMW: { summer: 47000, winter: 42300, fall: 41360, spring: 37600 },
                mix: { coal: 45.0, naturalGas: 18.0, hydro: 13.0, wind: 10.0, offshoreWind: 0, solar: 13.0, nuclear: 0.0, geothermal: 0.0, biomass: 0.7, rng: 0.3 },
                storageGWh: { battery4hr: 5.6 }
            },
            "Spain": {
                totalCapacityMW: 120000,
                peakLoadsMW: { summer: 45000, winter: 40500, fall: 39600, spring: 36000 },
                mix: { coal: 2.0, naturalGas: 22.0, hydro: 17.0, wind: 27.5, offshoreWind: 0, solar: 21.5, nuclear: 7.0, geothermal: 0.0, biomass: 1.0, rng: 0.4 },
                storageGWh: { battery4hr: 1.7 }
            },
            "Italy": {
                totalCapacityMW: 122000,
                peakLoadsMW: { summer: 60000, winter: 54000, fall: 52800, spring: 48000 },
                mix: { coal: 4.0, naturalGas: 47.0, hydro: 18.0, wind: 10.0, offshoreWind: 0, solar: 19.0, nuclear: 0.0, geothermal: 1.0, biomass: 1.4, rng: 0.6 },
                storageGWh: { battery4hr: 6 }
            },
            "Indonesia": {
                totalCapacityMW: 75000,
                peakLoadsMW: { summer: 50000, winter: 45000, fall: 44000, spring: 40000 },
                mix: { coal: 48.0, naturalGas: 28.0, hydro: 9.0, wind: 0.2, offshoreWind: 0, solar: 2.8, nuclear: 0.0, geothermal: 3.0, biomass: 0.7, rng: 0.3 }
            },
            "South Africa": {
                totalCapacityMW: 60000,
                peakLoadsMW: { winter: 34000, summer: 30600, fall: 29920, spring: 27200 },
                mix: { coal: 78.0, naturalGas: 6.0, hydro: 6.0, wind: 5.5, offshoreWind: 0, solar: 3.5, nuclear: 0.0, geothermal: 0.0, biomass: 0.3, rng: 0.1 },
                storageGWh: { battery4hr: 2 }
            },
            "Mexico": {
                totalCapacityMW: 88000,
                peakLoadsMW: { summer: 50000, winter: 45000, fall: 44000, spring: 40000 },
                mix: { coal: 5.0, naturalGas: 58.0, hydro: 15.0, wind: 9.0, offshoreWind: 0, solar: 11.0, nuclear: 1.0, geothermal: 1.0, biomass: 0.3, rng: 0.1 },
                storageGWh: { battery4hr: 0.6 }
            },
            "Norway": {
                totalCapacityMW: 39000,
                peakLoadsMW: { winter: 25000, summer: 22500, fall: 22000, spring: 20000 },
                mix: { coal: 0.0, naturalGas: 0.0, hydro: 91.0, wind: 8.5, offshoreWind: 0, solar: 0.5, nuclear: 0.0, geothermal: 0.0, biomass: 0.0, rng: 0.0 },
                storageGWh: { battery4hr: 0.2 }
            },
            "New Zealand": {
                totalCapacityMW: 9800,
                peakLoadsMW: { winter: 7000, summer: 6300, fall: 6160, spring: 5600 },
                mix: { coal: 0.0, naturalGas: 14.0, hydro: 56.0, wind: 7.5, offshoreWind: 0, solar: 1.5, nuclear: 0.0, geothermal: 20.0, biomass: 0.7, rng: 0.3 },
                storageGWh: { battery4hr: 0.4 }
            },
            "Vietnam": {
                totalCapacityMW: 80000,
                peakLoadsMW: { summer: 45000, winter: 40500, fall: 39600, spring: 36000 },
                mix: { coal: 32.0, naturalGas: 9.0, hydro: 28.0, wind: 6.0, offshoreWind: 0, solar: 24.0, nuclear: 0.0, geothermal: 0.0, biomass: 0.7, rng: 0.3 },
                storageGWh: { battery4hr: 0.1 }
            }
        };

        const carbonTaxes = {
            "California": 26, "Canada": 61, "China": 8, "France": 48, "Germany": 43, "Japan": 2,
            "South Korea": 22, "Spain": 16, "United Kingdom": 22, "South Africa": 9,
            "Mexico": 3, "Norway": 85, "New Zealand": 50
        };

        // High-demand seasonal profiles (used for non-California countries)
        const SEASONAL_DEMAND_PROFILES = {
            'spring-high': [28, 26, 25, 24, 24, 25, 28, 32, 33, 32, 30, 28, 27, 28, 30, 34, 39, 45, 48, 46, 42, 38, 34, 30],
            'summer-high': [30, 28, 27, 26, 26, 27, 29, 33, 37, 40, 42, 44, 46, 48, 50, 52, 55, 56, 55, 52, 48, 43, 38, 33],
            'fall-high': [27, 25, 24, 23, 23, 24, 27, 31, 34, 36, 37, 38, 39, 40, 41, 43, 46, 50, 49, 46, 42, 37, 32, 29],
            'winter-high': [32, 30, 29, 29, 30, 34, 40, 45, 44, 42, 40, 39, 39, 40, 41, 43, 45, 46, 45, 42, 39, 36, 34, 32],
            // Typical profiles (scaled from high profiles)
            'spring-typical': [28, 26, 25, 24, 24, 25, 28, 32, 33, 32, 30, 28, 27, 28, 30, 34, 39, 45, 48, 46, 42, 38, 34, 30].map(v => v * 0.79),
            'summer-typical': [30, 28, 27, 26, 26, 27, 29, 33, 37, 40, 42, 44, 46, 48, 50, 52, 55, 56, 55, 52, 48, 43, 38, 33].map(v => v * 0.82),
            'fall-typical': [27, 25, 24, 23, 23, 24, 27, 31, 34, 36, 37, 38, 39, 40, 41, 43, 46, 50, 49, 46, 42, 37, 32, 29].map(v => v * 0.77),
            'winter-typical': [32, 30, 29, 29, 30, 34, 40, 45, 44, 42, 40, 39, 39, 40, 41, 43, 45, 46, 45, 42, 39, 36, 34, 32].map(v => v * 0.73)
        };

        // California profiles loaded from JSON (populated during initialization)
        let CALIFORNIA_PROFILES = {};

        // This object will hold the calculated POTENTIAL generation, not a pre-dispatched baseline.
        let BASELINE_POTENTIAL_GENERATION = {};
        let currentCountryInstalledCapacity = {};
        let currentBaselineStorage = {};
        let yearlyGenerationTotalsGWh = {}; // For tooltips
        let latestGenerationData = null; // Store latest generation for CSV export

        const SOLAR_CF_PROFILE = [0, 0, 0, 0, 0, 0.05, 0.15, 0.3, 0.5, 0.7, 0.8, 0.85, 0.9, 0.85, 0.8, 0.7, 0.3, 0.05, 0, 0, 0, 0, 0, 0];
        const WIND_CF_PROFILE = [0.4, 0.42, 0.45, 0.46, 0.45, 0.4, 0.35, 0.3, 0.25, 0.2, 0.2, 0.2, 0.25, 0.3, 0.35, 0.4, 0.5, 0.6, 0.65, 0.6, 0.55, 0.5, 0.45, 0.4];
        const OFFSHORE_WIND_CF_PROFILE = [0.55, 0.56, 0.57, 0.58, 0.58, 0.57, 0.55, 0.52, 0.5, 0.48, 0.47, 0.46, 0.47, 0.48, 0.5, 0.52, 0.55, 0.6, 0.62, 0.61, 0.6, 0.58, 0.57, 0.56];

        const SEASONAL_HYDRO_CF = {
            spring: 0.50,
            summer: 0.30,
            fall: 0.25,
            winter: 0.35
        };

        // California monthly VRE profiles (CAISO 2025 Assessment-derived)
        // 12 months Ã— 24 hours - complete hourly profiles with realistic diurnal variation
        const CALIFORNIA_MONTHLY_PROFILES = {
            solar: [
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.208, 0.486, 0.578, 0.486, 0.208, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  // Jan
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.126, 0.508, 0.699, 0.699, 0.508, 0.126, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  // Feb
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.34, 0.656, 0.813, 0.813, 0.656, 0.34, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  // Mar
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.242, 0.613, 0.837, 0.911, 0.837, 0.613, 0.242, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  // Apr
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.428, 0.733, 0.917, 0.978, 0.917, 0.733, 0.428, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  // May
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.438, 0.75, 0.938, 1.0, 0.938, 0.75, 0.438, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  // Jun
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.126, 0.543, 0.821, 0.96, 0.96, 0.821, 0.543, 0.126, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  // Jul
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.242, 0.613, 0.837, 0.911, 0.837, 0.613, 0.242, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  // Aug
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.463, 0.741, 0.833, 0.741, 0.463, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  // Sep
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.126, 0.508, 0.699, 0.699, 0.508, 0.126, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  // Oct
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.467, 0.556, 0.467, 0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  // Nov
                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.278, 0.476, 0.476, 0.278, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  // Dec
            ],
            wind: [
                [0.114, 0.104, 0.095, 0.095, 0.095, 0.095, 0.104, 0.114, 0.133, 0.152, 0.171, 0.19, 0.208, 0.228, 0.247, 0.284, 0.303, 0.284, 0.266, 0.266, 0.228, 0.19, 0.152, 0.133],  // Jan
                [0.147, 0.135, 0.123, 0.123, 0.123, 0.123, 0.135, 0.147, 0.172, 0.197, 0.221, 0.246, 0.27, 0.295, 0.319, 0.369, 0.393, 0.369, 0.344, 0.344, 0.295, 0.246, 0.197, 0.172],  // Feb
                [0.215, 0.197, 0.178, 0.178, 0.178, 0.178, 0.197, 0.215, 0.25, 0.285, 0.322, 0.357, 0.393, 0.428, 0.465, 0.535, 0.572, 0.535, 0.5, 0.5, 0.428, 0.357, 0.285, 0.25],  // Mar
                [0.295, 0.27, 0.246, 0.246, 0.246, 0.246, 0.27, 0.295, 0.344, 0.393, 0.442, 0.491, 0.541, 0.59, 0.639, 0.736, 0.785, 0.736, 0.688, 0.688, 0.59, 0.491, 0.393, 0.344],  // Apr
                [0.342, 0.314, 0.284, 0.284, 0.284, 0.284, 0.314, 0.342, 0.399, 0.455, 0.513, 0.569, 0.626, 0.683, 0.74, 0.854, 0.91, 0.854, 0.797, 0.797, 0.683, 0.569, 0.455, 0.399],  // May
                [0.375, 0.344, 0.312, 0.312, 0.312, 0.312, 0.344, 0.375, 0.438, 0.5, 0.563, 0.625, 0.688, 0.75, 0.813, 0.938, 1.0, 0.938, 0.875, 0.875, 0.75, 0.625, 0.5, 0.438],  // Jun
                [0.295, 0.27, 0.246, 0.246, 0.246, 0.246, 0.27, 0.295, 0.344, 0.393, 0.442, 0.491, 0.541, 0.59, 0.639, 0.736, 0.785, 0.736, 0.688, 0.688, 0.59, 0.491, 0.393, 0.344],  // Jul
                [0.248, 0.227, 0.206, 0.206, 0.206, 0.206, 0.227, 0.248, 0.29, 0.33, 0.372, 0.413, 0.454, 0.496, 0.536, 0.62, 0.66, 0.62, 0.578, 0.578, 0.496, 0.413, 0.33, 0.29],  // Aug
                [0.234, 0.215, 0.196, 0.196, 0.196, 0.196, 0.215, 0.234, 0.273, 0.312, 0.352, 0.391, 0.43, 0.469, 0.508, 0.585, 0.625, 0.585, 0.547, 0.547, 0.469, 0.391, 0.312, 0.273],  // Sep
                [0.147, 0.135, 0.123, 0.123, 0.123, 0.123, 0.135, 0.147, 0.172, 0.197, 0.221, 0.246, 0.27, 0.295, 0.319, 0.369, 0.393, 0.369, 0.344, 0.344, 0.295, 0.246, 0.197, 0.172],  // Oct
                [0.114, 0.104, 0.095, 0.095, 0.095, 0.095, 0.104, 0.114, 0.133, 0.152, 0.171, 0.19, 0.208, 0.228, 0.247, 0.284, 0.303, 0.284, 0.266, 0.266, 0.228, 0.19, 0.152, 0.133],  // Nov
                [0.107, 0.098, 0.09, 0.09, 0.09, 0.09, 0.098, 0.107, 0.125, 0.143, 0.16, 0.178, 0.197, 0.215, 0.232, 0.268, 0.285, 0.268, 0.25, 0.25, 0.215, 0.178, 0.143, 0.125],  // Dec
            ],
            offshoreWind: [
                [0.188, 0.18, 0.169, 0.163, 0.163, 0.169, 0.18, 0.202, 0.23, 0.263, 0.295, 0.328, 0.36, 0.393, 0.437, 0.48, 0.502, 0.491, 0.469, 0.437, 0.393, 0.328, 0.274, 0.246],  // Jan
                [0.243, 0.234, 0.22, 0.212, 0.212, 0.22, 0.234, 0.261, 0.296, 0.339, 0.382, 0.423, 0.466, 0.508, 0.566, 0.621, 0.65, 0.636, 0.607, 0.566, 0.509, 0.425, 0.354, 0.318],  // Feb
                [0.3, 0.288, 0.27, 0.26, 0.26, 0.27, 0.288, 0.322, 0.365, 0.418, 0.47, 0.521, 0.574, 0.625, 0.696, 0.765, 0.799, 0.783, 0.747, 0.696, 0.625, 0.521, 0.434, 0.391],  // Mar
                [0.375, 0.358, 0.337, 0.326, 0.326, 0.337, 0.358, 0.402, 0.456, 0.521, 0.586, 0.651, 0.718, 0.783, 0.87, 0.956, 1.0, 0.978, 0.935, 0.87, 0.783, 0.651, 0.544, 0.49],  // Apr
                [0.349, 0.333, 0.313, 0.302, 0.302, 0.313, 0.333, 0.373, 0.423, 0.484, 0.544, 0.604, 0.665, 0.726, 0.806, 0.887, 0.927, 0.907, 0.867, 0.806, 0.726, 0.604, 0.503, 0.454],  // May
                [0.333, 0.32, 0.3, 0.29, 0.29, 0.3, 0.32, 0.358, 0.407, 0.465, 0.523, 0.581, 0.639, 0.697, 0.775, 0.852, 0.891, 0.871, 0.833, 0.775, 0.697, 0.581, 0.484, 0.436],  // Jun
                [0.3, 0.286, 0.27, 0.261, 0.261, 0.27, 0.286, 0.322, 0.365, 0.418, 0.469, 0.521, 0.574, 0.627, 0.696, 0.765, 0.799, 0.783, 0.748, 0.696, 0.627, 0.521, 0.434, 0.391],  // Jul
                [0.284, 0.271, 0.254, 0.246, 0.246, 0.254, 0.271, 0.304, 0.346, 0.396, 0.444, 0.494, 0.542, 0.592, 0.658, 0.723, 0.757, 0.74, 0.707, 0.658, 0.592, 0.494, 0.411, 0.371],  // Aug
                [0.268, 0.257, 0.242, 0.234, 0.234, 0.242, 0.257, 0.288, 0.326, 0.373, 0.42, 0.467, 0.513, 0.56, 0.622, 0.685, 0.715, 0.7, 0.669, 0.622, 0.56, 0.467, 0.389, 0.35],  // Sep
                [0.188, 0.18, 0.169, 0.163, 0.163, 0.169, 0.18, 0.201, 0.228, 0.261, 0.293, 0.326, 0.358, 0.391, 0.434, 0.479, 0.501, 0.49, 0.467, 0.434, 0.391, 0.326, 0.272, 0.245],  // Oct
                [0.173, 0.166, 0.156, 0.151, 0.151, 0.156, 0.166, 0.187, 0.212, 0.242, 0.272, 0.302, 0.332, 0.362, 0.404, 0.443, 0.463, 0.454, 0.433, 0.404, 0.362, 0.303, 0.252, 0.227],  // Nov
                [0.163, 0.156, 0.147, 0.142, 0.142, 0.147, 0.156, 0.176, 0.199, 0.227, 0.256, 0.285, 0.313, 0.342, 0.379, 0.418, 0.436, 0.426, 0.408, 0.379, 0.342, 0.285, 0.237, 0.213],  // Dec
            ]
        };

        // California monthly demand profiles (CAISO-derived realistic patterns)
        // 12 months Ã— 24 hours - complete hourly demand profiles in GW
        // Subtle midday plateau/softness (1-2 GW dip) before evening peak
        // Peaks: Feb ~30 GW (lowest), Aug ~45 GW (highest), Mar-May ~33-34 GW
        const CALIFORNIA_MONTHLY_DEMAND = [
            [20.6, 20.2, 19.8, 19.5, 19.3, 19.9, 22.0, 24.5, 26.3, 26.8, 26.6, 26.4, 26.1, 26.5, 27.1, 28.1, 29.1, 29.5, 29.0, 27.1, 25.1, 23.7, 22.6, 21.0],  // Jan: Peak 29.5 GW
            [19.4, 18.9, 18.6, 18.4, 18.2, 18.7, 20.7, 23.1, 24.7, 25.2, 25.0, 24.7, 24.4, 24.8, 25.5, 26.6, 27.3, 28.0, 27.4, 25.6, 23.8, 22.5, 21.6, 19.6],  // Feb: Peak 28.0 GW
            [17.5, 17.1, 16.8, 16.6, 16.3, 16.9, 18.8, 21.1, 22.8, 23.6, 23.3, 23.0, 22.7, 23.2, 23.8, 25.1, 26.0, 27.0, 26.7, 25.3, 23.6, 22.1, 20.6, 19.2],  // Mar: Peak 27.0 GW
            [17.7, 17.3, 16.9, 16.7, 16.4, 17.1, 19.0, 21.4, 23.2, 24.0, 23.7, 23.3, 23.1, 23.5, 24.2, 25.1, 25.9, 26.5, 26.2, 25.0, 23.5, 22.0, 20.6, 19.8],  // Apr: Peak 26.5 GW
            [18.9, 18.4, 18.0, 17.7, 17.5, 18.2, 20.6, 23.4, 25.5, 26.5, 26.1, 25.5, 25.1, 25.9, 26.7, 28.4, 29.7, 31.0, 30.7, 29.4, 27.8, 26.2, 24.6, 24.0],  // May: Peak 31.0 GW
            [23.4, 22.7, 22.3, 21.9, 21.7, 22.7, 25.7, 29.2, 31.9, 33.3, 32.9, 32.3, 31.7, 32.7, 34.1, 36.2, 37.6, 38.5, 38.1, 36.6, 34.6, 32.7, 30.3, 28.8],  // Jun: Peak 38.5 GW
            [27.3, 26.5, 25.9, 25.5, 25.3, 26.7, 30.3, 34.7, 38.1, 39.9, 39.5, 38.6, 37.9, 39.0, 40.9, 43.0, 44.4, 45.0, 44.5, 42.6, 40.4, 38.1, 35.5, 31.9],  // Jul: Peak 45.0 GW
            [28.3, 27.5, 26.8, 26.5, 26.2, 27.7, 31.5, 36.0, 39.8, 41.8, 41.3, 40.4, 39.4, 40.7, 42.8, 44.8, 46.2, 46.5, 46.2, 44.3, 42.1, 39.8, 36.8, 33.0],  // Aug: Peak 46.5 GW
            [29.2, 28.3, 27.6, 27.1, 26.9, 28.3, 32.0, 36.3, 39.6, 41.2, 40.7, 39.9, 39.0, 40.4, 41.7, 43.7, 45.2, 46.0, 45.4, 43.2, 40.7, 38.4, 36.0, 28.9],  // Sep: Peak 46.0 GW
            [21.8, 21.2, 20.7, 20.3, 20.1, 21.0, 23.6, 26.4, 28.8, 30.0, 29.6, 29.0, 28.5, 29.2, 30.2, 31.9, 33.4, 34.5, 33.9, 32.4, 30.4, 28.5, 26.9, 23.5],  // Oct: Peak 34.5 GW
            [20.0, 19.5, 19.0, 18.8, 18.5, 19.5, 21.7, 24.3, 26.3, 27.0, 26.8, 26.3, 25.9, 26.4, 27.2, 28.1, 28.6, 29.0, 28.6, 27.0, 25.3, 23.8, 22.1, 21.3],  // Nov: Peak 29.0 GW
            [20.5, 20.0, 19.7, 19.4, 19.1, 20.0, 22.1, 24.5, 26.6, 27.2, 27.0, 26.6, 26.1, 26.8, 27.7, 29.0, 29.5, 30.0, 29.5, 27.9, 25.9, 24.5, 22.8, 21.8],  // Dec: Peak 30.0 GW (unchanged - wraps to Jan)
        ];

        // Multipliers for non-California countries (generic pattern: solar summer-high, wind winter-high)
        const MONTHLY_MULTIPLIERS_DEFAULT = [
            { solar: 0.60, wind: 1.15, offshoreWind: 1.15 }, { solar: 0.70, wind: 1.10, offshoreWind: 1.10 },
            { solar: 0.85, wind: 1.05, offshoreWind: 1.05 }, { solar: 0.95, wind: 0.95, offshoreWind: 1.00 },
            { solar: 1.05, wind: 0.90, offshoreWind: 0.95 }, { solar: 1.15, wind: 0.85, offshoreWind: 0.90 },
            { solar: 1.15, wind: 0.80, offshoreWind: 0.85 }, { solar: 1.10, wind: 0.80, offshoreWind: 0.85 },
            { solar: 0.95, wind: 0.85, offshoreWind: 0.90 }, { solar: 0.80, wind: 0.95, offshoreWind: 1.00 },
            { solar: 0.65, wind: 1.10, offshoreWind: 1.10 }, { solar: 0.55, wind: 1.15, offshoreWind: 1.15 },
        ];
        function getMonthlyProfiles(country) {
            if (country === "California") {
                return CALIFORNIA_MONTHLY_PROFILES;
            }
            // For other countries, build 12Ã—24 profiles from base + multipliers
            const baseProfiles = countryProfiles[country] || countryProfiles["default"];
            const result = { solar: [], wind: [], offshoreWind: [] };
            for (let m = 0; m < 12; m++) {
                const mults = MONTHLY_MULTIPLIERS_DEFAULT[m];
                result.solar.push(baseProfiles.solar.map(cf => Math.min(1, cf * mults.solar)));
                result.wind.push(baseProfiles.wind.map(cf => Math.min(1, cf * mults.wind)));
                result.offshoreWind.push(baseProfiles.offshoreWind.map(cf => Math.min(1, cf * mults.offshoreWind)));
            }
            return result;
        }

        function getMonthlyDemand(country) {
            if (country === "California") {
                return CALIFORNIA_MONTHLY_DEMAND;
            }
            // For other countries, build 12Ã—24 demand from seasonal base + monthly multipliers
            // This preserves backward compatibility for non-California regions
            const result = [];
            const seasonOrder = ['winter', 'winter', 'spring', 'spring', 'spring', 'summer', 'summer', 'summer', 'summer', 'fall', 'fall', 'winter'];
            for (let m = 0; m < 12; m++) {
                const season = seasonOrder[m];
                // Use 'high' profiles as default base
                const baseDemand = SEASONAL_DEMAND_PROFILES[`${season}-high`] || SEASONAL_DEMAND_PROFILES['spring-high'];
                const multiplier = MONTHLY_DEMAND_MULTIPLIERS[m];
                result.push(baseDemand.map(d => d * multiplier));
            }
            return result;
        }

        // Monthly demand multipliers applied to seasonal base demand profiles (for non-California countries)
        // Derived from CAISO monthly average load patterns relative to seasonal averages
        const MONTHLY_DEMAND_MULTIPLIERS = [
            0.97,  // Jan (winter) - cold, moderate heating demand
            0.94,  // Feb (winter) - mildest winter month
            1.00,  // Mar (spring) - transitioning from winter
            0.96,  // Apr (spring) - mild, lowest demand period
            1.04,  // May (spring) - warming, early AC usage
            0.92,  // Jun (summer) - early summer, not peak heat yet
            1.08,  // Jul (summer) - peak summer heat
            1.11,  // Aug (summer) - often hottest month
            1.05,  // Sep (summer) - late summer, still warm
            1.04,  // Oct (fall)   - can still be warm (Santa Ana winds)
            0.97,  // Nov (fall)   - cooling down
            0.97,  // Dec (winter) - cold, holiday period
        ];
        const countryProfiles = {
            "California": { // Using default CA profile
                solar: SOLAR_CF_PROFILE,
                wind: WIND_CF_PROFILE,
                offshoreWind: OFFSHORE_WIND_CF_PROFILE
            },
            "Germany": {
                solar: [0, 0, 0, 0, 0, 0.02, 0.1, 0.25, 0.45, 0.6, 0.7, 0.75, 0.7, 0.6, 0.4, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0],
                wind: [0.5, 0.52, 0.55, 0.56, 0.55, 0.5, 0.45, 0.4, 0.35, 0.3, 0.3, 0.3, 0.35, 0.4, 0.45, 0.5, 0.6, 0.7, 0.75, 0.7, 0.65, 0.6, 0.55, 0.5],
                offshoreWind: [0.6, 0.62, 0.65, 0.66, 0.65, 0.6, 0.55, 0.5, 0.45, 0.4, 0.4, 0.4, 0.45, 0.5, 0.55, 0.6, 0.7, 0.8, 0.85, 0.8, 0.75, 0.7, 0.65, 0.6]
            },
            "United Kingdom": {
                solar: [0, 0, 0, 0, 0, 0.01, 0.08, 0.2, 0.4, 0.55, 0.65, 0.7, 0.65, 0.55, 0.35, 0.1, 0.02, 0, 0, 0, 0, 0, 0, 0],
                wind: [0.6, 0.62, 0.65, 0.68, 0.66, 0.6, 0.55, 0.5, 0.45, 0.4, 0.4, 0.4, 0.45, 0.5, 0.55, 0.6, 0.7, 0.8, 0.85, 0.8, 0.75, 0.7, 0.65, 0.6],
                offshoreWind: [0.7, 0.72, 0.75, 0.78, 0.76, 0.7, 0.65, 0.6, 0.55, 0.5, 0.5, 0.5, 0.55, 0.6, 0.65, 0.7, 0.8, 0.9, 0.95, 0.9, 0.85, 0.8, 0.75, 0.7]
            },
            "Australia": {
                solar: [0, 0, 0, 0, 0, 0.08, 0.2, 0.4, 0.6, 0.8, 0.9, 0.95, 0.9, 0.8, 0.6, 0.3, 0.1, 0, 0, 0, 0, 0, 0, 0],
                wind: [0.3, 0.3, 0.3, 0.25, 0.2, 0.2, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.45, 0.4, 0.35, 0.3, 0.3, 0.3, 0.35, 0.4, 0.4, 0.35, 0.3],
                offshoreWind: [0.4, 0.4, 0.4, 0.35, 0.3, 0.3, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.55, 0.5, 0.45, 0.4, 0.4, 0.4, 0.45, 0.5, 0.5, 0.45, 0.4]
            },
            "default": {
                solar: SOLAR_CF_PROFILE,
                wind: WIND_CF_PROFILE,
                offshoreWind: OFFSHORE_WIND_CF_PROFILE
            }
        };
        const EMISSION_FACTORS = { naturalGas: 395, hydro: 0, nuclear: 0, solar: 0, wind: 0, offshoreWind: 0, geothermal: 0, coal: 850, biomass: 0, rng: 0, hydrogen: 0 };

        const DEFAULT_COST_DATA = {
            capex: {
                solar: 800, wind: 1200, offshoreWind: 5000, nuclear: 7242, geothermal: 3329, biomass: 3500, rng: 3000, hydrogen: 3500,
                naturalGas: 1300, hydro: 3336, coal: 4407,
                battery4hr: 350, battery8hr: 300, longduration: 300, // $/kWh
                dac: 1000 // $/ton/year
            },
            fixed_om: {
                solar: 15, wind: 35, offshoreWind: 100, nuclear: 140, geothermal: 120, biomass: 100, rng: 95, hydrogen: 90, // $/kW-year
                naturalGas: 20, hydro: 20, coal: 40,
                battery4hr: 15, battery8hr: 15, longduration: 60, // $/kW-year
                dac: 20 // $/ton/year
            },
            variable_om: {
                solar: 0, wind: 1, offshoreWind: 0, nuclear: 10, geothermal: 5, biomass: 10, rng: 50, hydrogen: 410, // $/MWh - includes green H2 fuel cost (~$6/kg at 45% efficiency)
                naturalGasCCGT: { start: 35, end: 80 }, // NEW: $/MWh
                naturalGasCT: { start: 100, end: 150 }, // NEW: $/MWh
                hydro: 5, coal: 30, // $/MWh
                battery4hr: 0, battery8hr: 2, longduration: 1,
                dac: 400, // $/ton
                storage: 30 // $/MWh - an assumed opportunity cost for dispatching storage
            },
            lifetime: {
                solar: 30, wind: 30, offshoreWind: 30, nuclear: 60, geothermal: 30, biomass: 25, rng: 25, hydrogen: 30,
                naturalGas: 30, hydro: 80, coal: 40,
                battery4hr: 15, battery8hr: 15, longduration: 25, dac: 25
            },
            capacity_factor: {
                solar: 0.25, wind: 0.35, offshoreWind: 0.50, nuclear: 0.9, geothermal: 0.9, biomass: 0.85, rng: 0.85, hydrogen: 0.20,
                naturalGas: 0.55, hydro: 0.45, coal: 0.6
            },
            discount_rate: 0.07
        };

        // Initialize mutable cost data for the session
        let COST_DATA = JSON.parse(JSON.stringify(DEFAULT_COST_DATA));

        // Supply curves: CAPEX increases with deployment for resource-constrained technologies
        // Each step defines capacity threshold (GW) and cost multiplier relative to base CAPEX
        const SUPPLY_CURVES = {
            geothermal: [
                { upToGW: 2, multiplier: 1.0 },   // Best hydrothermal sites
                { upToGW: 4, multiplier: 1.3 },   // Good sites, higher drilling costs
                { upToGW: 5, multiplier: 1.6 }    // Marginal sites, enhanced geothermal
            ],
            biomass: [
                { upToGW: 1.5, multiplier: 1.0 }, // Cheapest feedstock (waste, residues)
                { upToGW: 3.0, multiplier: 1.4 }  // Dedicated energy crops, longer transport
            ]
        };

        // Get blended (average) CAPEX for a technology at a given total capacity
        // Used for total system cost calculations
        function getBlendedCapex(tech, totalCapacityGW) {
            const curve = SUPPLY_CURVES[tech];
            if (!curve || totalCapacityGW <= 0) return COST_DATA.capex[tech];

            const baseCapex = COST_DATA.capex[tech];
            let totalCost = 0;
            let remainingGW = totalCapacityGW;
            let prevThreshold = 0;

            for (const step of curve) {
                const bandWidth = step.upToGW - prevThreshold;
                const gwInBand = Math.min(remainingGW, bandWidth);
                if (gwInBand <= 0) break;

                totalCost += gwInBand * baseCapex * step.multiplier;
                remainingGW -= gwInBand;
                prevThreshold = step.upToGW;
            }

            // Any capacity beyond the last step uses the last multiplier
            if (remainingGW > 0) {
                const lastMultiplier = curve[curve.length - 1].multiplier;
                totalCost += remainingGW * baseCapex * lastMultiplier;
            }

            return totalCost / totalCapacityGW; // weighted average $/kW
        }

        // Get marginal CAPEX for the next unit of capacity at current deployment level
        // Used for LCOE-guided technology selection in the optimizer
        function getMarginalCapex(tech, currentCapacityGW) {
            const curve = SUPPLY_CURVES[tech];
            if (!curve) return COST_DATA.capex[tech];

            const baseCapex = COST_DATA.capex[tech];
            for (const step of curve) {
                if (currentCapacityGW < step.upToGW) {
                    return baseCapex * step.multiplier;
                }
            }
            // Beyond last step: use last multiplier
            return baseCapex * curve[curve.length - 1].multiplier;
        }

        document.addEventListener('DOMContentLoaded', async function () {
            setLogLevel('debug');

            // --- DOM ELEMENTS ---
            const sliders = {
                solar: document.getElementById('solar-slider'), wind: document.getElementById('wind-slider'), offshoreWind: document.getElementById('offshoreWind-slider'),
                geothermal: document.getElementById('geothermal-slider'), nuclear: document.getElementById('nuclear-slider'),
                biomass: document.getElementById('biomass-slider'), rng: document.getElementById("rng-slider"), hydrogen: document.getElementById("hydrogen-slider"),
                battery4hr: document.getElementById('battery4hr-slider'), battery8hr: document.getElementById('battery8hr-slider'),
                longduration: document.getElementById('longduration-slider'), demandflex: document.getElementById('demandflex-slider'),
                dac: document.getElementById('dac-slider'), solarIncentive: document.getElementById('solar-incentive-slider'),
                windIncentive: document.getElementById('wind-incentive-slider'), offshoreWindIncentive: document.getElementById('offshoreWind-incentive-slider'),
                geothermalIncentive: document.getElementById('geothermal-incentive-slider'),
                nuclearIncentive: document.getElementById('nuclear-incentive-slider'), biomassIncentive: document.getElementById('biomass-incentive-slider'),
                rngIncentive: document.getElementById("rng-incentive-slider"), hydrogenIncentive: document.getElementById("hydrogen-incentive-slider"),
                storageIncentive: document.getElementById('storage-incentive-slider'),
                dacIncentive: document.getElementById('dac-incentive-slider'), carbonTax: document.getElementById('carbon-tax-slider'),
                exportPrice: document.getElementById('export-price-slider'),
            };
            const inputs = {
                solar: document.getElementById('solar-input'), wind: document.getElementById('wind-input'), offshoreWind: document.getElementById('offshoreWind-input'),
                geothermal: document.getElementById('geothermal-input'), nuclear: document.getElementById('nuclear-input'),
                biomass: document.getElementById('biomass-input'), rng: document.getElementById("rng-input"), hydrogen: document.getElementById("hydrogen-input"),
                battery4hr: document.getElementById('battery4hr-input'), battery8hr: document.getElementById('battery8hr-input'),
                longduration: document.getElementById('longduration-input'), demandflex: document.getElementById('demandflex-input'),
                dac: document.getElementById('dac-input'), solarIncentive: document.getElementById('solar-incentive-input'),
                windIncentive: document.getElementById('wind-incentive-input'), offshoreWindIncentive: document.getElementById('offshoreWind-incentive-input'),
                geothermalIncentive: document.getElementById('geothermal-incentive-input'),
                nuclearIncentive: document.getElementById('nuclear-incentive-input'), biomassIncentive: document.getElementById('biomass-incentive-input'),
                rngIncentive: document.getElementById("rng-incentive-input"), hydrogenIncentive: document.getElementById("hydrogen-incentive-input"),
                storageIncentive: document.getElementById('storage-incentive-input'),
                dacIncentive: document.getElementById('dac-incentive-input'), carbonTax: document.getElementById('carbon-tax-input'),
                exportPrice: document.getElementById('export-price-input'),
            };

            const billImpactEl = document.getElementById('bill-impact');
            const systemCostImpactEl = document.getElementById('system-cost-impact');
            const co2AvoidedEl = document.getElementById('co2-avoided-text');
            const resetToZeroButton = document.getElementById('reset-to-zero-button');
            const makeDefaultButton = document.getElementById('make-default-button');
            const resetToDefaultButton = document.getElementById('reset-to-default-button');
            const undoButton = document.getElementById('undo-button');
            const redoButton = document.getElementById('redo-button');
            const gridMixSlidersContainer = document.getElementById('grid-mix-sliders');
            const storageCapacityDisplayContainer = document.getElementById('storage-capacity-display');
            const generationMixSlidersContainer = document.getElementById('generation-mix-sliders');
            const countrySelect = document.getElementById('country-select');
            const hoverTooltip = document.getElementById('hover-tooltip');
            const startTutorialBtn = document.getElementById('start-tutorial-btn');

            const currentDemandProfileText = document.getElementById('current-demand-profile-text');
            const editDemandBtn = document.getElementById('edit-demand-btn');
            const confirmDemandBtn = document.getElementById('confirm-demand-btn');
            const revertDemandBtn = document.getElementById('revert-demand-btn');
            const demandPresetsDiv = document.getElementById('demand-presets');

            const editCFBtn = document.getElementById('edit-cf-btn');
            const confirmCFBtn = document.getElementById('confirm-cf-btn');
            const revertCFBtn = document.getElementById('revert-cf-btn');
            const visitorCountEl = document.getElementById('visitor-count');


            // --- STATE MANAGEMENT ---
            let stateHistory = [];
            let historyIndex = -1;
            let userDefaultState = {};
            let systemDefaultState = {};
            let customBaselineSystemCost = 0;
            let customBaselineConsumerCost = 0; // NEW
            let customBaselineTotalAnnualCO2 = 0;
            let enabledTechnologies = {};
            let defaultCapacityMix = {};
            let defaultGenerationMix = {};
            let currentSystemDefaultProfileName = 'monthly-default'; // Using monthly profiles instead of seasonal presets

            let isDemandEditMode = false;
            let currentDemand = []; // Will be set by initializeWithMonthlyProfiles()
            let originalDemandBeforeEdit = [];
            let currentDemandProfileName = 'Monthly Profiles';

            let isCFEditMode = false;
            let currentSolarCFProfile = [];
            let currentWindCFProfile = [];
            let currentOffshoreWindCFProfile = [];
            let currentHydroCF = 0.35; // Average hydro CF - will be used with seasonal variation
            let originalSolarCFBeforeEdit = [];
            let originalWindCFBeforeEdit = [];
            let originalOffshoreWindCFBeforeEdit = [];
            let currentCFProfileName = 'Spring';

            // Full profiles for optimization (288 hours)
            let fullSolarProfile = [];
            let fullWindProfile = [];
            let fullOffshoreWindProfile = [];
            let activePotentialGeneration = {};
            let currentBaselineStorage = {};

            // Optimization context (set before running optimization)
            let optimizationContext = null;

            // --- CHARTING SETUP ---
            const generationCtx = document.getElementById('generationMixChart').getContext('2d');
            const marginalPriceCtx = document.getElementById('marginalPriceChart').getContext('2d'); // NEW
            const co2Ctx = document.getElementById('co2EmissionsChart').getContext('2d');
            const capacityFactorCtx = document.getElementById('capacityFactorChart').getContext('2d');

            const COLORS = {
                naturalGas: 'rgba(156, 163, 175, 0.9)', hydro: 'rgba(59, 130, 246, 0.8)',
                nuclear: 'rgba(239, 68, 68, 0.8)', solar: 'rgba(251, 191, 36, 1)',
                wind: 'rgba(52, 211, 153, 0.8)', /* CHANGE: Lighter green for Onshore Wind */
                offshoreWind: 'rgba(12, 148, 103, 0.8)',
                geothermal: 'rgba(120, 40, 40, 0.8)',
                biomass: 'rgba(101, 67, 33, 0.8)',
                rng: 'rgba(132, 204, 22, 0.8)',
                hydrogen: 'rgba(219, 39, 119, 0.8)', /* Pink/magenta for hydrogen */
                storage: 'rgba(168, 85, 247, 0.8)', demand: 'rgba(17, 24, 39, 1)',
                curtailment: 'rgba(253, 186, 116, 0.8)', coal: 'rgba(0, 0, 0, 0.8)',
                price: 'rgba(79, 70, 229, 1)' // NEW for price chart
            };

            // Helper function to create a patterned fill for "to Storage" generation
            function createPattern(baseColor, patternColor) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 10;
                canvas.height = 10;
                ctx.fillStyle = baseColor;
                ctx.fillRect(0, 0, 10, 10);
                ctx.strokeStyle = patternColor;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 10);
                ctx.lineTo(10, 0);
                ctx.moveTo(-1, 1);
                ctx.lineTo(1, -1);
                ctx.moveTo(9, 11);
                ctx.lineTo(11, 9);
                ctx.stroke();
                return ctx.createPattern(canvas, 'repeat');
            }

            const PATTERNS = {
                solarToStorage: createPattern(COLORS.solar, 'rgba(168, 85, 247, 0.7)'),
                windToStorage: createPattern(COLORS.wind, 'rgba(168, 85, 247, 0.7)'),
                offshoreWindToStorage: createPattern(COLORS.offshoreWind, 'rgba(168, 85, 247, 0.7)'),
                hydroToStorage: createPattern(COLORS.hydro, COLORS.storage),
                geothermalToStorage: createPattern(COLORS.geothermal, COLORS.storage),
                nuclearToStorage: createPattern(COLORS.nuclear, COLORS.storage),
                coalToStorage: createPattern(COLORS.coal, COLORS.storage),
                naturalGasToStorage: createPattern(COLORS.naturalGas, COLORS.storage),
                biomassToStorage: createPattern(COLORS.biomass, COLORS.storage),
            };

            const generationChartConfig = {
                type: 'line',
                data: {
                    labels: HOURS,
                    datasets: [
                        { label: 'Nuclear', data: [], backgroundColor: COLORS.nuclear, borderColor: COLORS.nuclear, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Geothermal', data: [], backgroundColor: COLORS.geothermal, borderColor: COLORS.geothermal, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Biomass', data: [], backgroundColor: COLORS.biomass, borderColor: COLORS.biomass, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'RNG (Biogas)', data: [], backgroundColor: COLORS.rng, borderColor: COLORS.rng, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Hydrogen', data: [], backgroundColor: COLORS.hydrogen, borderColor: COLORS.hydrogen, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Hydro', data: [], backgroundColor: COLORS.hydro, borderColor: COLORS.hydro, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Onshore Wind', data: [], backgroundColor: COLORS.wind, borderColor: COLORS.wind, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Offshore Wind', data: [], backgroundColor: COLORS.offshoreWind, borderColor: COLORS.offshoreWind, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Solar', data: [], backgroundColor: COLORS.solar, borderColor: COLORS.solar, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Natural Gas', data: [], backgroundColor: COLORS.naturalGas, borderColor: COLORS.naturalGas, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Coal', data: [], backgroundColor: COLORS.coal, borderColor: COLORS.coal, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Storage', data: [], backgroundColor: COLORS.storage, borderColor: COLORS.storage, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Solar to Storage', data: [], backgroundColor: PATTERNS.solarToStorage, borderColor: COLORS.solar, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false, hidden: false },
                        { label: 'Onshore Wind to Storage', data: [], backgroundColor: PATTERNS.windToStorage, borderColor: COLORS.wind, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false, hidden: false },
                        { label: 'Offshore Wind to Storage', data: [], backgroundColor: PATTERNS.offshoreWindToStorage, borderColor: COLORS.offshoreWind, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false, hidden: false },
                        { label: 'Curtailment', data: [], backgroundColor: COLORS.curtailment, borderColor: COLORS.curtailment, borderWidth: 1, fill: true, stack: 'generators', pointRadius: 0, tension: 0.1, dragData: false },
                        { label: 'Demand', data: currentDemand, type: 'line', borderColor: COLORS.demand, borderWidth: 1.5, pointRadius: 0, fill: false, order: -1 }
                    ]
                },
                options: {
                    responsive: true, animation: { duration: 0 },
                    plugins: {
                        tooltip: {
                            mode: 'index',
                            callbacks: {
                                title: function (context) {
                                    return context[0].label;
                                },
                                label: function (context) {
                                    return ''; // We build the full tooltip in the footer
                                },
                                footer: function (tooltipItems) {
                                    const totals = {};
                                    let stackTotal = 0;

                                    tooltipItems.forEach(function (tooltipItem) {
                                        let label = tooltipItem.dataset.label;
                                        const value = tooltipItem.raw;
                                        if (value === 0) return;

                                        // Consolidate "to Storage" tooltips
                                        if (label.includes('to Storage')) {
                                            const sourceTech = label.replace(' to Storage', '');
                                            label = `${sourceTech} (to Storage)`;
                                        }

                                        totals[label] = (totals[label] || 0) + value;

                                        if (tooltipItem.dataset.type !== 'line') {
                                            if (!label.includes('to Storage') && label !== 'Curtailment') {
                                                stackTotal += value;
                                            }
                                        }
                                    });

                                    const lines = [];
                                    const tooltipOrder = ['Coal', 'Natural Gas', 'Hydro', 'Geothermal', 'Biomass', 'RNG (Biogas)', 'Hydrogen', 'Nuclear', 'Solar', 'Onshore Wind', 'Offshore Wind', 'Storage', 'Curtailment', 'Solar (to Storage)', 'Onshore Wind (to Storage)', 'Offshore Wind (to Storage)', 'Demand'];
                                    tooltipOrder.forEach(label => {
                                        if (totals[label] > 0.01) {
                                            lines.push(`${label}: ${totals[label].toFixed(2)}`);
                                        }
                                    });

                                    if (stackTotal > 0) {
                                        lines.push('------------------');
                                        lines.push(`Total Gen to Grid: ${stackTotal.toFixed(2)}`);
                                    }
                                    return lines;
                                }
                            }
                        },
                        legend: {
                            position: 'bottom',
                            labels: {
                                filter: function (legendItem) {
                                    return !legendItem.text.includes('to Storage') && legendItem.text !== 'Demand';
                                }
                            }
                        },
                        dragData: { enabled: false }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            title: { display: false },
                            ticks: {
                                callback: function (value, index) {
                                    // Show month name only at the center of each month (hour 12 of 24)
                                    if (index % 24 === 12) {
                                        const monthIndex = Math.floor(index / 24);
                                        return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][monthIndex];
                                    }
                                    return '';
                                },
                                autoSkip: false,
                                maxRotation: 0
                            }
                        },
                        y: { stacked: true, min: 0, title: { display: true, text: 'Generation (GWh)' } }
                    }
                }
            };
            const marginalPriceChartConfig = {
                type: 'line',
                data: {
                    labels: HOURS,
                    datasets: [{
                        label: 'Marginal Price (with Storage)', data: [],
                        borderColor: COLORS.price, backgroundColor: 'rgba(79, 70, 229, 0.1)',
                        borderWidth: 1.5, fill: true, tension: 0.3, pointRadius: 0
                    }, {
                        label: 'Marginal Price (without Storage)', data: [],
                        borderColor: 'rgba(239, 68, 68, 1)',
                        borderWidth: 1.5, borderDash: [5, 5],
                        fill: false, tension: 0.3, pointRadius: 0
                    }]
                },
                options: {
                    responsive: true, animation: { duration: 0 },
                    scales: {
                        x: {
                            title: { display: false },
                            ticks: {
                                callback: function (value, index) {
                                    // Show month name only at the center of each month (hour 12 of 24)
                                    if (index % 24 === 12) {
                                        const monthIndex = Math.floor(index / 24);
                                        return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][monthIndex];
                                    }
                                    return '';
                                },
                                autoSkip: false,
                                maxRotation: 0
                            }
                        },
                        y: { title: { display: true, text: 'Price ($/MWh)' } }
                    },
                    plugins: {
                        legend: { display: true }
                    }
                }
            };
            const co2ChartConfig = {
                type: 'bar',
                data: {
                    labels: MONTHS,
                    datasets: [{
                        label: 'Total CO2 Emissions (Metric Tons)', data: [],
                        backgroundColor: 'rgba(239, 68, 68, 0.6)',
                        borderColor: 'rgba(239, 68, 68, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true, animation: { duration: 0 },
                    scales: {
                        y: { beginAtZero: true, title: { display: true, text: 'Total CO2 (Metric Tons)' } }
                    },
                    plugins: {
                        legend: { display: false },
                        annotation: {
                            annotations: {
                                totalCO2: {
                                    type: 'label',
                                    content: 'Total Annual CO2: 0 tons',
                                    position: { x: 'center', y: 'top' },
                                    yAdjust: 10,
                                    backgroundColor: 'rgba(249, 250, 251, 0.85)',
                                    borderColor: 'rgba(209, 213, 219, 1)',
                                    borderWidth: 1,
                                    borderRadius: 6,
                                    color: '#1f2937',
                                    font: { weight: 'bold', size: 16 },
                                    padding: 8,
                                }
                            }
                        }
                    }
                }
            };
            const capacityFactorChartConfig = {
                type: 'line',
                data: {
                    labels: HOURS,
                    datasets: [
                        { label: 'Solar', data: [], borderColor: COLORS.solar, borderWidth: 1.5, pointRadius: 0, fill: false, tension: 0.4, dragData: false },
                        { label: 'Onshore Wind', data: [], borderColor: COLORS.wind, borderWidth: 1.5, pointRadius: 0, fill: false, tension: 0.4, dragData: false },
                        { label: 'Offshore Wind', data: [], borderColor: COLORS.offshoreWind, borderWidth: 1.5, pointRadius: 0, fill: false, tension: 0.4, dragData: false }
                    ]
                },
                options: {
                    responsive: true, animation: { duration: 0 },
                    plugins: {
                        legend: { position: 'bottom' },
                        dragData: {
                            round: 2,
                            showTooltip: true,
                            onDrag: (e, datasetIndex, index, value) => {
                                // Enforce constraints DURING dragging for real-time feedback
                                if (value < 0) return 0;
                                if (value > 1) return 1;
                                return value;
                            },
                            onDragEnd: (e, datasetIndex, index, value) => {
                                const chart = e.chart;
                                let updatedValue = value;
                                if (value < 0) updatedValue = 0;
                                if (value > 1) updatedValue = 1;
                                chart.data.datasets[datasetIndex].data[index] = updatedValue;
                                chart.update('none');
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: false },
                            ticks: {
                                callback: function (value, index) {
                                    // Show month name only at the center of each month (hour 12 of 24)
                                    if (index % 24 === 12) {
                                        const monthIndex = Math.floor(index / 24);
                                        return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][monthIndex];
                                    }
                                    return '';
                                },
                                autoSkip: false,
                                maxRotation: 0
                            }
                        },
                        y: { title: { display: true, text: 'Capacity Factor (%)' }, min: 0, max: 1, ticks: { callback: value => `${value * 100}%` } }
                    }
                }
            };

            const generationChart = new Chart(generationCtx, generationChartConfig);
            const marginalPriceChart = new Chart(marginalPriceCtx, marginalPriceChartConfig); // NEW
            const co2Chart = new Chart(co2Ctx, co2ChartConfig);
            const capacityFactorChart = new Chart(capacityFactorCtx, capacityFactorChartConfig);

            // Magnifying glass for capacity factor chart
            const cfMagnifier = document.getElementById('cf-magnifier');
            const cfMagnifierCanvas = document.getElementById('cf-magnifier-canvas');
            const cfMagnifierCtx = cfMagnifierCanvas.getContext('2d');

            function updateMagnifier(e, chart) {
                // Only show magnifier when in edit mode
                if (!isCFEditMode) return;

                const rect = chart.canvas.getBoundingClientRect();

                // Calculate cursor position relative to canvas
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Only show magnifier if cursor is within canvas display bounds
                if (mouseX < 0 || mouseX > rect.width || mouseY < 0 || mouseY > rect.height) {
                    hideMagnifier();
                    return;
                }

                // Convert display coordinates to canvas coordinates (handle canvas scaling)
                const scaleX = chart.canvas.width / rect.width;
                const scaleY = chart.canvas.height / rect.height;
                const x = mouseX * scaleX;
                const y = mouseY * scaleY;

                // Position magnifier centered on cursor
                const magnifierLeft = e.clientX - 100;
                const magnifierTop = e.clientY - 100;

                cfMagnifier.style.left = magnifierLeft + 'px';
                cfMagnifier.style.top = magnifierTop + 'px';
                cfMagnifier.classList.remove('hidden');

                // Draw zoomed portion of chart
                const sourceSize = 80; // 80px becomes 200px = 2.5x zoom
                const sourceX = x - sourceSize / 2;
                const sourceY = y - sourceSize / 2;

                cfMagnifierCtx.fillStyle = 'white';
                cfMagnifierCtx.fillRect(0, 0, 200, 200);
                cfMagnifierCtx.drawImage(
                    chart.canvas,
                    sourceX, sourceY, sourceSize, sourceSize,
                    0, 0, 200, 200
                );

                // Draw crosshair at center
                cfMagnifierCtx.strokeStyle = '#EF4444';
                cfMagnifierCtx.lineWidth = 2;
                cfMagnifierCtx.beginPath();
                cfMagnifierCtx.moveTo(100, 90);
                cfMagnifierCtx.lineTo(100, 110);
                cfMagnifierCtx.moveTo(90, 100);
                cfMagnifierCtx.lineTo(110, 100);
                cfMagnifierCtx.stroke();
            }

            function hideMagnifier() {
                cfMagnifier.classList.add('hidden');
            }

            // Add event listeners to capacity factor chart for magnifier
            capacityFactorCtx.canvas.addEventListener('mousemove', (e) => {
                if (isCFEditMode) {
                    updateMagnifier(e, capacityFactorChart);
                }
            });

            capacityFactorCtx.canvas.addEventListener('mouseleave', hideMagnifier);


            // --- COST CALCULATION ---
            function calculateTotalAnnualSystemCost(generation, capacity, currentIncentives, curtailedEnergy, baselineCapacity, baselineStorage, gasGenDetails) {
                let totalAnnualCost = 0;
                const d = COST_DATA.discount_rate;
                const numHours = generation.solar.length;
                const hoursPerMonth = 24;

                function getAnnualSum(profile) {
                    if (!profile) return 0;
                    let sum = 0;
                    for (let i = 0; i < numHours; i++) {
                        const monthIndex = Math.floor(i / hoursPerMonth) % 12;
                        sum += profile[i] * DAYS_IN_MONTH[monthIndex];
                    }
                    return sum;
                }

                for (const tech in COST_DATA.capacity_factor) {
                    if (tech === 'naturalGas') continue;

                    const techData = COST_DATA;
                    if (!techData.lifetime[tech]) continue;
                    const n = techData.lifetime[tech];
                    const crf = (d * Math.pow(1 + d, n)) / (Math.pow(1 + d, n) - 1);

                    const baselineCapacityGW = baselineCapacity[tech] || 0;
                    const newCapacityGW = capacity[tech] || 0;
                    const totalCapacityKW = (baselineCapacityGW + newCapacityGW) * 1000000;

                    if (totalCapacityKW > 0) {
                        // Use supply-curve-adjusted CAPEX for resource-constrained technologies
                        const totalCapacityGW = (baselineCapacityGW + newCapacityGW);
                        const effectiveCapex = getBlendedCapex(tech, totalCapacityGW);
                        const annualized_capex = effectiveCapex * totalCapacityKW * crf;
                        const annual_fom = techData.fixed_om[tech] * totalCapacityKW;
                        const annual_generation_mwh = getAnnualSum(generation[tech]) * 1000;
                        const annual_vom = techData.variable_om[tech] * annual_generation_mwh;

                        let annual_ptc = 0;
                        if (currentIncentives[tech]) {
                            annual_ptc = currentIncentives[tech] * annual_generation_mwh;
                        }

                        totalAnnualCost += annualized_capex + annual_fom + annual_vom - annual_ptc;
                    }
                }

                const baselineNGCapacityGW = baselineCapacity.naturalGas || 0;
                const newNGCapacityGW = capacity.naturalGas || 0;
                const totalNGCapacityKW = (baselineNGCapacityGW + newNGCapacityGW) * 1000000;

                if (totalNGCapacityKW > 0) {
                    const n = COST_DATA.lifetime.naturalGas;
                    const crf = (d * Math.pow(1 + d, n)) / (Math.pow(1 + d, n) - 1);
                    const annualized_capex = COST_DATA.capex.naturalGas * totalNGCapacityKW * crf;
                    const annual_fom = COST_DATA.fixed_om.naturalGas * totalNGCapacityKW;
                    const annual_vom_ng = (gasGenDetails?.ccgt?.cost || 0) + (gasGenDetails?.ct?.cost || 0);
                    totalAnnualCost += annualized_capex + annual_fom + annual_vom_ng;
                }

                // Calculate total storage power capacity to apportion discharge across types
                const storageTypes = ['battery4hr', 'battery8hr', 'longduration'];
                let totalStoragePowerKW = 0;
                const storagePowerByType = {};
                for (const type of storageTypes) {
                    if (!enabledTechnologies[type]) continue;
                    const total_gwh = (baselineStorage[type] || 0) + (capacity[type] || 0);
                    const duration = type === 'longduration' ? 24 : parseInt(type.match(/\d+/)[0]);
                    const powerKW = (total_gwh * 1000000) / duration;
                    storagePowerByType[type] = powerKW;
                    totalStoragePowerKW += powerKW;
                }
                const totalAnnualStorageDischargeMWh = getAnnualSum(generation.storage) * 1000;

                for (const type of storageTypes) {
                    if (!enabledTechnologies[type]) continue;
                    const baseline_gwh = baselineStorage[type] || 0;
                    const new_gwh = capacity[type] || 0;
                    const total_gwh = baseline_gwh + new_gwh;

                    if (total_gwh > 0) {
                        if (!COST_DATA.lifetime[type]) continue;
                        const n = COST_DATA.lifetime[type];
                        const crf = (d * Math.pow(1 + d, n)) / (Math.pow(1 + d, n) - 1);

                        let capex_per_kwh = COST_DATA.capex[type] - currentIncentives.storage;
                        const total_kwh = total_gwh * 1000000;
                        const duration = type === 'longduration' ? 24 : parseInt(type.match(/\d+/)[0]);
                        const total_kw = total_kwh / duration;

                        const annualized_capex = capex_per_kwh * total_kwh * crf;
                        const annual_fom = COST_DATA.fixed_om[type] * total_kw;
                        // Apportion total storage discharge to this type based on power capacity share
                        const typeShare = totalStoragePowerKW > 0 ? (storagePowerByType[type] || 0) / totalStoragePowerKW : 0;
                        const annual_discharge_mwh = totalAnnualStorageDischargeMWh * typeShare;
                        const annual_vom = COST_DATA.variable_om[type] * annual_discharge_mwh;

                        totalAnnualCost += annualized_capex + annual_fom + annual_vom;
                    }
                }

                if (capacity.dac > 0) {
                    const annualDacCapacityTons = capacity.dac * 24 * 365;
                    const n = COST_DATA.lifetime.dac;
                    const crf = (d * Math.pow(1 + d, n)) / (Math.pow(1 + d, n) - 1);

                    const annualizedDacCapex = COST_DATA.capex.dac * annualDacCapacityTons * crf;
                    const annualDacFom = COST_DATA.fixed_om.dac * annualDacCapacityTons;
                    const dacVariableCost = annualDacCapacityTons * COST_DATA.variable_om.dac;
                    const dacIncentiveValue = annualDacCapacityTons * currentIncentives.dac;

                    totalAnnualCost += (annualizedDacCapex + annualDacFom + dacVariableCost - dacIncentiveValue);
                }

                const totalAnnualCO2 = getAnnualSum(calculateEmissions(generation, 0));
                totalAnnualCost += (totalAnnualCO2 / 1000) * currentIncentives.carbonTax; // carbonTax is in $/ton, CO2 is in kg

                const annualExportRevenue = getAnnualSum(curtailedEnergy) * 1000 * currentIncentives.exportPrice;
                totalAnnualCost -= annualExportRevenue;

                return totalAnnualCost;
            }

            // NEW: Function to calculate consumer cost based on marginal price
            function calculateAnnualConsumerCost(hourlyMarginalPrice, demand) {
                let totalCost = 0;
                const numHours = hourlyMarginalPrice.length;
                const hoursPerMonth = 24;
                for (let i = 0; i < numHours; i++) {
                    const monthIndex = Math.floor(i / hoursPerMonth) % 12;
                    totalCost += hourlyMarginalPrice[i] * demand[i] * 1000 * DAYS_IN_MONTH[monthIndex];
                }
                return totalCost;
            }


            // --- REWRITTEN DISPATCH LOGIC ---
            function getSimulationResult(inputs, solarProfile, windProfile, offshoreWindProfile, potentialGen, baselineStorageGWh = {}, hydroCF, countryName, storageOverrideDisabled = false) {
                const VRE_SOURCES = ['solar', 'wind', 'offshoreWind'];
                const INFLEXIBLE_SOURCES = ['nuclear', 'geothermal', 'biomass'];
                const FLEXIBLE_CLEAN_SOURCES = ['rng', 'hydrogen']; // Dispatched only when needed
                const numHours = solarProfile.length;

                let finalGeneration = {
                    coal: Array(numHours).fill(0), naturalGas: Array(numHours).fill(0),
                    hydro: Array(numHours).fill(0), nuclear: Array(numHours).fill(0),
                    geothermal: Array(numHours).fill(0), biomass: Array(numHours).fill(0), rng: Array(numHours).fill(0), hydrogen: Array(numHours).fill(0),
                    solar: Array(numHours).fill(0), wind: Array(numHours).fill(0), offshoreWind: Array(numHours).fill(0),
                    storage: Array(numHours).fill(0), curtailment: Array(numHours).fill(0),
                    solarToStorage: Array(numHours).fill(0), windToStorage: Array(numHours).fill(0), offshoreWindToStorage: Array(numHours).fill(0)
                };

                let curtailmentBySource = { solar: Array(numHours).fill(0), wind: Array(numHours).fill(0), offshoreWind: Array(numHours).fill(0) };

                let modifiedDemand = [...currentDemand];

                if (inputs.capacity.demandflex > 0) {
                    for (let dayStart = 0; dayStart < numHours; dayStart += 24) {
                        const dayLoad = modifiedDemand.slice(dayStart, dayStart + 24);
                        const originalPeak = Math.max(...dayLoad);
                        let totalAmountToShift = originalPeak * (inputs.capacity.demandflex / 100);

                        const shiftIncrement = 0.1;
                        let iterations = 0;
                        while (totalAmountToShift > 0.01 && iterations < 100) {
                            const currentPeak = Math.max(...dayLoad);
                            const currentTrough = Math.min(...dayLoad);
                            if (currentPeak <= currentTrough) break;

                            const peakIndex = dayLoad.indexOf(currentPeak);
                            const troughIndex = dayLoad.indexOf(currentTrough);

                            const amount = Math.min(shiftIncrement, totalAmountToShift);
                            dayLoad[peakIndex] -= amount;
                            dayLoad[troughIndex] += amount;

                            modifiedDemand[dayStart + peakIndex] -= amount;
                            modifiedDemand[dayStart + troughIndex] += amount;

                            totalAmountToShift -= amount;
                            iterations++;
                        }
                    }
                }


                let currentPotential = JSON.parse(JSON.stringify(potentialGen));

                // Ensure all technology arrays exist and are correctly sized to numHours
                const allTechs = ['solar', 'wind', 'offshoreWind', 'nuclear', 'geothermal', 'biomass', 'rng', 'hydrogen', 'hydro', 'naturalGas', 'coal'];
                for (const tech of allTechs) {
                    if (!currentPotential[tech] || currentPotential[tech].length !== numHours) {
                        // If array is missing or wrong size, create/resize it
                        const existingArray = currentPotential[tech] || [];
                        currentPotential[tech] = Array(numHours).fill(0);
                        // Copy existing values if any
                        for (let j = 0; j < Math.min(existingArray.length, numHours); j++) {
                            currentPotential[tech][j] = existingArray[j] || 0;
                        }
                        // For arrays that were shorter, repeat the 24-hour pattern
                        if (existingArray.length === 24 && numHours > 24) {
                            for (let j = 24; j < numHours; j++) {
                                currentPotential[tech][j] = existingArray[j % 24] || 0;
                            }
                        }
                    }
                }

                // Log CF profile being used (always)
                const maxSolarCF = Math.max(...solarProfile);
                const janMaxCF = Math.max(...solarProfile.slice(0, 24));
                const junMaxCF = Math.max(...solarProfile.slice(120, 144));

                for (let i = 0; i < numHours; i++) {
                    currentPotential.solar[i] += inputs.capacity.solar * solarProfile[i];
                    currentPotential.wind[i] += inputs.capacity.wind * windProfile[i];
                    currentPotential.offshoreWind[i] += inputs.capacity.offshoreWind * offshoreWindProfile[i];
                    currentPotential.nuclear[i] += inputs.capacity.nuclear * COST_DATA.capacity_factor.nuclear;
                    currentPotential.geothermal[i] += inputs.capacity.geothermal * COST_DATA.capacity_factor.geothermal;
                    currentPotential.biomass[i] += inputs.capacity.biomass * COST_DATA.capacity_factor.biomass;
                    currentPotential.rng[i] += inputs.capacity.rng * COST_DATA.capacity_factor.rng;
                    currentPotential.hydrogen[i] += inputs.capacity.hydrogen * COST_DATA.capacity_factor.hydrogen;
                }
                const hydroCapacity = (currentCountryInstalledCapacity.hydro || 0) + (inputs.capacity.hydro || 0);
                const maxHourlyHydroOutput = countryName === 'California' ? hydroCapacity * 0.32 : hydroCapacity;

                let netLoad = Array(numHours).fill(0);
                for (let i = 0; i < numHours; i++) {
                    let vreAndInflexibleGen = 0;
                    [...INFLEXIBLE_SOURCES, ...VRE_SOURCES].forEach(tech => {
                        const potential = currentPotential[tech][i];
                        finalGeneration[tech][i] = potential;
                        vreAndInflexibleGen += potential;
                    });
                    netLoad[i] = modifiedDemand[i] - vreAndInflexibleGen;
                }

                if (!storageOverrideDisabled) {
                    // Save original netLoad before storage dispatch modifies it
                    const originalNetLoad = [...netLoad];

                    const storageDispatch = dispatchStorageEconomically(netLoad, inputs, baselineStorageGWh, currentPotential);

                    // Create new array for capped storage discharge (not a reference)
                    finalGeneration.storage = Array(numHours).fill(0);

                    for (let i = 0; i < numHours; i++) {
                        // CRITICAL: Limit storage discharge to actual remaining deficit from ORIGINAL netLoad
                        // This prevents storage from creating excess generation
                        const maxAllowedDischarge = Math.max(0, originalNetLoad[i] + storageDispatch.charge[i]);
                        finalGeneration.storage[i] = Math.min(storageDispatch.discharge[i], maxAllowedDischarge);

                        netLoad[i] += storageDispatch.charge[i];
                        netLoad[i] -= finalGeneration.storage[i];

                        // Only route VRE to storage if charging AND not discharging (prevents simultaneous charge/discharge)
                        if (storageDispatch.charge[i] > 0 && finalGeneration.storage[i] === 0) {
                            let totalVrePotential = finalGeneration.solar[i] + finalGeneration.wind[i] + finalGeneration.offshoreWind[i];
                            if (totalVrePotential > 0) {
                                const vreChargeAmount = Math.min(storageDispatch.charge[i], totalVrePotential);
                                let solarCharge = (finalGeneration.solar[i] / totalVrePotential) * vreChargeAmount;
                                let windCharge = (finalGeneration.wind[i] / totalVrePotential) * vreChargeAmount;
                                let offshoreCharge = (finalGeneration.offshoreWind[i] / totalVrePotential) * vreChargeAmount;

                                finalGeneration.solarToStorage[i] = solarCharge = Math.min(solarCharge, finalGeneration.solar[i]);
                                finalGeneration.windToStorage[i] = windCharge = Math.min(windCharge, finalGeneration.wind[i]);
                                finalGeneration.offshoreWindToStorage[i] = offshoreCharge = Math.min(offshoreCharge, finalGeneration.offshoreWind[i]);

                                finalGeneration.solar[i] -= solarCharge;
                                finalGeneration.wind[i] -= windCharge;
                                finalGeneration.offshoreWind[i] -= offshoreCharge;
                            }
                        }
                    }
                }

                for (let i = 0; i < numHours; i++) {
                    if (netLoad[i] < 0) {
                        finalGeneration.curtailment[i] = -netLoad[i];

                        // Flexibility: Solar, Wind, Nuclear, Geothermal, Biomass, RNG, and Hydrogen can all curtail
                        const flexibleResources = [...VRE_SOURCES, 'nuclear', 'geothermal', 'biomass', 'rng', 'hydrogen'];
                        let availableForCurtailment = 0;
                        flexibleResources.forEach(tech => availableForCurtailment += finalGeneration[tech][i]);

                        if (availableForCurtailment > 0) {
                            flexibleResources.forEach(tech => {
                                const proportion = finalGeneration[tech][i] / availableForCurtailment;
                                const reduction = Math.min(finalGeneration.curtailment[i] * proportion, finalGeneration[tech][i]);
                                if (VRE_SOURCES.includes(tech)) {
                                    curtailmentBySource[tech][i] += reduction;
                                }
                                finalGeneration[tech][i] -= reduction;
                            });
                        }
                        netLoad[i] = 0;
                    }
                }

                for (let dayStart = 0; dayStart < numHours; dayStart += 24) {
                    const dayNetLoad = netLoad.slice(dayStart, dayStart + 24);
                    const totalDailyHydroEnergy = hydroCapacity * hydroCF * 24;
                    const baseloadHydroEnergy = totalDailyHydroEnergy * 0.40;
                    let flexibleHydroEnergy = totalDailyHydroEnergy * 0.60;

                    const deficitHours = dayNetLoad.map((load, h) => load > 0.01 ? h + dayStart : -1).filter(h => h !== -1);
                    if (deficitHours.length > 0) {
                        const hourlyBaseloadHydro = baseloadHydroEnergy / deficitHours.length;
                        deficitHours.forEach(i => {
                            const hydroToDispatch = Math.min(hourlyBaseloadHydro, netLoad[i], maxHourlyHydroOutput - finalGeneration.hydro[i]);
                            finalGeneration.hydro[i] += hydroToDispatch;
                            netLoad[i] -= hydroToDispatch;
                        });
                    }
                    while (flexibleHydroEnergy > 0.01) {
                        let maxPriority = -Infinity, maxPriorityHour = -1;
                        for (let i = dayStart; i < dayStart + 24; i++) {
                            if (netLoad[i] > 0.01 && netLoad[i] > maxPriority) {
                                maxPriority = netLoad[i];
                                maxPriorityHour = i;
                            }
                        }
                        if (maxPriorityHour === -1) break;
                        const hydroToDispatch = Math.min(0.1, flexibleHydroEnergy, netLoad[maxPriorityHour], maxHourlyHydroOutput - finalGeneration.hydro[maxPriorityHour]);
                        if (hydroToDispatch < 0.001) break;
                        finalGeneration.hydro[maxPriorityHour] += hydroToDispatch;
                        netLoad[maxPriorityHour] -= hydroToDispatch;
                        flexibleHydroEnergy -= hydroToDispatch;
                    }
                }

                // Dispatch flexible clean sources (RNG, Hydrogen) only when there is positive net load
                for (let i = 0; i < numHours; i++) {
                    if (netLoad[i] > 0.01) {
                        for (const tech of FLEXIBLE_CLEAN_SOURCES) {
                            const available = currentPotential[tech][i];
                            const toDispatch = Math.min(available, netLoad[i]);
                            if (toDispatch > 0.001) {
                                finalGeneration[tech][i] = toDispatch;
                                netLoad[i] -= toDispatch;
                            }
                        }
                    }
                }

                const { gasGenDetails, hourlyMarginalPrice, thermalGeneration } = calculateThermalDispatchAndPrice(netLoad, inputs, currentPotential);
                finalGeneration.naturalGas = thermalGeneration.naturalGas;
                finalGeneration.coal = thermalGeneration.coal;

                // --- SANITY CHECK: ENSURE GENERATION DOES NOT EXCEED DEMAND ---
                // This proactively handles any edge cases where generation might slightly exceed demand due to storage/thermal dispatch tolerances
                for (let i = 0; i < numHours; i++) {
                    let totalGen = 0;
                    // Sum all generation sources (excluding curtailment related fields)
                    const genSources = ['coal', 'naturalGas', 'hydro', 'nuclear', 'geothermal', 'biomass', 'rng', 'hydrogen', 'solar', 'wind', 'offshoreWind', 'storage'];
                    genSources.forEach(tech => totalGen += (finalGeneration[tech][i] || 0));

                    if (totalGen > modifiedDemand[i] + 0.001) {
                        const excess = totalGen - modifiedDemand[i];
                        finalGeneration.curtailment[i] += excess;

                        let remainingExcess = excess;

                        // Priority 1: Reduce Thermal (Gas/Coal)
                        ['coal', 'naturalGas'].forEach(tech => {
                            if (remainingExcess > 0.0001 && finalGeneration[tech][i] > 0) {
                                const cut = Math.min(remainingExcess, finalGeneration[tech][i]);
                                finalGeneration[tech][i] -= cut;
                                remainingExcess -= cut;
                            }
                        });

                        // Priority 2: Reduce Storage Discharge
                        if (remainingExcess > 0.0001 && finalGeneration.storage[i] > 0) {
                            const cut = Math.min(remainingExcess, finalGeneration.storage[i]);
                            finalGeneration.storage[i] -= cut;
                            remainingExcess -= cut;
                        }

                        // Priority 3: Reduce Hydro
                        if (remainingExcess > 0.0001 && finalGeneration.hydro[i] > 0) {
                            const cut = Math.min(remainingExcess, finalGeneration.hydro[i]);
                            finalGeneration.hydro[i] -= cut;
                            remainingExcess -= cut;
                        }

                        // Priority 4: Reduce Flexible Clean Gen (VRE + Inflexible)
                        if (remainingExcess > 0.0001) {
                            const flexibleResources = [...VRE_SOURCES, 'nuclear', 'geothermal', 'biomass', 'rng', 'hydrogen'];
                            let available = 0;
                            flexibleResources.forEach(tech => available += finalGeneration[tech][i]);

                            if (available > 0) {
                                const initialTotal = available;
                                flexibleResources.forEach(tech => {
                                    if (finalGeneration[tech][i] > 0) {
                                        const proportion = finalGeneration[tech][i] / initialTotal;
                                        const reduceAmount = remainingExcess * proportion;
                                        const safeReduce = Math.min(reduceAmount, finalGeneration[tech][i]);

                                        finalGeneration[tech][i] -= safeReduce;
                                        if (VRE_SOURCES.includes(tech)) {
                                            curtailmentBySource[tech][i] += safeReduce;
                                        }
                                    }
                                });
                            }
                        }
                    }
                }

                for (let i = 0; i < numHours; i++) {
                    if (finalGeneration.curtailment[i] > 0.01) {
                        hourlyMarginalPrice[i] = inputs.incentives.exportPrice;
                    }
                }

                const newEmissions = calculateEmissions(finalGeneration, inputs.capacity.dac * 1000);  // Convert t/hr to kg/hr
                const newSystemCost = calculateTotalAnnualSystemCost(finalGeneration, inputs.capacity, inputs.incentives, finalGeneration.curtailment, currentCountryInstalledCapacity, baselineStorageGWh, gasGenDetails);

                return {
                    generation: finalGeneration,
                    emissions: newEmissions,
                    systemCost: newSystemCost,
                    demand: modifiedDemand,
                    curtailmentBySource: curtailmentBySource,
                    hourlyMarginalPrice: hourlyMarginalPrice
                };
            }

            function calculateThermalDispatchAndPrice(netLoad, inputs, currentPotential) {
                const gasGenDetails = { ccgt: { generation: 0, cost: 0 }, ct: { generation: 0, cost: 0 } };
                const numHours = netLoad.length;
                const hourlyMarginalPrice = Array(numHours).fill(0);
                const thermalGeneration = { naturalGas: Array(numHours).fill(0), coal: Array(numHours).fill(0) };

                const totalNGCapacity = (currentCountryInstalledCapacity.naturalGas || 0) + (inputs.capacity.naturalGas || 0);
                const ccgtCapacity = totalNGCapacity * 0.7;
                const ctCapacity = totalNGCapacity * 0.3;

                const hoursPerMonth = 24;

                for (let i = 0; i < numHours; i++) {
                    let remainingLoad = netLoad[i];
                    let hourlyPrice = 0;

                    if (remainingLoad <= 0.01) {
                        hourlyMarginalPrice[i] = 0;
                        continue;
                    }

                    const monthIndex = Math.floor(i / hoursPerMonth) % 12;
                    const days = DAYS_IN_MONTH[monthIndex];

                    if (ccgtCapacity > 0) {
                        const ccgtToDispatch = Math.min(remainingLoad, ccgtCapacity);
                        if (ccgtToDispatch > 0) {
                            thermalGeneration.naturalGas[i] += ccgtToDispatch;
                            remainingLoad -= ccgtToDispatch;
                            const costStart = COST_DATA.variable_om.naturalGasCCGT.start;
                            const costEnd = COST_DATA.variable_om.naturalGasCCGT.end;
                            const priceAtDispatch = costStart + (costEnd - costStart) * (ccgtToDispatch / ccgtCapacity);
                            hourlyPrice = Math.max(hourlyPrice, priceAtDispatch);
                            const avgCost = (costStart + priceAtDispatch) / 2;
                            gasGenDetails.ccgt.cost += ccgtToDispatch * 1000 * avgCost * days;
                        }
                    }

                    // Coal dispatches before gas CT (peakers) in merit order:
                    // CCGT ($35-80/MWh) -> Coal ($30/MWh) -> CT ($100-150/MWh)
                    if (remainingLoad > 0.01 && currentPotential.coal[i] > 0) {
                        const coalToDispatch = Math.min(remainingLoad, currentPotential.coal[i]);
                        thermalGeneration.coal[i] += coalToDispatch;
                        remainingLoad -= coalToDispatch;
                        hourlyPrice = Math.max(hourlyPrice, COST_DATA.variable_om.coal);
                    }

                    if (remainingLoad > 0.01 && ctCapacity > 0) {
                        const ctToDispatch = Math.min(remainingLoad, ctCapacity);
                        if (ctToDispatch > 0) {
                            thermalGeneration.naturalGas[i] += ctToDispatch;
                            remainingLoad -= ctToDispatch;
                            const costStart = COST_DATA.variable_om.naturalGasCT.start;
                            const costEnd = COST_DATA.variable_om.naturalGasCT.end;
                            const priceAtDispatch = costStart + (costEnd - costStart) * (ctToDispatch / ctCapacity);
                            hourlyPrice = Math.max(hourlyPrice, priceAtDispatch);
                            const avgCost = (costStart + priceAtDispatch) / 2;
                            gasGenDetails.ct.cost += ctToDispatch * 1000 * avgCost * days;
                        }
                    }
                    hourlyMarginalPrice[i] = hourlyPrice;
                }
                return { gasGenDetails, hourlyMarginalPrice, thermalGeneration };
            }

            function dispatchStorageEconomically(initialNetLoad, inputs, baselineStorageGWh, currentPotential) {
                const storageTypes = ['battery4hr', 'battery8hr', 'longduration'];
                const storageCapacityGWh = {};
                const storagePowerGW = {};
                let totalStorageEnergyGWh = 0;
                // Separate short-term and long-duration capacity for independent dispatch
                let shortTermEnergyGWh = 0;
                let shortTermPowerGW = 0;
                let longDurationEnergyGWh = 0;
                let longDurationPowerGW = 0;

                storageTypes.forEach(type => {
                    if (enabledTechnologies[type]) {
                        const capacity = (baselineStorageGWh[type] || 0) + inputs.capacity[type];
                        storageCapacityGWh[type] = capacity;
                        totalStorageEnergyGWh += capacity;
                        const duration = type === 'longduration' ? 24 : parseInt(type.match(/\d+/)[0]);
                        storagePowerGW[type] = capacity / duration;
                        if (type === 'longduration') {
                            longDurationEnergyGWh = capacity;
                            longDurationPowerGW = capacity / 24;
                        } else {
                            shortTermEnergyGWh += capacity;
                            shortTermPowerGW += capacity / duration;
                        }
                    } else {
                        storageCapacityGWh[type] = 0;
                        storagePowerGW[type] = 0;
                    }
                });

                const numHours = initialNetLoad.length;

                if (totalStorageEnergyGWh === 0) {
                    return { charge: Array(numHours).fill(0), discharge: Array(numHours).fill(0) };
                }

                let netLoad = [...initialNetLoad];
                let hourlyCharge = Array(numHours).fill(0);
                let hourlyDischarge = Array(numHours).fill(0);

                const storageEfficiency = 0.85;
                const DISPATCH_INCREMENT = 0.1;
                const PROFIT_THRESHOLD = 20;

                // Helper: run daily arbitrage dispatch for a given energy/power budget.
                // Paired arbitrage: each cycle charges at a low-price hour and discharges at a high-price hour.
                // Energy headroom tracks how many more cycles can fit (capacity - cycled energy).
                // initialSoC represents pre-existing stored energy (for long-duration carryover).
                function dispatchDailyArbitrage(dayNetLoad, dayPotential, energyBudgetGWh, powerBudgetGW, initialSoC) {
                    let dayCharge = Array(24).fill(0);
                    let dayDischarge = Array(24).fill(0);
                    // For paired arbitrage, track total net energy cycled (not running SoC)
                    // Each cycle uses `dispatchAmount` of capacity (charge in, discharge out)
                    let totalCycledEnergy = 0;
                    let daySoC = initialSoC || 0; // only meaningful for long-duration carryover

                    while (true) {
                        const { hourlyMarginalPrice } = calculateThermalDispatchAndPrice(dayNetLoad, inputs, dayPotential);

                        let maxPrice = -Infinity, minPrice = Infinity;

                        for (let i = 0; i < 24; i++) {
                            if (hourlyMarginalPrice[i] > maxPrice) maxPrice = hourlyMarginalPrice[i];
                            if (hourlyMarginalPrice[i] < minPrice) minPrice = hourlyMarginalPrice[i];
                        }

                        // Find best discharge hour (highest price, least existing discharge)
                        let maxPriceHour = -1;
                        const maxPriceHours = [];
                        for (let i = 0; i < 24; i++) {
                            if (Math.abs(hourlyMarginalPrice[i] - maxPrice) < 0.01) maxPriceHours.push(i);
                        }
                        if (maxPriceHours.length > 0) {
                            maxPriceHour = maxPriceHours[0];
                            let minExisting = dayDischarge[maxPriceHours[0]];
                            for (let j = 1; j < maxPriceHours.length; j++) {
                                if (dayDischarge[maxPriceHours[j]] < minExisting) {
                                    minExisting = dayDischarge[maxPriceHours[j]];
                                    maxPriceHour = maxPriceHours[j];
                                }
                            }
                        }

                        // Find best charge hour (lowest price, least existing charge)
                        let minPriceHour = -1;
                        const minPriceHours = [];
                        for (let i = 0; i < 24; i++) {
                            if (Math.abs(hourlyMarginalPrice[i] - minPrice) < 0.01) minPriceHours.push(i);
                        }
                        if (minPriceHours.length > 0) {
                            minPriceHour = minPriceHours[0];
                            let minExisting = dayCharge[minPriceHours[0]];
                            for (let j = 1; j < minPriceHours.length; j++) {
                                if (dayCharge[minPriceHours[j]] < minExisting) {
                                    minExisting = dayCharge[minPriceHours[j]];
                                    minPriceHour = minPriceHours[j];
                                }
                            }
                        }

                        if ((maxPrice * storageEfficiency) - minPrice <= PROFIT_THRESHOLD || maxPriceHour === -1 || minPriceHour === -1) break;

                        const chargeHeadroom = powerBudgetGW - dayCharge[minPriceHour];
                        const dischargeHeadroom = powerBudgetGW - dayDischarge[maxPriceHour];
                        // Energy headroom: how much more can be cycled through this storage
                        const energyHeadroom = energyBudgetGWh - totalCycledEnergy;

                        const dispatchAmount = Math.min(DISPATCH_INCREMENT, chargeHeadroom, dischargeHeadroom, energyHeadroom);
                        if (dispatchAmount < 0.01) break;

                        const chargeAmount = dispatchAmount / storageEfficiency;
                        dayCharge[minPriceHour] += chargeAmount;
                        dayDischarge[maxPriceHour] += dispatchAmount;
                        totalCycledEnergy += dispatchAmount; // Track energy cycled through storage

                        dayNetLoad[minPriceHour] += chargeAmount;
                        dayNetLoad[maxPriceHour] -= dispatchAmount;
                    }

                    // finalSoC: for long-duration storage, SoC doesn't change from paired arbitrage
                    // (each charge is matched by discharge). Actual SoC changes come from banking/releasing.
                    return { dayCharge, dayDischarge, finalSoC: daySoC, totalCycledEnergy };
                }

                // Pass 1: Short-term battery dispatch (per-day, no carryover)
                if (shortTermEnergyGWh > 0) {
                    for (let dayStart = 0; dayStart < numHours; dayStart += 24) {
                        let dayPotential = {};
                        for (let k in currentPotential) {
                            if (Array.isArray(currentPotential[k])) dayPotential[k] = currentPotential[k].slice(dayStart, dayStart + 24);
                        }
                        let dayNetLoad = netLoad.slice(dayStart, dayStart + 24);

                        const result = dispatchDailyArbitrage(dayNetLoad, dayPotential, shortTermEnergyGWh, shortTermPowerGW, 0);

                        for (let i = 0; i < 24; i++) {
                            hourlyCharge[dayStart + i] += result.dayCharge[i];
                            hourlyDischarge[dayStart + i] += result.dayDischarge[i];
                            netLoad[dayStart + i] = dayNetLoad[i];
                        }
                    }
                }

                // Pass 2: Long-duration storage dispatch (with inter-month SoC carryover)
                // Long-duration storage can bank energy across months:
                // - Charge from excess renewables in high-production months
                // - Discharge stored energy in deficit months
                if (longDurationEnergyGWh > 0) {
                    let longDurationSoC = 0; // Carries over between months (GWh stored)

                    for (let dayStart = 0; dayStart < numHours; dayStart += 24) {
                        let dayPotential = {};
                        for (let k in currentPotential) {
                            if (Array.isArray(currentPotential[k])) dayPotential[k] = currentPotential[k].slice(dayStart, dayStart + 24);
                        }
                        let dayNetLoad = netLoad.slice(dayStart, dayStart + 24);

                        // Step 2a: Intra-day arbitrage (paired charge/discharge)
                        const result = dispatchDailyArbitrage(dayNetLoad, dayPotential, longDurationEnergyGWh, longDurationPowerGW, longDurationSoC);

                        for (let i = 0; i < 24; i++) {
                            hourlyCharge[dayStart + i] += result.dayCharge[i];
                            hourlyDischarge[dayStart + i] += result.dayDischarge[i];
                        }

                        // Step 2b: Bank excess energy (charge when net load is negative/low)
                        for (let i = 0; i < 24; i++) {
                            if (dayNetLoad[i] < -0.01 && longDurationSoC < longDurationEnergyGWh) {
                                const excess = -dayNetLoad[i]; // available excess generation
                                const powerLimit = longDurationPowerGW - result.dayCharge[i]; // remaining power headroom
                                const energyLimit = longDurationEnergyGWh - longDurationSoC;
                                const bankAmount = Math.min(excess * storageEfficiency, powerLimit * storageEfficiency, energyLimit);
                                if (bankAmount > 0.01) {
                                    const grossCharge = bankAmount / storageEfficiency;
                                    hourlyCharge[dayStart + i] += grossCharge;
                                    dayNetLoad[i] += grossCharge;
                                    longDurationSoC += bankAmount;
                                }
                            }
                        }

                        // Step 2c: Release stored energy to cover deficit (discharge from banked SoC)
                        // Sort hours by net load (highest deficit first) for priority dispatch
                        const deficitHours = [];
                        for (let i = 0; i < 24; i++) {
                            if (dayNetLoad[i] > 0.01) deficitHours.push({ hour: i, deficit: dayNetLoad[i] });
                        }
                        deficitHours.sort((a, b) => b.deficit - a.deficit);

                        for (const { hour } of deficitHours) {
                            if (longDurationSoC < 0.01) break;
                            const powerLimit = longDurationPowerGW - result.dayDischarge[hour];
                            const releaseAmount = Math.min(dayNetLoad[hour], powerLimit, longDurationSoC);
                            if (releaseAmount > 0.01) {
                                hourlyDischarge[dayStart + hour] += releaseAmount;
                                dayNetLoad[hour] -= releaseAmount;
                                longDurationSoC -= releaseAmount;
                            }
                        }

                        // Apply self-discharge (1% per month)
                        longDurationSoC *= 0.99;

                        for (let i = 0; i < 24; i++) {
                            netLoad[dayStart + i] = dayNetLoad[i];
                        }
                    }
                }

                return { charge: hourlyCharge, discharge: hourlyDischarge };
            }


            function runSimulation() {
                // Collect inputs
                const currentValues = {};
                for (const key in sliders) {
                    currentValues[key] = parseFloat(sliders[key].value);
                }

                const selectedCountry = countrySelect.value;
                // If profiles aren't ready, use empty arrays (prevents crash on first load)
                const baseProfiles = {
                    solar: countryProfiles[selectedCountry]?.solar || countryProfiles['default'].solar,
                    wind: countryProfiles[selectedCountry]?.wind || countryProfiles['default'].wind,
                    offshoreWind: countryProfiles[selectedCountry]?.offshoreWind || countryProfiles['default'].offshoreWind
                };

                // Construct 12-month profiles
                let fullSolarProfile = [];
                let fullWindProfile = [];
                let fullOffshoreWindProfile = [];
                const fullDemand = [];

                // Check if we should use user-defined profiles instead of rebuilding from base
                if (currentCFProfileName === "User Defined" &&
                    currentSolarCFProfile.length === 288 &&
                    currentWindCFProfile.length === 288 &&
                    currentOffshoreWindCFProfile.length === 288) {
                    // Use the saved user-defined profiles directly
                    fullSolarProfile = [...currentSolarCFProfile];
                    fullWindProfile = [...currentWindCFProfile];
                    fullOffshoreWindProfile = [...currentOffshoreWindCFProfile];
                } else {
                    // Build profiles from monthly profiles (California uses direct CAISO-extracted profiles, others use base + multipliers)
                    const monthlyProfiles = getMonthlyProfiles(selectedCountry);
                    for (let m = 0; m < 12; m++) {
                        fullSolarProfile.push(...monthlyProfiles.solar[m]);
                        fullWindProfile.push(...monthlyProfiles.wind[m]);
                        fullOffshoreWindProfile.push(...monthlyProfiles.offshoreWind[m]);
                    }
                }

                // Build demand profile from monthly profiles
                const monthlyDemand = getMonthlyDemand(selectedCountry);
                for (let m = 0; m < 12; m++) {
                    fullDemand.push(...monthlyDemand[m]);
                }

                let activePotentialGeneration = {};
                if (typeof BASELINE_POTENTIAL_GENERATION !== 'undefined') {
                    for (const tech in BASELINE_POTENTIAL_GENERATION) {
                        activePotentialGeneration[tech] = [];
                    }
                }

                // Get monthly profiles for scaling VRE baseline generation
                const monthlyProfilesForBaseline = getMonthlyProfiles(selectedCountry);

                // Get base CF profiles to calculate scaling ratios
                const baseCFProfiles = {
                    solar: SOLAR_CF_PROFILE,
                    wind: WIND_CF_PROFILE,
                    offshoreWind: OFFSHORE_WIND_CF_PROFILE
                };
                const baseCFPeaks = {
                    solar: Math.max(...SOLAR_CF_PROFILE),           // 0.9
                    wind: Math.max(...WIND_CF_PROFILE),             // ~0.65
                    offshoreWind: Math.max(...OFFSHORE_WIND_CF_PROFILE)  // ~0.62
                };

                for (let m = 0; m < 12; m++) {

                    // Apply monthly capacity factor scaling to baseline VRE generation
                    // BASELINE_POTENTIAL_GENERATION was calculated at base CF profiles
                    // Scale by ratio: (monthly CF) / (base CF) to get correct monthly variation
                    if (typeof BASELINE_POTENTIAL_GENERATION !== 'undefined') {
                        for (const tech in BASELINE_POTENTIAL_GENERATION) {
                            const baselineProfile24h = BASELINE_POTENTIAL_GENERATION[tech] || Array(24).fill(0);

                            // Scale VRE technologies by ratio of monthly CF to base CF
                            if (tech === 'solar' && monthlyProfilesForBaseline.solar) {
                                const monthPeakCF = Math.max(...monthlyProfilesForBaseline.solar[m]);
                                const scalingRatio = monthPeakCF / baseCFPeaks.solar;
                                activePotentialGeneration[tech].push(...baselineProfile24h.map(val => val * scalingRatio));
                            } else if (tech === 'wind' && monthlyProfilesForBaseline.wind) {
                                const monthPeakCF = Math.max(...monthlyProfilesForBaseline.wind[m]);
                                const scalingRatio = monthPeakCF / baseCFPeaks.wind;
                                activePotentialGeneration[tech].push(...baselineProfile24h.map(val => val * scalingRatio));
                            } else if (tech === 'offshoreWind' && monthlyProfilesForBaseline.offshoreWind) {
                                const monthPeakCF = Math.max(...monthlyProfilesForBaseline.offshoreWind[m]);
                                const scalingRatio = monthPeakCF / baseCFPeaks.offshoreWind;
                                activePotentialGeneration[tech].push(...baselineProfile24h.map(val => val * scalingRatio));
                            } else {
                                // Non-VRE technologies: keep as-is
                                activePotentialGeneration[tech].push(...baselineProfile24h);
                            }
                        }
                    }
                }

                // Verification logging for baseline VRE generation with monthly CF scaling
                if (activePotentialGeneration.solar && activePotentialGeneration.solar.length === 288) {
                    const janSolarPeak = Math.max(...activePotentialGeneration.solar.slice(0, 24));
                    const junSolarPeak = Math.max(...activePotentialGeneration.solar.slice(120, 144));
                    const augSolarPeak = Math.max(...activePotentialGeneration.solar.slice(168, 192));
                    console.log(`âœ“ Baseline solar generation now varies by month:`);
                    console.log(`  Jan peak: ${janSolarPeak.toFixed(2)} GW (CF 0.578), Jun peak: ${junSolarPeak.toFixed(2)} GW (CF 1.00), Aug peak: ${augSolarPeak.toFixed(2)} GW (CF 0.91)`);
                }

                currentDemand = fullDemand; // Update global currentDemand

                // REMOVED: This code was incorrectly OVERWRITING baseline generation when using user-defined CFs
                // The baseline should stay in activePotentialGeneration, and NEW capacity is added via inputs.capacity in getSimulationResult
                // If using user-defined CF profiles, they're already applied to fullSolarProfile/fullWindProfile/fullOffshoreWindProfile
                // and will be used correctly when getSimulationResult adds inputs.capacity to the baseline (line 2042-2044)

                const inputsForSim = {
                    capacity: {
                        solar: currentValues.solar,
                        wind: currentValues.wind,
                        offshoreWind: currentValues.offshoreWind,
                        geothermal: currentValues.geothermal,
                        nuclear: currentValues.nuclear,
                        biomass: currentValues.biomass,
                        rng: currentValues.rng,
                        hydrogen: currentValues.hydrogen,
                        battery4hr: currentValues.battery4hr,
                        battery8hr: currentValues.battery8hr,
                        longduration: currentValues.longduration,
                        dac: currentValues.dac,
                        hydro: 0,
                        naturalGas: 0,
                        coal: 0,
                        demandflex: currentValues.demandflex
                    },
                    incentives: {
                        solar: currentValues.solarIncentive,
                        wind: currentValues.windIncentive,
                        offshoreWind: currentValues.offshoreWindIncentive,
                        geothermal: currentValues.geothermalIncentive,
                        nuclear: currentValues.nuclearIncentive,
                        biomass: currentValues.biomassIncentive,
                        rng: currentValues.rngIncentive,
                        hydrogen: currentValues.hydrogenIncentive,
                        storage: currentValues.storageIncentive,
                        dac: currentValues.dacIncentive,
                        carbonTax: currentValues.carbonTax,
                        exportPrice: currentValues.exportPrice
                    }
                };

                const result = getSimulationResult(inputsForSim, fullSolarProfile, fullWindProfile, fullOffshoreWindProfile, activePotentialGeneration, currentBaselineStorage, currentHydroCF, selectedCountry);
                const resultWithoutStorage = getSimulationResult(inputsForSim, fullSolarProfile, fullWindProfile, fullOffshoreWindProfile, activePotentialGeneration, currentBaselineStorage, currentHydroCF, selectedCountry, true);

                const totalAnnualSystemCost = result.systemCost;
                const annualConsumerCost = calculateAnnualConsumerCost(result.hourlyMarginalPrice, result.demand);

                const totalAnnualSystemCostBaseline = customBaselineSystemCost;
                const systemCostPercentageChange = totalAnnualSystemCostBaseline > 0 ? ((totalAnnualSystemCost - totalAnnualSystemCostBaseline) / totalAnnualSystemCostBaseline) * 100 : 0;

                const billPercentageChange = customBaselineConsumerCost > 0 ? ((annualConsumerCost - customBaselineConsumerCost) / customBaselineConsumerCost) * 100 : 0;

                // Calculate total annual CO2 by multiplying each hour by days in that month
                let totalAnnualCO2 = 0;
                const hoursPerMonth = 24;
                for (let i = 0; i < result.emissions.length; i++) {
                    const monthIndex = Math.floor(i / hoursPerMonth) % 12;
                    totalAnnualCO2 += result.emissions[i] * DAYS_IN_MONTH[monthIndex];
                }

                // Calculate CO2 avoided and abatement cost
                const co2Avoided = customBaselineTotalAnnualCO2 - totalAnnualCO2;
                const abatementCost = co2Avoided > 0 ? (totalAnnualSystemCost - totalAnnualSystemCostBaseline) / (co2Avoided / 1e9) : 0;

                updateCharts(result.generation, result.emissions, result.demand, totalAnnualCO2, fullSolarProfile, fullWindProfile, fullOffshoreWindProfile, result.hourlyMarginalPrice, resultWithoutStorage.hourlyMarginalPrice);

                // Store generation data for CSV export
                latestGenerationData = {
                    generation: result.generation,
                    demand: result.demand,
                    country: selectedCountry
                };

                updateGridMixSlider(currentCountryInstalledCapacity, defaultCapacityMix);
                updateGenerationMixSlider(result.generation, defaultGenerationMix, result.curtailmentBySource);

                billImpactEl.textContent = `${billPercentageChange > 0 ? '+' : ''}${billPercentageChange.toFixed(0)}%`;
                systemCostImpactEl.textContent = `${systemCostPercentageChange > 0 ? '+' : ''}${systemCostPercentageChange.toFixed(0)}%`;

                [billImpactEl, systemCostImpactEl].forEach((el, index) => {
                    const change = index === 0 ? billPercentageChange : systemCostPercentageChange;
                    if (change > 0) {
                        el.className = 'text-5xl font-bold text-red-600 mt-2';
                    } else if (change < 0) {
                        el.className = 'text-5xl font-bold text-green-600 mt-2';
                    } else {
                        el.className = 'text-5xl font-bold text-blue-600 mt-2';
                    }
                });

                // Display CO2 Avoided
                const co2AvoidedPercent = customBaselineTotalAnnualCO2 > 0 ? (co2Avoided / customBaselineTotalAnnualCO2) * 100 : 0;

                if (Math.abs(co2Avoided) < 1000) { // 1000 kg = 1 ton tolerance
                    co2AvoidedEl.textContent = `CO2 avoided: 0 tons (0%)`;
                    co2AvoidedEl.className = 'text-md font-medium text-gray-700';
                } else {
                    let text = `CO2 avoided: ${(co2Avoided / 1e9).toFixed(1)}M tons (${co2AvoidedPercent.toFixed(0)}%)`;
                    if (co2Avoided > 0) {
                        text += ` at $${abatementCost.toFixed(0)}/ton`;
                    }
                    co2AvoidedEl.textContent = text;
                    co2AvoidedEl.className = co2Avoided > 0 ? 'text-md font-medium text-green-600' : 'text-md font-medium text-red-600';
                }
            }

            function calculateEmissions(generation, dacRate) {
                const co2 = [];
                const numHours = generation.naturalGas.length;
                for (let i = 0; i < numHours; i++) {
                    let hourlyEmission = 0;
                    if (EMISSION_FACTORS) {
                        // Generation is in GW, emission factors are in kg/MWh
                        // Need to multiply by 1000 to convert GW to MW
                        hourlyEmission += (generation.naturalGas[i] || 0) * 1000 * EMISSION_FACTORS.naturalGas;
                        hourlyEmission += (generation.coal[i] || 0) * 1000 * EMISSION_FACTORS.coal;
                        hourlyEmission += (generation.biomass[i] || 0) * 1000 * EMISSION_FACTORS.biomass;
                    } else {
                        // Fallback
                        hourlyEmission += (generation.naturalGas[i] || 0) * 1000 * 0.45;
                        hourlyEmission += (generation.coal[i] || 0) * 1000 * 1.0;
                    }
                    hourlyEmission -= dacRate;
                    co2.push(Math.max(0, hourlyEmission));
                }
                return co2;
            }

            function updateCharts(generation, emissions, demand, totalAnnualCO2, solarProfile, windProfile, offshoreWindProfile, hourlyMarginalPrice, priceWithoutStorage) {
                const chartData = generationChart.data.datasets;

                const techMap = {
                    nuclear: 0, geothermal: 1, biomass: 2, rng: 3, hydrogen: 4, hydro: 5,
                    wind: 6, offshoreWind: 7, solar: 8,
                    naturalGas: 9, coal: 10, storage: 11,
                    solarToStorage: 12, windToStorage: 13, offshoreWindToStorage: 14, curtailment: 15
                };

                for (const tech in techMap) {
                    if (generation[tech]) {
                        chartData[techMap[tech]].data = generation[tech];
                    }
                }
                chartData[16].data = demand;

                generationChart.update('none');

                // Update marginal price chart
                marginalPriceChart.data.datasets[0].data = hourlyMarginalPrice;
                marginalPriceChart.data.datasets[1].data = priceWithoutStorage;
                marginalPriceChart.update('none');

                // Update CO2 chart (Monthly Bar Chart)
                const monthlyEmissions = Array(12).fill(0);
                // emissions is length 288 (hourly rates t/hr)
                for (let i = 0; i < emissions.length; i++) {
                    const monthIndex = Math.floor(i / 24) % 12;
                    monthlyEmissions[monthIndex] += emissions[i] * DAYS_IN_MONTH[monthIndex];
                }

                co2Chart.data.datasets[0].data = monthlyEmissions;
                if (co2Chart.options.plugins.annotation && co2Chart.options.plugins.annotation.annotations.totalCO2) {
                    co2Chart.options.plugins.annotation.annotations.totalCO2.content = `Total Annual CO2: ${(totalAnnualCO2 / 1e9).toFixed(2)} Million Tons`;
                }
                co2Chart.update('none');

                capacityFactorChart.data.datasets[0].data = solarProfile;
                capacityFactorChart.data.datasets[1].data = windProfile;
                capacityFactorChart.data.datasets[2].data = offshoreWindProfile;
                capacityFactorChart.update('none');
            }

            function updateGridMixSlider(installedCapacity, defaultMix) {
                const capacities = {};
                let totalCapacity = 0;

                for (const tech in COST_DATA.capacity_factor) {
                    const baselineCapacity = installedCapacity[tech] || 0;
                    let newCapacity = 0;
                    if (sliders[tech]) {
                        newCapacity = parseFloat(sliders[tech].value);
                    }
                    capacities[tech] = baselineCapacity + newCapacity;
                    totalCapacity += capacities[tech];
                }

                if (totalCapacity > 0) {
                    for (const tech in capacities) {
                        if (COST_DATA.capacity_factor[tech]) { // Only for generators
                            const percentage = (capacities[tech] / totalCapacity) * 100;
                            const fillEl = document.getElementById(`mix-fill-${tech}`);
                            const valueEl = document.getElementById(`mix-value-${tech}`);
                            const outlineEl = document.getElementById(`mix-default-outline-${tech}`);

                            if (fillEl && valueEl) {
                                fillEl.style.width = `${percentage}%`;
                                valueEl.textContent = `${percentage.toFixed(1)}%`;
                            }
                            if (outlineEl && defaultMix[tech] !== undefined) {
                                outlineEl.style.width = `${defaultMix[tech]}%`;
                            }
                        }
                    }
                }

                // Update storage display
                ['battery4hr', 'battery8hr', 'longduration'].forEach(type => {
                    const baselineGWh = currentBaselineStorage[type] || 0;
                    const newGWh = parseFloat(sliders[type].value);
                    const totalGWh = baselineGWh + newGWh;
                    const duration = type === 'longduration' ? 24 : parseInt(type.match(/\d+/)[0]);
                    const totalGW = totalGWh / duration;
                    const displayEl = document.getElementById(`storage-capacity-${type}`);
                    if (displayEl) {
                        displayEl.textContent = `${totalGW.toFixed(2)} GW / ${totalGWh.toFixed(2)} GWh`;
                    }
                });
            }

            function createGridMixSliders() {
                const techOrder = ['coal', 'naturalGas', 'solar', 'hydro', 'wind', 'offshoreWind', 'nuclear', 'geothermal', 'biomass', 'rng', 'hydrogen'];
                techOrder.forEach(tech => {
                    let name = tech.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                    if (tech === 'wind') name = 'Onshore Wind';
                    if (tech === 'offshoreWind') name = 'Offshore Wind';
                    if (tech === 'rng') name = 'RNG (Biogas)';
                    if (tech === 'hydrogen') name = 'Hydrogen';

                    const color = COLORS[tech] || '#ccc';

                    const wrapper = document.createElement('div');
                    wrapper.className = 'grid grid-cols-6 gap-2 items-center mix-slider-row';
                    wrapper.dataset.tech = tech;

                    const checkboxContainer = document.createElement('div');
                    checkboxContainer.className = "flex items-center justify-center";
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `toggle-${tech}`;
                    checkbox.checked = true;
                    checkbox.className = "form-checkbox h-5 w-5 text-blue-600 rounded";
                    checkbox.addEventListener('change', () => {
                        enabledTechnologies[tech] = checkbox.checked;
                        runSimulation();
                        saveState();
                    });
                    checkboxContainer.appendChild(checkbox);
                    wrapper.appendChild(checkboxContainer);

                    const label = document.createElement('label');
                    label.textContent = name;
                    label.className = 'col-span-1 text-sm font-medium text-gray-700';
                    wrapper.appendChild(label);

                    const sliderContainer = document.createElement('div');
                    sliderContainer.className = 'col-span-3';
                    const track = document.createElement('div');
                    track.className = 'mix-slider-track';
                    const fill = document.createElement('div');
                    fill.id = `mix-fill-${tech}`;
                    fill.className = 'mix-slider-fill';
                    fill.style.backgroundColor = color;
                    const outline = document.createElement('div');
                    outline.id = `mix-default-outline-${tech}`;
                    outline.className = 'mix-slider-default-outline';
                    track.appendChild(fill);
                    track.appendChild(outline);
                    sliderContainer.appendChild(track);
                    wrapper.appendChild(sliderContainer);

                    const value = document.createElement('span');
                    value.id = `mix-value-${tech}`;
                    value.className = 'col-span-1 text-sm font-semibold text-right';
                    value.textContent = '0.0%';
                    wrapper.appendChild(value);

                    gridMixSlidersContainer.appendChild(wrapper);
                });

                // Create storage section
                const storageHeader = document.createElement('h3');
                storageHeader.className = 'text-lg font-lora font-semibold mt-6 mb-2 text-gray-800';
                storageHeader.textContent = 'Installed Storage Capacity';
                storageCapacityDisplayContainer.appendChild(storageHeader);

                const storageTypes = [
                    { id: 'battery4hr', name: '4-hr Battery' },
                    { id: 'battery8hr', name: '8-hr Battery' },
                    { id: 'longduration', name: '24-hr Storage' }
                ];

                storageTypes.forEach(type => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'grid grid-cols-6 gap-2 items-center';

                    const checkboxContainer = document.createElement('div');
                    checkboxContainer.className = "flex items-center justify-center";
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `toggle-${type.id}`;
                    checkbox.checked = true;
                    checkbox.className = "form-checkbox h-5 w-5 text-blue-600 rounded";
                    checkbox.addEventListener('change', () => {
                        enabledTechnologies[type.id] = checkbox.checked;
                        runSimulation();
                        saveState();
                    });
                    checkboxContainer.appendChild(checkbox);
                    wrapper.appendChild(checkboxContainer);

                    const label = document.createElement('label');
                    label.textContent = type.name;
                    label.className = 'col-span-2 text-sm font-medium text-gray-700';
                    wrapper.appendChild(label);

                    const value = document.createElement('span');
                    value.id = `storage-capacity-${type.id}`;
                    value.className = 'col-span-3 text-sm font-semibold text-right';
                    value.textContent = '0.00 GW / 0.00 GWh';
                    wrapper.appendChild(value);

                    storageCapacityDisplayContainer.appendChild(wrapper);
                });
            }

            // --- GENERATION MIX SLIDER ---
            function updateGenerationMixSlider(generation, defaultMix, curtailmentBySource) {
                yearlyGenerationTotalsGWh = {}; // Clear previous totals
                let totalGeneration = 0;

                const gridTechs = ['coal', 'naturalGas', 'hydro', 'geothermal', 'biomass', 'rng', 'hydrogen', 'nuclear', 'solar', 'wind', 'offshoreWind', 'storage'];
                gridTechs.forEach(tech => {
                    // Calculate yearly total by multiplying each hour by days in that month
                    let techTotal = 0;
                    (generation[tech] || []).forEach((value, i) => {
                        const monthIndex = Math.floor(i / 24) % 12;
                        techTotal += value * DAYS_IN_MONTH[monthIndex];
                    });
                    yearlyGenerationTotalsGWh[tech] = techTotal;
                    totalGeneration += techTotal;
                });

                if (totalGeneration > 0) {
                    gridTechs.forEach(tech => {
                        const percentage = (yearlyGenerationTotalsGWh[tech] / totalGeneration) * 100;
                        const fillEl = document.getElementById(`gen-mix-fill-${tech}`);
                        const valueEl = document.getElementById(`gen-mix-value-${tech}`);
                        const outlineEl = document.getElementById(`gen-mix-default-outline-${tech}`);

                        if (fillEl && valueEl) {
                            fillEl.style.width = `${percentage}%`;
                            valueEl.textContent = `${percentage.toFixed(1)}%`;
                        }
                        if (outlineEl && defaultMix[tech] !== undefined) {
                            outlineEl.style.width = `${defaultMix[tech]}%`;
                        }
                    });
                } else {
                    gridTechs.forEach(tech => {
                        const fillEl = document.getElementById(`gen-mix-fill-${tech}`);
                        const valueEl = document.getElementById(`gen-mix-value-${tech}`);
                        if (fillEl && valueEl) {
                            fillEl.style.width = '0%';
                            valueEl.textContent = '0.0%';
                        }
                    });
                }

                const curtailmentTrack = document.getElementById('gen-mix-track-curtailment');
                const curtailmentValue = document.getElementById('gen-mix-value-curtailment');
                curtailmentTrack.innerHTML = '';

                // Calculate yearly curtailment by multiplying each hour by days in that month
                let totalCurtailed = 0;
                (generation.curtailment || []).forEach((value, i) => {
                    const monthIndex = Math.floor(i / 24) % 12;
                    totalCurtailed += value * DAYS_IN_MONTH[monthIndex];
                });
                yearlyGenerationTotalsGWh['curtailment'] = totalCurtailed;

                // Calculate yearly storage charging
                let solarToStorageTotal = 0, windToStorageTotal = 0, offshoreWindToStorageTotal = 0;
                (generation.solarToStorage || []).forEach((value, i) => {
                    const monthIndex = Math.floor(i / 24) % 12;
                    solarToStorageTotal += value * DAYS_IN_MONTH[monthIndex];
                });
                (generation.windToStorage || []).forEach((value, i) => {
                    const monthIndex = Math.floor(i / 24) % 12;
                    windToStorageTotal += value * DAYS_IN_MONTH[monthIndex];
                });
                (generation.offshoreWindToStorage || []).forEach((value, i) => {
                    const monthIndex = Math.floor(i / 24) % 12;
                    offshoreWindToStorageTotal += value * DAYS_IN_MONTH[monthIndex];
                });

                let totalPotentialGeneration = totalGeneration + totalCurtailed + solarToStorageTotal + windToStorageTotal + offshoreWindToStorageTotal;

                if (totalPotentialGeneration > 0) {
                    const overallCurtailmentPercent = (totalCurtailed / totalPotentialGeneration) * 100;
                    curtailmentValue.textContent = `${overallCurtailmentPercent.toFixed(1)}%`;

                    if (totalCurtailed > 0) {
                        // Calculate yearly curtailment by source
                        let solarCurtail = 0, windCurtail = 0, offshoreWindCurtail = 0;
                        (curtailmentBySource.solar || []).forEach((value, i) => {
                            const monthIndex = Math.floor(i / 24) % 12;
                            solarCurtail += value * DAYS_IN_MONTH[monthIndex];
                        });
                        (curtailmentBySource.wind || []).forEach((value, i) => {
                            const monthIndex = Math.floor(i / 24) % 12;
                            windCurtail += value * DAYS_IN_MONTH[monthIndex];
                        });
                        (curtailmentBySource.offshoreWind || []).forEach((value, i) => {
                            const monthIndex = Math.floor(i / 24) % 12;
                            offshoreWindCurtail += value * DAYS_IN_MONTH[monthIndex];
                        });

                        const techWithCurtailment = [{ tech: 'solar', val: solarCurtail }, { tech: 'wind', val: windCurtail }, { tech: 'offshoreWind', val: offshoreWindCurtail }];

                        techWithCurtailment.forEach(item => {
                            if (item.val > 0) {
                                const contributionPercent = (item.val / totalCurtailed);
                                const segmentWidth = 100 * contributionPercent;

                                const segment = document.createElement('div');
                                segment.className = 'h-full';
                                segment.style.backgroundColor = COLORS[item.tech];
                                segment.style.width = `${segmentWidth}%`;
                                segment.style.float = 'left';
                                curtailmentTrack.appendChild(segment);
                            }
                        });
                        curtailmentTrack.parentElement.style.width = `${overallCurtailmentPercent}%`;
                    } else {
                        curtailmentTrack.parentElement.style.width = `0%`;
                    }
                } else {
                    curtailmentValue.textContent = '0.0%';
                    curtailmentTrack.parentElement.style.width = `0%`;
                }
            }

            function createGenerationMixSliders() {
                const techOrder = ['coal', 'naturalGas', 'solar', 'hydro', 'wind', 'offshoreWind', 'nuclear', 'geothermal', 'biomass', 'rng', 'hydrogen', 'storage'];
                techOrder.forEach(tech => {
                    let name = tech.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                    if (tech === 'wind') name = 'Onshore Wind';
                    if (tech === 'offshoreWind') name = 'Offshore Wind';
                    if (tech === 'rng') name = 'RNG (Biogas)';
                    if (tech === 'hydrogen') name = 'Hydrogen';
                    const color = COLORS[tech] || '#ccc';

                    const wrapper = document.createElement('div');
                    wrapper.className = 'grid grid-cols-5 gap-2 items-center mix-slider-row';
                    wrapper.dataset.tech = tech;

                    const label = document.createElement('label');
                    label.textContent = name;
                    label.className = 'col-span-1 text-sm font-medium text-gray-700';
                    wrapper.appendChild(label);

                    const sliderContainer = document.createElement('div');
                    sliderContainer.className = 'col-span-3';
                    const track = document.createElement('div');
                    track.className = 'mix-slider-track';
                    const fill = document.createElement('div');
                    fill.id = `gen-mix-fill-${tech}`;
                    fill.className = 'mix-slider-fill';
                    fill.style.backgroundColor = color;
                    const outline = document.createElement('div');
                    outline.id = `gen-mix-default-outline-${tech}`;
                    outline.className = 'mix-slider-default-outline';
                    track.appendChild(fill);
                    track.appendChild(outline);
                    sliderContainer.appendChild(track);
                    wrapper.appendChild(sliderContainer);

                    const value = document.createElement('span');
                    value.id = `gen-mix-value-${tech}`;
                    value.className = 'col-span-1 text-sm font-semibold text-right';
                    value.textContent = '0.0%';
                    wrapper.appendChild(value);

                    generationMixSlidersContainer.appendChild(wrapper);
                });

                const wrapper = document.createElement('div');
                wrapper.className = 'grid grid-cols-5 gap-2 items-center mix-slider-row';
                wrapper.dataset.tech = 'curtailment';
                const label = document.createElement('label');
                label.textContent = 'Curtailment';
                label.className = 'col-span-1 text-sm font-medium text-gray-700';
                wrapper.appendChild(label);
                const sliderContainer = document.createElement('div');
                sliderContainer.className = 'col-span-3';
                const outerTrack = document.createElement('div');
                outerTrack.className = 'mix-slider-track';
                const innerTrack = document.createElement('div');
                innerTrack.id = 'gen-mix-track-curtailment';
                innerTrack.className = 'h-full w-full';
                outerTrack.appendChild(innerTrack);
                sliderContainer.appendChild(outerTrack);
                wrapper.appendChild(sliderContainer);
                const value = document.createElement('span');
                value.id = `gen-mix-value-curtailment`;
                value.className = 'col-span-1 text-sm font-semibold text-right';
                value.textContent = '0.0%';
                wrapper.appendChild(value);
                generationMixSlidersContainer.appendChild(wrapper);
            }

            // --- HELPER: Calculate minimum demand based on inflexible baseload ---
            function calculateMinimumDemand() {
                const INFLEXIBLE_SOURCES = ['nuclear', 'geothermal', 'biomass'];
                const currentValues = {};
                for (const key in sliders) {
                    currentValues[key] = parseFloat(sliders[key].value);
                }

                let minDemand = 0;
                INFLEXIBLE_SOURCES.forEach(tech => {
                    const baselineCapacity = currentCountryInstalledCapacity[tech] || 0;
                    const newCapacity = currentValues[tech] || 0;
                    const totalCapacity = baselineCapacity + newCapacity;
                    const cf = COST_DATA.capacity_factor[tech] || 0;
                    minDemand += totalCapacity * cf;
                });
                return minDemand;
            }

            // --- DEMAND EDIT MODE ---
            function setDemandEditMode(enabled) {
                isDemandEditMode = enabled;
                const demandDatasetIndex = generationChart.data.datasets.findIndex(ds => ds.label === 'Demand');

                if (enabled) {
                    if (editDemandBtn) editDemandBtn.classList.add('hidden');
                    if (confirmDemandBtn) confirmDemandBtn.classList.remove('hidden');
                    if (revertDemandBtn) revertDemandBtn.classList.remove('hidden');
                    if (demandPresetsDiv) demandPresetsDiv.classList.remove('hidden');

                    document.querySelectorAll('#demand-presets button').forEach(btn => {
                        btn.classList.remove('preset-active');
                        if (btn.id === `preset-demand-${currentDemandProfileName.toLowerCase().replace(' ', '-')}`) {
                            btn.classList.add('preset-active');
                        }
                    });

                    generationChart.data.datasets.forEach((dataset, index) => {
                        if (index !== demandDatasetIndex) {
                            dataset.hidden = true;
                        } else {
                            dataset.borderWidth = 4;
                            dataset.pointRadius = 6;
                            dataset.pointHoverRadius = 8;
                            dataset.pointBackgroundColor = 'rgba(17, 24, 39, 1)';
                            dataset.pointBorderColor = 'white';
                            dataset.pointBorderWidth = 2;
                        }
                    });

                    generationChart.options.plugins.dragData = {
                        round: 1,
                        showTooltip: true,
                        onDrag: function (e, datasetIndex, index, value) {
                            // Enforce constraints DURING dragging for real-time feedback
                            const minDemand = calculateMinimumDemand();

                            if (value < minDemand) {
                                return minDemand;
                            }
                            if (value < 0) {
                                return 0;
                            }
                            return value;
                        },
                        onDragEnd: function (e, datasetIndex, index, value) {
                            const chart = e.chart;
                            let updatedValue = value;

                            // Calculate minimum demand based on inflexible baseload
                            const minDemand = calculateMinimumDemand();

                            // Enforce minimum demand constraint
                            if (updatedValue < minDemand) {
                                updatedValue = minDemand;
                            }

                            // Enforce non-negative constraint
                            if (updatedValue < 0) {
                                updatedValue = 0;
                            }

                            chart.data.datasets[datasetIndex].data[index] = updatedValue;
                            generationChart.update('none');
                        }
                    };
                    generationChart.options.plugins.dragData.enabled = true;
                    generationChart.options.scales.y.stacked = false;
                    generationChart.update();

                } else {
                    if (editDemandBtn) editDemandBtn.classList.remove('hidden');
                    if (confirmDemandBtn) confirmDemandBtn.classList.add('hidden');
                    if (revertDemandBtn) revertDemandBtn.classList.add('hidden');
                    if (demandPresetsDiv) demandPresetsDiv.classList.add('hidden');

                    generationChart.data.datasets.forEach((dataset, index) => {
                        dataset.hidden = false;
                        if (index === demandDatasetIndex) {
                            dataset.borderWidth = 3;
                            dataset.pointRadius = 0;
                            dataset.pointHoverRadius = 0;
                        }
                    });

                    if (generationChart.options.plugins.dragData) {
                        generationChart.options.plugins.dragData.enabled = false;
                        generationChart.options.plugins.dragData.onDragEnd = null;
                    }
                    generationChart.options.scales.y.stacked = true;
                    generationChart.update();
                }
            }

            // --- CF EDIT MODE ---
            function setCFEditMode(enabled) {
                isCFEditMode = enabled;

                if (enabled) {
                    if (editCFBtn) editCFBtn.classList.add('hidden');
                    if (confirmCFBtn) confirmCFBtn.classList.remove('hidden');
                    if (revertCFBtn) revertCFBtn.classList.remove('hidden');
                    capacityFactorChart.data.datasets.forEach(dataset => {
                        dataset.pointRadius = 6;
                        dataset.pointHoverRadius = 8;
                        dataset.pointBorderColor = 'white';
                        dataset.pointBorderWidth = 2;
                        dataset.dragData = true;
                    });

                } else {
                    if (editCFBtn) editCFBtn.classList.remove('hidden');
                    if (confirmCFBtn) confirmCFBtn.classList.add('hidden');
                    if (revertCFBtn) revertCFBtn.classList.add('hidden');

                    capacityFactorChart.data.datasets.forEach(dataset => {
                        dataset.pointRadius = 0;
                        dataset.dragData = false;
                    });
                }
                capacityFactorChart.update();
            }

            // --- NEW: Function to set the baseline from the current state ---
            // Returns the simulation result to avoid running the simulation twice
            function setNewBaselineFromCurrentState() {
                const currentValues = {};
                for (const key in sliders) {
                    currentValues[key] = parseFloat(sliders[key].value);
                }

                let activePotentialGeneration = JSON.parse(JSON.stringify(BASELINE_POTENTIAL_GENERATION));
                for (const tech in enabledTechnologies) {
                    if (!enabledTechnologies[tech]) {
                        activePotentialGeneration[tech] = Array(24).fill(0);
                    }
                }

                const newBaselineResult = getSimulationResult(
                    {
                        capacity: {
                            solar: currentValues.solar, wind: currentValues.wind, offshoreWind: currentValues.offshoreWind,
                            geothermal: currentValues.geothermal, nuclear: currentValues.nuclear,
                            biomass: currentValues.biomass, rng: currentValues.rng, hydrogen: currentValues.hydrogen,
                            battery4hr: currentValues.battery4hr, battery8hr: currentValues.battery8hr,
                            longduration: currentValues.longduration, dac: currentValues.dac,
                            demandflex: currentValues.demandflex,
                        },
                        incentives: {
                            solar: currentValues.solarIncentive, wind: currentValues.windIncentive, offshoreWind: currentValues.offshoreWindIncentive,
                            geothermal: currentValues.geothermalIncentive, nuclear: currentValues.nuclearIncentive,
                            biomass: currentValues.biomassIncentive, rng: currentValues.rngIncentive, hydrogen: currentValues.hydrogenIncentive,
                            storage: currentValues.storageIncentive, dac: currentValues.dacIncentive,
                            carbonTax: currentValues.carbonTax,
                            exportPrice: currentValues.exportPrice,
                        }
                    },
                    currentSolarCFProfile,
                    currentWindCFProfile,
                    currentOffshoreWindCFProfile,
                    activePotentialGeneration,
                    currentBaselineStorage,
                    currentHydroCF,
                    countrySelect.value
                );

                customBaselineSystemCost = newBaselineResult.systemCost;
                customBaselineConsumerCost = calculateAnnualConsumerCost(newBaselineResult.hourlyMarginalPrice, newBaselineResult.demand);
                // Calculate yearly CO2 by multiplying each hour by days in that month
                let co2Total = 0;
                newBaselineResult.emissions.forEach((value, i) => {
                    const monthIndex = Math.floor(i / 24) % 12;
                    co2Total += value * DAYS_IN_MONTH[monthIndex];
                });
                customBaselineTotalAnnualCO2 = co2Total;

                // Return the simulation result so we can display it without re-running
                return newBaselineResult;
            }

            // --- EVENT LISTENERS ---
            function updateUndoRedoButtons() {
                undoButton.disabled = historyIndex <= 0;
                redoButton.disabled = historyIndex >= stateHistory.length - 1;
            }

            function saveState() {
                const currentState = {};
                for (const key in sliders) {
                    currentState[key] = sliders[key].value;
                }
                currentState.enabledTech = { ...enabledTechnologies };
                currentState.demandProfile = [...currentDemand];
                currentState.solarCFProfile = [...currentSolarCFProfile];
                currentState.windCFProfile = [...currentWindCFProfile];
                currentState.offshoreWindCFProfile = [...currentOffshoreWindCFProfile];
                currentState.demandProfileName = currentDemandProfileName;
                currentState.cfProfileName = currentCFProfileName;
                currentState.hydroCF = currentHydroCF;

                stateHistory = stateHistory.slice(0, historyIndex + 1);
                stateHistory.push(currentState);
                historyIndex++;
                updateUndoRedoButtons();
            }

            function syncInputs(sourceElement, targetElement) {
                targetElement.value = sourceElement.value;
            }

            function setupInputSyncing() {
                for (const key in sliders) {
                    const slider = sliders[key];
                    const input = inputs[key];

                    // All sliders behave the same way - just run simulation
                    // Baseline only updates when "Make Default" is clicked
                    slider.addEventListener('input', () => {
                        syncInputs(slider, input);
                        runSimulation();
                    });

                    input.addEventListener('input', () => {
                        let value = parseFloat(input.value);
                        const min = parseFloat(slider.min);
                        const max = parseFloat(slider.max);
                        if (isNaN(value)) value = min;
                        if (value > max) value = max;
                        if (value < min) value = min;
                        input.value = value;
                        syncInputs(input, slider);
                        runSimulation();
                    });

                    slider.addEventListener('change', saveState);
                    input.addEventListener('change', saveState);
                }
            }


            // Initialize system with monthly profiles (replaces old seasonal applySeason function)
            function initializeWithMonthlyProfiles(country = null) {
                const selectedCountry = country || countrySelect.value;

                // Set profile names to indicate monthly data is being used
                currentDemandProfileName = "Monthly Profiles";
                currentCFProfileName = "Monthly Profiles";
                if (currentDemandProfileText) currentDemandProfileText.textContent = currentDemandProfileName;

                // Set hydro CF to a default (average of seasonal values)
                currentHydroCF = 0.35; // Average of spring/summer/fall/winter

                // Initialize baseline with monthly profiles
                updateBaselineForCountry(selectedCountry, 'monthly-default');

                setDemandEditMode(false);
                setCFEditMode(false);
                saveState();
            }

            // Legacy function kept for backward compatibility - redirects to monthly profile initialization
            function applySeason(profileName) {
                // Legacy function - redirects to monthly profiles
                initializeWithMonthlyProfiles();
            }



            if (editDemandBtn) {
                editDemandBtn.addEventListener('click', () => {
                    originalDemandBeforeEdit = [...currentDemand];
                    setDemandEditMode(true);
                });
            }

            if (revertDemandBtn) {
                revertDemandBtn.addEventListener('click', () => {
                    generationChart.data.datasets.find(ds => ds.label === 'Demand').data = [...originalDemandBeforeEdit];
                    generationChart.update('none');
                });
            }

            if (confirmDemandBtn) {
                confirmDemandBtn.addEventListener('click', () => {
                    currentDemand = [...generationChart.data.datasets.find(ds => ds.label === 'Demand').data];
                    currentDemandProfileName = "User Defined";
                    currentDemandProfileText.textContent = currentDemandProfileName;
                    setDemandEditMode(false);
                    runSimulation();
                    saveState();
                });
            }

            // Seasonal preset buttons removed - now using monthly profiles
            // Legacy code kept for backward compatibility with other regions

            // Download generation data as CSV
            const downloadGenerationBtn = document.getElementById('downloadGenerationBtn');
            if (downloadGenerationBtn) {
                downloadGenerationBtn.addEventListener('click', () => {
                    if (!latestGenerationData) {
                        alert('No generation data available. Please run a simulation first.');
                        return;
                    }

                    const { generation, demand, country } = latestGenerationData;

                    // Build CSV content
                    let csv = 'Hour,Month,';
                    const technologies = Object.keys(generation).sort();
                    csv += technologies.join(',') + ',Demand (GW)\n';

                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

                    for (let i = 0; i < 288; i++) {
                        const monthIndex = Math.floor(i / 24);
                        const hourOfDay = i % 24;

                        csv += `${hourOfDay},${monthNames[monthIndex]},`;

                        // Add generation values for each technology
                        csv += technologies.map(tech => generation[tech][i].toFixed(4)).join(',');

                        // Add demand
                        csv += `,${demand[i].toFixed(4)}\n`;
                    }

                    // Create download
                    const blob = new Blob([csv], { type: 'text/csv' });
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `generation_profile_${country}_${new Date().toISOString().split('T')[0]}.csv`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);

                    console.log('âœ“ Generation profile exported to CSV');
                });
            }

            if (editCFBtn) {
                editCFBtn.addEventListener('click', () => {
                    originalSolarCFBeforeEdit = [...capacityFactorChart.data.datasets[0].data];
                    originalWindCFBeforeEdit = [...capacityFactorChart.data.datasets[1].data];
                    originalOffshoreWindCFBeforeEdit = [...capacityFactorChart.data.datasets[2].data];
                    setCFEditMode(true);
                });
            }

            if (revertCFBtn) {
                revertCFBtn.addEventListener('click', () => {
                    capacityFactorChart.data.datasets[0].data = [...originalSolarCFBeforeEdit];
                    capacityFactorChart.data.datasets[1].data = [...originalWindCFBeforeEdit];
                    capacityFactorChart.data.datasets[2].data = [...originalOffshoreWindCFBeforeEdit];
                    capacityFactorChart.update('none');
                });
            }

            if (confirmCFBtn) {
                confirmCFBtn.addEventListener('click', () => {
                    currentSolarCFProfile = [...capacityFactorChart.data.datasets[0].data];
                    currentWindCFProfile = [...capacityFactorChart.data.datasets[1].data];
                    currentOffshoreWindCFProfile = [...capacityFactorChart.data.datasets[2].data];
                    currentCFProfileName = "User Defined";

                    setCFEditMode(false);
                    runSimulation();
                    saveState();
                });
            }



            resetToZeroButton.addEventListener('click', () => {
                Object.keys(sliders).forEach(key => {
                    if (key === 'exportPrice') {
                        sliders[key].value = 20;
                        inputs[key].value = 20;
                    } else {
                        sliders[key].value = 0;
                        inputs[key].value = 0;
                    }
                });
                runSimulation();
                saveState();
            });

            makeDefaultButton.addEventListener('click', () => {
                userDefaultState = {};
                for (const key in sliders) {
                    userDefaultState[key] = sliders[key].value;
                }
                userDefaultState.enabledTech = { ...enabledTechnologies };
                userDefaultState.demandProfile = [...currentDemand];
                userDefaultState.solarCFProfile = [...currentSolarCFProfile];
                userDefaultState.windCFProfile = [...currentWindCFProfile];
                userDefaultState.offshoreWindCFProfile = [...currentOffshoreWindCFProfile];
                userDefaultState.demandProfileName = currentDemandProfileName;
                userDefaultState.cfProfileName = currentCFProfileName;
                userDefaultState.hydroCF = currentHydroCF;

                // Set the new baseline (runs simulation once)
                setNewBaselineFromCurrentState();

                userDefaultState.baselineCost = customBaselineSystemCost;
                userDefaultState.baselineCO2 = customBaselineTotalAnnualCO2;

                // Run normal simulation to update display
                // This may show 1-2% difference due to iterative optimization, which is acceptable
                runSimulation();

                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50';
                modal.innerHTML = `
                    <div class="bg-white p-6 rounded-lg shadow-2xl text-center">
                        <p class="text-lg font-semibold text-gray-800">Current settings saved as user default.</p>
                    </div>
                `;
                document.body.appendChild(modal);
                setTimeout(() => modal.remove(), 2500);
            });

            resetToDefaultButton.addEventListener('click', () => {
                const isUserDefaultAvailable = Object.keys(userDefaultState).length > 0;

                if (isUserDefaultAvailable) {
                    restoreState(userDefaultState);
                    saveState();
                } else {
                    applySeason(currentSystemDefaultProfileName);
                }
            });

            function restoreState(state) {
                currentDemand = [...state.demandProfile];
                currentSolarCFProfile = [...state.solarCFProfile];
                currentWindCFProfile = [...state.windCFProfile];
                currentOffshoreWindCFProfile = [...state.offshoreWindCFProfile];
                currentDemandProfileName = state.demandProfileName;
                currentCFProfileName = state.cfProfileName;
                currentHydroCF = state.hydroCF;
                currentDemandProfileText.textContent = currentDemandProfileName;

                for (const key in state) {
                    if (sliders[key] && inputs[key]) {
                        sliders[key].value = state[key];
                        inputs[key].value = state[key];
                    }
                }
                if (state.enabledTech) {
                    for (const tech in state.enabledTech) {
                        const checkbox = document.getElementById(`toggle-${tech}`);
                        if (checkbox) {
                            checkbox.checked = state.enabledTech[tech];
                            enabledTechnologies[tech] = state.enabledTech[tech];
                        }
                    }
                }
                runSimulation();
                updateUndoRedoButtons();
            }

            undoButton.addEventListener('click', () => {
                if (historyIndex > 0) {
                    historyIndex--;
                    restoreState(stateHistory[historyIndex]);
                }
            });

            redoButton.addEventListener('click', () => {
                if (historyIndex < stateHistory.length - 1) {
                    historyIndex++;
                    restoreState(stateHistory[historyIndex]);
                }
            });

            // --- INITIALIZATION & DYNAMIC CONTENT ---

            function populateCountryDropdown() {
                countrySelect.innerHTML = '';
                const caOption = document.createElement('option');
                caOption.value = "California";
                caOption.textContent = "California";
                countrySelect.appendChild(caOption);

                for (const country in countryGridMixData) {
                    if (country !== "California") {
                        const option = document.createElement('option');
                        option.value = country;
                        option.textContent = country;
                        countrySelect.appendChild(option);
                    }
                }
                countrySelect.value = "California";
            }

            function updateBaselineForCountry(countryName, profileName) {
                let newCarbonTax = 0;
                let countryData = countryGridMixData[countryName];

                if (!countryData) {
                    console.error(`No data for country: ${countryName}`);
                    return;
                }

                newCarbonTax = carbonTaxes[countryName] || 0;

                if (currentDemandProfileName !== 'User Defined') {
                    // Handle monthly profiles (new default approach)
                    if (profileName === 'monthly-default') {
                        const monthlyDemand = getMonthlyDemand(countryName);
                        // Use June (month index 5) as representative display profile (peak solar month)
                        currentDemand = monthlyDemand[5];
                    } else {
                        // Legacy seasonal profile handling
                        const nameParts = profileName.split('-');
                        const baseSeason = nameParts[0];
                        const profileType = nameParts[1];

                        // For California, use JSON profiles directly (same calculation as Grid Dispatch Test)
                        if (countryName === 'California' && CALIFORNIA_PROFILES[profileName]) {
                            const profile = CALIFORNIA_PROFILES[profileName];
                            const peakMW = profile.peakMW;
                            const hourlyPercentages = profile.hourlyPercentages;

                            // Match tester's calculation: (pct / 100) * peakMW, then convert to GW
                            currentDemand = hourlyPercentages.map(pct => (pct / 100) * (peakMW / 1000));
                        } else {
                            // For other countries, use scaling approach
                            const TYPICAL_DAY_SCALING_FACTORS = {
                                spring: 0.79, summer: 0.82, fall: 0.77, winter: 0.73
                            };

                            const hourlyPercentages = SEASONAL_DEMAND_PROFILES[profileName] || SEASONAL_DEMAND_PROFILES[`${baseSeason}-high`];
                            const scalingFactor = profileType === 'typical' ? TYPICAL_DAY_SCALING_FACTORS[baseSeason] || 1.0 : 1.0;
                            const peakLoadMW = countryData.peakLoadsMW[baseSeason] || countryData.peakLoadsMW.summer;
                            const peakPercentage = Math.max(...hourlyPercentages);
                            currentDemand = hourlyPercentages.map(pct => (pct / peakPercentage) * (peakLoadMW / 1000) * scalingFactor);
                        }
                    }
                }

                currentCountryInstalledCapacity = {};
                for (const tech in COST_DATA.capacity_factor) {
                    const techCapacityGW = (countryData.totalCapacityMW / 1000) * ((countryData.mix[tech] || 0) / 100);
                    currentCountryInstalledCapacity[tech] = techCapacityGW;
                }

                currentBaselineStorage = countryData.storageGWh || {};

                // Get base 24-hour profiles for this country
                const baseProfiles24h = {
                    solar: (countryProfiles[countryName] || countryProfiles.default).solar,
                    wind: (countryProfiles[countryName] || countryProfiles.default).wind,
                    offshoreWind: (countryProfiles[countryName] || countryProfiles.default).offshoreWind
                };

                const potentialGeneration = {};
                for (const tech in currentCountryInstalledCapacity) {
                    potentialGeneration[tech] = Array(24).fill(0);
                    const cf = COST_DATA.capacity_factor[tech];
                    let capacity = currentCountryInstalledCapacity[tech];

                    if (tech === 'solar') {
                        for (let i = 0; i < 24; i++) potentialGeneration.solar[i] = capacity * baseProfiles24h.solar[i];
                    } else if (tech === 'wind') {
                        for (let i = 0; i < 24; i++) potentialGeneration.wind[i] = capacity * baseProfiles24h.wind[i];
                    } else if (tech === 'offshoreWind') {
                        for (let i = 0; i < 24; i++) potentialGeneration.offshoreWind[i] = capacity * baseProfiles24h.offshoreWind[i];
                    } else if (tech === 'hydro') {
                        for (let i = 0; i < 24; i++) potentialGeneration.hydro[i] = capacity;
                    } else if (tech === 'naturalGas' || tech === 'coal') {
                        for (let i = 0; i < 24; i++) potentialGeneration[tech][i] = capacity * 1.0;
                    } else {
                        for (let i = 0; i < 24; i++) potentialGeneration[tech][i] = capacity * cf;
                    }
                }
                BASELINE_POTENTIAL_GENERATION = potentialGeneration;

                Object.keys(sliders).forEach(key => {
                    sliders[key].value = 0;
                    inputs[key].value = 0;
                });

                sliders.carbonTax.value = newCarbonTax;
                inputs.carbonTax.value = newCarbonTax;

                const newExportPrice = countryData.defaultExportPrice ?? 20;
                sliders.exportPrice.value = newExportPrice;
                inputs.exportPrice.value = newExportPrice;

                const allTechs = [...Object.keys(COST_DATA.capacity_factor), 'battery4hr', 'battery8hr', 'longduration'];
                allTechs.forEach(tech => {
                    const checkbox = document.getElementById(`toggle-${tech}`);
                    if (checkbox) {
                        checkbox.checked = true;
                        enabledTechnologies[tech] = true;
                    }
                });

                // Construct 12-month profiles for baseline calculation (matching runSimulation logic)
                const baseProfiles = {
                    solar: (countryProfiles[countryName] || countryProfiles.default).solar,
                    wind: (countryProfiles[countryName] || countryProfiles.default).wind,
                    offshoreWind: (countryProfiles[countryName] || countryProfiles.default).offshoreWind
                };

                const fullSolarProfile = [];
                const fullWindProfile = [];
                const fullOffshoreWindProfile = [];
                const fullDemand = [];
                let fullPotentialGeneration = {};
                for (const tech in BASELINE_POTENTIAL_GENERATION) {
                    fullPotentialGeneration[tech] = [];
                }

                // Build VRE and demand profiles from monthly profiles
                const monthlyProfiles = getMonthlyProfiles(countryName);
                const monthlyDemand = getMonthlyDemand(countryName);

                // Get base CF peaks for ratio scaling
                const baseCFPeaks = {
                    solar: Math.max(...baseProfiles.solar),           // ~0.9
                    wind: Math.max(...baseProfiles.wind),             // ~0.65
                    offshoreWind: Math.max(...baseProfiles.offshoreWind)  // ~0.62
                };

                for (let m = 0; m < 12; m++) {
                    fullSolarProfile.push(...monthlyProfiles.solar[m]);
                    fullWindProfile.push(...monthlyProfiles.wind[m]);
                    fullOffshoreWindProfile.push(...monthlyProfiles.offshoreWind[m]);
                    fullDemand.push(...monthlyDemand[m]);

                    // Apply monthly capacity factor scaling to baseline VRE generation
                    for (const tech in BASELINE_POTENTIAL_GENERATION) {
                        const baselineProfile24h = BASELINE_POTENTIAL_GENERATION[tech] || Array(24).fill(0);

                        // Scale VRE technologies by ratio: (monthly peak CF) / (base peak CF)
                        // This avoids double-applying CF since baselineProfile24h already has base CF applied
                        if (tech === 'solar' && monthlyProfiles.solar) {
                            const monthPeakCF = Math.max(...monthlyProfiles.solar[m]);
                            const scalingRatio = monthPeakCF / baseCFPeaks.solar;
                            fullPotentialGeneration[tech].push(...baselineProfile24h.map(val => val * scalingRatio));
                        } else if (tech === 'wind' && monthlyProfiles.wind) {
                            const monthPeakCF = Math.max(...monthlyProfiles.wind[m]);
                            const scalingRatio = monthPeakCF / baseCFPeaks.wind;
                            fullPotentialGeneration[tech].push(...baselineProfile24h.map(val => val * scalingRatio));
                        } else if (tech === 'offshoreWind' && monthlyProfiles.offshoreWind) {
                            const monthPeakCF = Math.max(...monthlyProfiles.offshoreWind[m]);
                            const scalingRatio = monthPeakCF / baseCFPeaks.offshoreWind;
                            fullPotentialGeneration[tech].push(...baselineProfile24h.map(val => val * scalingRatio));
                        } else {
                            // Non-VRE technologies: keep as-is
                            fullPotentialGeneration[tech].push(...baselineProfile24h);
                        }
                    }
                }

                currentDemand = fullDemand; // Update global currentDemand

                const baselineResult = getSimulationResult(
                    {
                        capacity: { solar: 0, wind: 0, offshoreWind: 0, geothermal: 0, nuclear: 0, biomass: 0, rng: 0, hydrogen: 0, battery4hr: 0, battery8hr: 0, longduration: 0, dac: 0, demandflex: 0 },
                        incentives: { solar: 0, wind: 0, offshoreWind: 0, geothermal: 0, nuclear: 0, biomass: 0, rng: 0, hydrogen: 0, storage: 0, dac: 0, carbonTax: newCarbonTax, exportPrice: newExportPrice }
                    },
                    fullSolarProfile,
                    fullWindProfile,
                    fullOffshoreWindProfile,
                    fullPotentialGeneration,
                    currentBaselineStorage,
                    currentHydroCF,
                    countryName
                );
                customBaselineSystemCost = baselineResult.systemCost;
                customBaselineConsumerCost = calculateAnnualConsumerCost(baselineResult.hourlyMarginalPrice, baselineResult.demand); // NEW
                // Calculate yearly CO2 by multiplying each hour by days in that month
                let co2Total = 0;
                baselineResult.emissions.forEach((value, i) => {
                    const monthIndex = Math.floor(i / 24) % 12;
                    co2Total += value * DAYS_IN_MONTH[monthIndex];
                });
                customBaselineTotalAnnualCO2 = co2Total;

                systemDefaultState = {};
                for (const key in sliders) {
                    systemDefaultState[key] = sliders[key].value;
                }
                systemDefaultState.enabledTech = { ...enabledTechnologies };
                userDefaultState = {};

                let totalDefaultCapacity = 0;
                for (const tech in currentCountryInstalledCapacity) {
                    defaultCapacityMix[tech] = currentCountryInstalledCapacity[tech];
                    totalDefaultCapacity += currentCountryInstalledCapacity[tech];
                }

                if (totalDefaultCapacity > 0) {
                    for (const tech in defaultCapacityMix) {
                        defaultCapacityMix[tech] = (defaultCapacityMix[tech] / totalDefaultCapacity) * 100;
                    }
                }

                let totalDefaultGeneration = 0;
                for (const tech in baselineResult.generation) {
                    if (tech !== 'curtailment' && !tech.includes('ToStorage')) {
                        // Calculate yearly generation by multiplying each hour by days in that month
                        let gen = 0;
                        baselineResult.generation[tech].forEach((value, i) => {
                            const monthIndex = Math.floor(i / 24) % 12;
                            gen += value * DAYS_IN_MONTH[monthIndex];
                        });
                        defaultGenerationMix[tech] = gen;
                        totalDefaultGeneration += gen;
                    }
                }
                if (totalDefaultGeneration > 0) {
                    for (const tech in defaultGenerationMix) {
                        defaultGenerationMix[tech] = (defaultGenerationMix[tech] / totalDefaultGeneration) * 100;
                    }
                }
                runSimulation();
            }

            countrySelect.addEventListener('change', (e) => {
                applySeason(currentSystemDefaultProfileName);
            });

            document.addEventListener('mousemove', (e) => {
                hoverTooltip.style.left = e.pageX + 15 + 'px';
                hoverTooltip.style.top = e.pageY + 15 + 'px';
            });

            gridMixSlidersContainer.addEventListener('mouseover', (e) => {
                const row = e.target.closest('.mix-slider-row');
                if (!row) return;
                const tech = row.dataset.tech;
                if (!tech) return;

                const baselineCapacity = currentCountryInstalledCapacity[tech] || 0;
                const newCapacity = (sliders[tech] ? parseFloat(sliders[tech].value) : 0) || 0;
                const totalCapacity = baselineCapacity + newCapacity;

                hoverTooltip.innerHTML = `Total Capacity: ${totalCapacity.toFixed(2)} GW`;
                hoverTooltip.classList.remove('hidden');
            });
            gridMixSlidersContainer.addEventListener('mouseout', () => {
                hoverTooltip.classList.add('hidden');
            });

            generationMixSlidersContainer.addEventListener('mouseover', (e) => {
                const row = e.target.closest('.mix-slider-row');
                if (!row) return;
                const tech = row.dataset.tech;
                if (!tech || yearlyGenerationTotalsGWh[tech] === undefined) return;

                const totalGWh = yearlyGenerationTotalsGWh[tech];
                const label = tech === 'curtailment' ? 'Total Yearly Curtailment' : 'Total Yearly Generation';
                hoverTooltip.innerHTML = `${label}: ${totalGWh.toFixed(2)} GWh`;
                hoverTooltip.classList.remove('hidden');
            });
            generationMixSlidersContainer.addEventListener('mouseout', () => {
                hoverTooltip.classList.add('hidden');
            });


            // --- INPUT SYNCING ---
            // This function connects sliders and input boxes to runSimulation
            function setupInputSyncing() {
                // Debounce function to limit how often simulation runs during rapid slider movements
                let debounceTimeout = null;
                const debouncedRunSimulation = () => {
                    if (debounceTimeout) clearTimeout(debounceTimeout);
                    debounceTimeout = setTimeout(() => {
                        runSimulation();
                    }, 150); // 150ms debounce - adjust as needed for responsiveness
                };

                // Connect each slider and input pair
                let connectedCount = 0;
                for (const key in sliders) {
                    if (sliders[key] && inputs[key]) {
                        connectedCount++;
                        // Slider -> Input sync + run simulation
                        sliders[key].addEventListener('input', (e) => {
                            inputs[key].value = e.target.value;
                            debouncedRunSimulation();
                        });

                        // Input -> Slider sync + run simulation  
                        inputs[key].addEventListener('input', (e) => {
                            // Handle empty or invalid input - treat as 0
                            const value = parseFloat(e.target.value);
                            if (isNaN(value) || e.target.value === '') {
                                sliders[key].value = 0;
                            } else {
                                sliders[key].value = value;
                            }
                            debouncedRunSimulation();
                        });

                        // On blur (focus lost), save state for undo/redo
                        sliders[key].addEventListener('change', () => {
                            saveState();
                        });
                        inputs[key].addEventListener('change', () => {
                            saveState();
                        });
                    }
                }
            }

            // --- TUTORIAL LOGIC ---
            const tutorialSteps = [
                {
                    title: 'Welcome to the Grid Simulator!',
                    text: 'This interactive tool lets you explore pathways to a zero-carbon electricity grid. Let\'s take a quick tour of the main features.',
                    position: 'center'
                },
                {
                    element: '#tutorial-step-2',
                    title: 'Live Simulation Charts',
                    text: 'These charts show the real-time results of your decisions. See how the generation mix and CO2 emissions change as you adjust the levers.',
                    position: 'right',
                    highlightClass: 'rounded-lg'
                },
                {
                    element: '#tutorial-step-3',
                    title: 'Your Control Panel',
                    text: 'This is where you make things happen! Use these sliders to deploy new technologies, set government incentives, and choose a starting grid mix.',
                    position: 'left',
                    highlightClass: 'rounded-lg'
                },
                {
                    element: '#tutorial-step-4',
                    title: 'Manage Existing Resources',
                    text: 'Use these checkboxes to turn off an existing resource type and watch the impact it has on emissions and costs.',
                    position: 'right',
                    highlightClass: 'rounded-lg'
                },
                {
                    element: '#make-default-button',
                    title: 'Save Your Scenario',
                    text: 'Once you find a set of policies you like, you can save them as your new default. The cost metrics will then be calculated relative to this new baseline.',
                    position: 'top',
                    highlightClass: 'rounded-full'
                },
                {
                    element: '#tutorial-step-5',
                    title: 'Key Outcome Metrics',
                    text: 'Your goal is to get CO2 emissions to zero while keeping costs low. These cards show the impact on electricity bills and the cost of avoiding CO2.',
                    position: 'bottom',
                    highlightClass: 'rounded-lg'
                },
                {
                    element: '#edit-demand-btn',
                    title: 'Customize Demand',
                    text: 'Click the edit icon to create your own custom daily demand profile, or select a seasonal preset.',
                    position: 'left',
                    highlightClass: 'rounded-full'
                },
                {
                    element: '#edit-cf-btn',
                    title: 'Customize Weather',
                    text: 'Click this edit icon to change the hourly performance of solar and wind to simulate different weather conditions.',
                    position: 'top',
                    highlightClass: 'rounded-full'
                }
            ];

            let currentStep = 0;
            const overlay = document.getElementById('tutorial-overlay');
            const popover = document.getElementById('tutorial-popover');
            const titleEl = document.getElementById('tutorial-title');
            const textEl = document.getElementById('tutorial-text');
            const prevBtn = document.getElementById('tutorial-prev');
            const nextBtn = document.getElementById('tutorial-next');
            const skipBtn = document.getElementById('tutorial-skip');
            let highlightedElement = null;

            function startTutorial() {
                if (localStorage.getItem('gridSimulatorTutorialSeen')) {
                    return;
                }
                document.body.classList.add('tutorial-active');
                currentStep = 0;
                showTutorialStep(currentStep);
            }

            function endTutorial() {
                document.body.classList.remove('tutorial-active');
                overlay.style.display = 'none';
                popover.style.display = 'none';
                if (highlightedElement) {
                    highlightedElement.classList.remove('tutorial-highlight-active', 'rounded-full', 'rounded-lg');
                }
                localStorage.setItem('gridSimulatorTutorialSeen', 'true');
            }

            function positionPopover(targetElement, popoverEl, position) {
                popoverEl.style.visibility = 'hidden';
                popoverEl.style.display = 'block';

                const popoverRect = popoverEl.getBoundingClientRect();
                const margin = 15;

                if (position === 'center' || !targetElement) {
                    popoverEl.style.left = '50%';
                    popoverEl.style.top = '50%';
                    popoverEl.style.transform = 'translate(-50%, -50%)';
                    popoverEl.style.visibility = 'visible';
                    return;
                }

                const targetRect = targetElement.getBoundingClientRect();
                let top, left;

                switch (position) {
                    case 'top':
                        top = targetRect.top - popoverRect.height - margin;
                        left = targetRect.left + (targetRect.width / 2) - (popoverRect.width / 2);
                        break;
                    case 'bottom':
                        top = targetRect.bottom + margin;
                        left = targetRect.left + (targetRect.width / 2) - (popoverRect.width / 2);
                        break;
                    case 'left':
                        top = targetRect.left - popoverRect.width - margin;
                        left = targetRect.top + (targetRect.height / 2) - (popoverRect.height / 2);
                        break;
                    case 'right':
                    default:
                        top = targetRect.top + (targetRect.height / 2) - (popoverRect.height / 2);
                        left = targetRect.right + margin;
                        break;
                }

                if (top < margin) top = margin;
                if (left < margin) left = margin;
                if (left + popoverRect.width > window.innerWidth - margin) {
                    left = window.innerWidth - popoverRect.width - margin;
                }
                if (top + popoverRect.height > window.innerHeight - margin) {
                    top = window.innerHeight - popoverRect.height - margin;
                }

                popoverEl.style.top = `${top}px`;
                popoverEl.style.left = `${left}px`;
                popoverEl.style.transform = 'none';
                popoverEl.style.visibility = 'visible';
            }

            function showTutorialStep(stepIndex) {
                if (stepIndex < 0 || stepIndex >= tutorialSteps.length) {
                    endTutorial();
                    return;
                }

                const step = tutorialSteps[stepIndex];

                if (highlightedElement) {
                    highlightedElement.classList.remove('tutorial-highlight-active', 'rounded-full', 'rounded-lg');
                    highlightedElement = null;
                }

                titleEl.textContent = step.title;
                textEl.textContent = step.text;

                let targetElement;
                if (step.element) {
                    targetElement = document.querySelector(step.element);
                }

                if (targetElement) {
                    overlay.style.display = 'none';
                    highlightedElement = targetElement;
                    highlightedElement.classList.add('tutorial-highlight-active');
                    if (step.highlightClass) {
                        highlightedElement.classList.add(step.highlightClass);
                    }

                    highlightedElement.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });

                    setTimeout(() => {
                        positionPopover(highlightedElement, popover, step.position);
                    }, 400);
                } else {
                    overlay.style.display = 'block';
                    positionPopover(null, popover, 'center');
                }

                prevBtn.style.display = stepIndex === 0 ? 'none' : 'inline-block';
                nextBtn.textContent = stepIndex === tutorialSteps.length - 1 ? 'Finish' : 'Next';
            }

            nextBtn.addEventListener('click', () => {
                currentStep++;
                showTutorialStep(currentStep);
            });

            prevBtn.addEventListener('click', () => {
                currentStep--;
                showTutorialStep(currentStep);
            });

            skipBtn.addEventListener('click', endTutorial);

            startTutorialBtn.addEventListener('click', () => {
                localStorage.removeItem('gridSimulatorTutorialSeen');
                startTutorial();
            });


            // ============================================
            // CAPACITY EXPANSION OPTIMIZATION MODULE
            // ============================================

            // ===== OPTIMIZATION CONFIGURATION =====
            const OPTIMIZATION_CONFIG = {
                MAX_ITERATIONS: 1000,         // Increased from 500 for better convergence
                NUM_CANDIDATES: 5,
                TECHNOLOGIES: ['solar', 'wind', 'offshoreWind', 'nuclear', 'geothermal', 'biomass', 'rng', 'hydrogen',
                    'battery4hr', 'battery8hr', 'longduration', 'dac'],
                BOUNDS: {
                    solar: [0, 100],          // GW
                    wind: [0, 80],            // GW
                    offshoreWind: [0, 50],    // GW
                    nuclear: [0, 30],         // GW
                    geothermal: [0, 5],       // GW (limited by resource availability)
                    biomass: [0, 3],          // GW (limited by sustainable feedstock)
                    rng: [0, 20],             // GW
                    hydrogen: [0, 20],        // GW
                    battery4hr: [0, 100],     // GWh
                    battery8hr: [0, 100],     // GWh
                    longduration: [0, 200],   // GWh
                    dac: [0, 10000]           // tons/hr
                },
                RESERVE_MARGIN_TARGET: 0.20,  // 20% reserve margin (Flexible capacity > 120% of Peak)
                MAX_CURTAILMENT_RATE: 0.20,   // 20% (matches UI checkbox)
                CO2_TOLERANCE: 0.02,          // 2% tolerance for CO2 constraint (relaxed from 1%)
                MIN_DISPATCHABLE_CAPACITY: 10, // GW - minimum firm capacity (relaxed from 15)
                // VRE Effective Load Carrying Capability (ELCC) for reserve margin
                // Based on CAISO resource adequacy values at moderate penetration levels
                ELCC: {
                    solar: 0.15,         // 15% capacity credit (decreases with penetration)
                    wind: 0.25,          // 25% capacity credit
                    offshoreWind: 0.35   // 35% capacity credit (more consistent output)
                }
            };

            // ===== SEEDED PRNG (Mulberry32) =====
            // Deterministic pseudo-random number generator for reproducible optimization results.
            // Same seed always produces the same sequence of random numbers.
            function mulberry32(seed) {
                let state = seed | 0;
                return function() {
                    state = (state + 0x6D2B79F5) | 0;
                    let t = Math.imul(state ^ (state >>> 15), 1 | state);
                    t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
                    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
                };
            }

            // Global seeded RNG instance - initialized before each optimization run
            let seededRandom = mulberry32(42); // default seed

            function initializeRNG(seed) {
                seededRandom = mulberry32(seed);
            }

            // ===== HELPER FUNCTIONS =====

            /**
             * Enforce capacity bounds for all technologies
             */
            function enforceCapacityBounds(solution, checkOnly = false) {
                const bounded = checkOnly ? true : {};
                let allValid = true;

                for (const tech of OPTIMIZATION_CONFIG.TECHNOLOGIES) {
                    const value = solution[tech] || 0;
                    const [min, max] = OPTIMIZATION_CONFIG.BOUNDS[tech];

                    if (value < min || value > max) {
                        allValid = false;
                    }

                    if (!checkOnly) {
                        bounded[tech] = Math.max(min, Math.min(max, value));
                    }
                }

                return checkOnly ? allValid : bounded;
            }

            /**
             * Calculate reserve margin (dispatchable capacity / peak demand)
             */
            function calculateReserveMargin(capacity, demandData, baselineCapacity, baselineStorage = {}) {
                const peakDemand = Math.max(...demandData);

                // Helper to safely ensure we get a number, ignoring arrays/objects
                const getVal = (obj, key) => {
                    if (!obj) return 0;
                    const val = obj[key];
                    if (typeof val === 'number') return val;
                    if (typeof val === 'string') return parseFloat(val) || 0;
                    return 0; // Arrays and objects return 0
                };

                // Flexible Resources: RNG, Hydrogen, Hydro, Natural Gas, Storage
                // VRE (solar, wind, offshore wind) excluded from reserve margin

                const flexibleCapacity =
                    // NEW flexible generation
                    getVal(capacity, 'rng') +
                    getVal(capacity, 'hydrogen') +
                    getVal(capacity, 'naturalGas') +
                    getVal(capacity, 'hydro') +
                    // NEW storage (power capacity)
                    (getVal(capacity, 'battery4hr') / 4) +
                    (getVal(capacity, 'battery8hr') / 8) +
                    (getVal(capacity, 'longduration') / 24) +
                    // BASELINE flexible generation
                    getVal(baselineCapacity, 'rng') +
                    getVal(baselineCapacity, 'hydrogen') +
                    getVal(baselineCapacity, 'naturalGas') +
                    getVal(baselineCapacity, 'hydro') +
                    // BASELINE storage (power capacity)
                    (getVal(baselineStorage, 'battery4hr') / 4) +
                    (getVal(baselineStorage, 'battery8hr') / 8) +
                    (getVal(baselineStorage, 'longduration') / 24);

                return (flexibleCapacity / peakDemand) - 1.0;
            }

            /**
             * Calculate annual CO2 emissions from generation profile
             */
            function calculateAnnualCO2(emissionsProfile) {
                let totalCO2 = 0;
                const hoursPerMonth = 24;

                for (let i = 0; i < emissionsProfile.length; i++) {
                    const monthIndex = Math.floor(i / hoursPerMonth) % 12;
                    totalCO2 += emissionsProfile[i] * DAYS_IN_MONTH[monthIndex];
                }

                return totalCO2;  // in kg CO2
            }

            /**
             * Calculate curtailment rate from simulation result
             */
            function calculateCurtailmentRate(simulationResult) {
                const hoursPerMonth = 24;
                let totalGeneration = 0;
                let totalCurtailment = 0;

                for (let i = 0; i < simulationResult.generation.solar.length; i++) {
                    const monthIndex = Math.floor(i / hoursPerMonth) % 12;
                    const daysInMonth = DAYS_IN_MONTH[monthIndex];

                    // Sum all generation (EXCLUDING curtailment which isn't generation)
                    for (const tech in simulationResult.generation) {
                        if (tech !== 'curtailment') {  // FIX: Don't include curtailment in generation sum
                            totalGeneration += simulationResult.generation[tech][i] * daysInMonth;
                        }
                    }

                    // Sum curtailment
                    totalCurtailment += simulationResult.generation.curtailment[i] * daysInMonth;
                }

                return totalCurtailment / (totalGeneration + totalCurtailment);
            }

            /**
             * Estimate current CO2 emissions from a capacity solution (quick approximation)
             */
            function estimateCurrentCO2(solution) {
                // Use full simulation (cached) for accurate CO2 estimate
                // This is critical for the "Capacity Removal" logic to work correctly
                if (!optimizationContext) return 38e9;

                // We use a dummy targetCO2 since we only want the absolute emission value
                const result = evaluateSolutionFull(solution, 0);
                return result.annualCO2;
            }

            /**
             * Get current curtailment rate from a solution (requires full simulation)
             */
            function getCurrentCurtailmentRate(solution) {
                // Run a quick simulation to get curtailment
                try {
                    if (!optimizationContext) return 0;

                    // Pass only NEW capacity (solution), not total
                    const capacityInputs = {
                        capacity: solution,
                        incentives: optimizationContext.incentives
                    };

                    const result = getSimulationResult(
                        capacityInputs,
                        optimizationContext.solarProfile,
                        optimizationContext.windProfile,
                        optimizationContext.offshoreWindProfile,
                        optimizationContext.potentialGen,
                        optimizationContext.baselineStorage,
                        optimizationContext.hydroCF,
                        optimizationContext.countryName
                    );

                    return calculateCurtailmentRate(result);
                } catch (error) {
                    console.warn('Error calculating curtailment rate:', error);
                    return 0;
                }
            }

            /**
             * Estimate baseline fossil CO2 emissions
             */
            function estimateBaselineFossilCO2() {
                // Get current emissions from the current state
                try {
                    if (!optimizationContext) return 38e9;  // Fallback if context not set

                    // IMPORTANT: Pass ZERO new capacity to get baseline emissions
                    // The simulation adds potentialGen (baseline) + inputs.capacity (new)
                    // So to get just baseline, we pass zero for inputs.capacity
                    const zeroCapacity = {
                        solar: 0, wind: 0, offshoreWind: 0, nuclear: 0, geothermal: 0,
                        biomass: 0, rng: 0, hydrogen: 0, battery4hr: 0, battery8hr: 0,
                        longduration: 0, dac: 0, hydro: 0, naturalGas: 0, coal: 0, demandflex: 0
                    };

                    const result = getSimulationResult(
                        { capacity: zeroCapacity, incentives: optimizationContext.incentives },
                        optimizationContext.solarProfile,
                        optimizationContext.windProfile,
                        optimizationContext.offshoreWindProfile,
                        optimizationContext.potentialGen,
                        optimizationContext.baselineStorage,
                        optimizationContext.hydroCF,
                        optimizationContext.countryName
                    );

                    const annualCO2 = calculateAnnualCO2(result.emissions);

                    return annualCO2;
                } catch (error) {
                    console.error('Error estimating baseline CO2:', error);
                    console.error('Stack:', error.stack);
                    // Fallback estimate
                    return 38e9;  // kg CO2/year (roughly California's grid emissions)
                }
            }

            /**
             * Perturb solution to escape local minimum
             */
            function perturbSolution(solution, iteration, targetCO2) {
                const perturbed = { ...solution };

                // Determine number of perturbations based on iteration
                const numPerturbs = Math.min(3, Math.floor(iteration / 100) + 1);

                for (let i = 0; i < numPerturbs; i++) {
                    // Filter out DAC using same logic as generateCandidates
                    const allowedTechs = OPTIMIZATION_CONFIG.TECHNOLOGIES.filter(t => {
                        // User disabled DAC entirely
                        if (t === 'dac' && window.optimizerOptions && !window.optimizerOptions.allowDAC) return false;

                        // Same logic as generateCandidates: skip DAC for easy targets
                        if (t === 'dac' && targetCO2) {
                            const baselineCO2 = estimateBaselineFossilCO2();
                            const targetDifficulty = targetCO2 / baselineCO2;
                            const currentCurtailment = getCurrentCurtailmentRate(solution);
                            const isAggressiveTarget = targetDifficulty < 0.60;
                            const isHittingCurtailmentLimit = currentCurtailment > 0.15;
                            if (!isAggressiveTarget && !isHittingCurtailmentLimit) return false;
                        }

                        return true;
                    });

                    if (allowedTechs.length === 0) {
                        console.log('[perturbSolution] No allowed technologies for perturbation!');
                        return perturbed;
                    }

                    const tech = allowedTechs[
                        Math.floor(seededRandom() * allowedTechs.length)
                    ];

                    // Scaling factor for perturbation
                    // Use larger perturbation for DAC to avoid "dust"
                    let scale = 1.0;
                    if (tech === 'dac') scale = 20.0;
                    if (tech.includes('battery') || tech === 'longduration') scale = 2.0;

                    // Random perturbation Â±2 GW (scaled)
                    const delta = (seededRandom() - 0.5) * 4.0 * scale;
                    perturbed[tech] = Math.max(0, (perturbed[tech] || 0) + delta);
                }

                return enforceCapacityBounds(perturbed);
            }

            // ===== SOLUTION EVALUATION =====

            // Cache for solution evaluations to avoid redundant calculations
            let solutionCache = new Map();
            let cacheHits = 0;
            let cacheMisses = 0;

            /**
             * Generate a hash key for a solution (for caching)
             */
            function hashSolution(solution) {
                // Round values to 0.1 precision for caching
                const rounded = {};
                for (const tech of OPTIMIZATION_CONFIG.TECHNOLOGIES) {
                    const value = solution[tech] || 0;
                    rounded[tech] = Math.round(value * 10) / 10;
                }
                return JSON.stringify(rounded);
            }

            /**
             * Clear the solution cache (call between optimization runs)
             */
            function clearSolutionCache() {
                solutionCache.clear();
                cacheHits = 0;
                cacheMisses = 0;
            }

            /**
             * Evaluate a capacity solution by running full dispatch simulation (with caching)
             */
            function evaluateSolutionFull(solution, targetCO2, useCache = true) {
                // Check cache first
                if (useCache) {
                    const hash = hashSolution(solution);
                    if (solutionCache.has(hash)) {
                        cacheHits++;
                        return solutionCache.get(hash);
                    }
                    cacheMisses++;
                }

                // Perform actual evaluation
                const result = evaluateSolutionFullUncached(solution, targetCO2);

                // Store in cache
                if (useCache) {
                    const hash = hashSolution(solution);
                    solutionCache.set(hash, result);
                }

                return result;
            }

            /**
             * Evaluate a capacity solution by running full dispatch simulation (no caching)
             */
            function evaluateSolutionFullUncached(solution, targetCO2) {
                try {
                    if (!optimizationContext) {
                        throw new Error('Optimization context not initialized');
                    }

                    // Build capacity object for existing simulation
                    // IMPORTANT: inputs.capacity should contain ONLY NEW capacity additions (solution)
                    // - potentialGen already contains baseline generation (line 2019: currentPotential = JSON.parse(JSON.stringify(potentialGen)))
                    // - Line 2042 ADDS inputs.capacity to currentPotential: currentPotential.solar[i] += inputs.capacity.solar * solarProfile[i]
                    // - Lines 2051 (hydro) and 2172 (naturalGas) also add currentCountryInstalledCapacity separately
                    // - Cost function expects capacity=NEW, baselineCapacity=baseline (line 1878-1880)
                    const capacityInputs = {
                        capacity: {
                            // ALL technologies: Pass only NEW capacity additions from optimization
                            solar: solution.solar || 0,
                            wind: solution.wind || 0,
                            offshoreWind: solution.offshoreWind || 0,
                            nuclear: solution.nuclear || 0,
                            geothermal: solution.geothermal || 0,
                            biomass: solution.biomass || 0,
                            rng: solution.rng || 0,
                            hydrogen: solution.hydrogen || 0,
                            battery4hr: solution.battery4hr || 0,
                            battery8hr: solution.battery8hr || 0,
                            longduration: solution.longduration || 0,
                            dac: solution.dac || 0,
                            hydro: solution.hydro || 0,
                            naturalGas: solution.naturalGas || 0,
                            coal: solution.coal || 0,
                            demandflex: solution.demandflex || 0
                        },
                        incentives: optimizationContext.incentives
                    };

                    // Run existing dispatch simulation
                    const simulationResult = getSimulationResult(
                        capacityInputs,
                        optimizationContext.solarProfile,
                        optimizationContext.windProfile,
                        optimizationContext.offshoreWindProfile,
                        optimizationContext.potentialGen,
                        optimizationContext.baselineStorage,
                        optimizationContext.hydroCF,
                        optimizationContext.countryName
                    );

                    // Debug: Check if simulation result is valid
                    if (!simulationResult || !simulationResult.emissions) {
                        console.error('Invalid simulation result:', simulationResult);
                        throw new Error('Simulation result missing emissions data');
                    }

                    // Calculate system cost
                    const systemCost = calculateTotalAnnualSystemCost(
                        simulationResult.generation,
                        capacityInputs.capacity,
                        optimizationContext.incentives,
                        simulationResult.generation.curtailment,
                        optimizationContext.baselineCapacity,
                        optimizationContext.baselineStorage,
                        simulationResult.gasGenDetails
                    );

                    // Calculate metrics
                    const annualCO2 = calculateAnnualCO2(simulationResult.emissions);

                    // Debug: Check if CO2 calculation is valid
                    if (isNaN(annualCO2)) {
                        console.error('Annual CO2 is NaN. Emissions profile:', simulationResult.emissions.slice(0, 5));
                        throw new Error('CO2 calculation returned NaN');
                    }
                    const reserveMargin = calculateReserveMargin(capacityInputs.capacity, optimizationContext.demand, optimizationContext.baselineCapacity, optimizationContext.baselineStorage);
                    const curtailmentRate = calculateCurtailmentRate(simulationResult);

                    // Calculate unmet energy
                    let unmetEnergy = 0;
                    const hoursPerMonth = 24;
                    for (let i = 0; i < simulationResult.generation.solar.length; i++) {
                        const monthIndex = Math.floor(i / hoursPerMonth) % 12;
                        let totalGen = 0;
                        for (const tech in simulationResult.generation) {
                            if (tech !== 'curtailment') {
                                totalGen += simulationResult.generation[tech][i];
                            }
                        }
                        const deficit = Math.max(0, optimizationContext.demand[i] - totalGen);
                        unmetEnergy += deficit * DAYS_IN_MONTH[monthIndex];
                    }

                    // Check feasibility
                    const feasibility = checkFeasibility(
                        simulationResult,
                        capacityInputs.capacity,
                        annualCO2,
                        targetCO2
                    );

                    return {
                        systemCost,
                        annualCO2,
                        isFeasible: feasibility.isFeasible,
                        metrics: {
                            reserveMargin,
                            curtailmentRate,
                            unmetEnergy
                        },
                        feasibility: feasibility,
                        simulationResult
                    };
                } catch (error) {
                    console.error('Error evaluating solution:', error);
                    return {
                        systemCost: Infinity,
                        annualCO2: Infinity,
                        isFeasible: false,
                        metrics: {
                            reserveMargin: 0,
                            curtailmentRate: 0,
                            unmetEnergy: Infinity
                        },
                        error: error.message
                    };
                }
            }

            /**
             * Quick feasibility check before full evaluation (for performance)
             */
            function quickFeasibilityCheck(solution, targetCO2) {
                if (!optimizationContext) return false;

                // QUICK CHECK 1: Total capacity (NEW + BASELINE)
                // CRITICAL FIX: Must include baseline capacity, not just new capacity!
                const newCapacity = Object.values(solution).reduce((a, b) => (a || 0) + (b || 0), 0);
                const baselineCapacity = Object.values(optimizationContext.baselineCapacity || {}).reduce((a, b) => (a || 0) + (b || 0), 0);
                const totalCapacity = newCapacity + baselineCapacity;
                const peakDemand = Math.max(...optimizationContext.demand);

                if (totalCapacity < peakDemand * 0.3) {
                    return false;  // Obviously insufficient (relaxed from 0.5 to 0.3)
                }

                // QUICK CHECK 2: Don't make things worse
                // Only reject if estimated CO2 is WORSE than baseline (i.e., adding capacity increases emissions)
                // This was too strict before - it rejected candidates making progress toward target
                // Removed this check entirely to allow exploration

                // QUICK CHECK 3: Bounds check
                if (!enforceCapacityBounds(solution, true)) {
                    return false;  // Exceeds technology limits
                }

                return true;  // Passed quick checks, worth full evaluation
            }

            /**
             * Check if a solution meets all feasibility constraints
             */
            function checkFeasibility(simulationResult, capacity, annualCO2, targetCO2) {
                const checks = {
                    co2: false,
                    energyBalance: false,
                    reserveMargin: false,
                    curtailment: false
                };

                // 1. CO2 CONSTRAINT (HARD - User preference: must meet)
                checks.co2 = annualCO2 <= targetCO2 * (1 + OPTIMIZATION_CONFIG.CO2_TOLERANCE);

                // 2. ENERGY BALANCE (all hours)
                const hoursPerMonth = 24;
                let unmetEnergy = 0;
                for (let i = 0; i < simulationResult.generation.solar.length; i++) {
                    const monthIndex = Math.floor(i / hoursPerMonth) % 12;
                    let totalGen = 0;
                    for (const tech in simulationResult.generation) {
                        if (tech !== 'curtailment') {
                            totalGen += simulationResult.generation[tech][i];
                        }
                    }
                    const deficit = Math.max(0, optimizationContext.demand[i] - totalGen);
                    unmetEnergy += deficit * DAYS_IN_MONTH[monthIndex];
                }
                checks.energyBalance = unmetEnergy < 0.01;  // Negligible unmet (< 10 MWh/year)

                // 3. RESERVE MARGIN (20% flexible capacity above peak)
                const reserveMargin = calculateReserveMargin(capacity, optimizationContext.demand, optimizationContext.baselineCapacity, optimizationContext.baselineStorage);
                checks.reserveMargin = reserveMargin >= OPTIMIZATION_CONFIG.RESERVE_MARGIN_TARGET * 0.96;  // Allow 4% tolerance (19.2% minimum)

                // 4. CURTAILMENT (hard constraint only if user enabled it)
                const curtailmentRate = calculateCurtailmentRate(simulationResult);
                checks.curtailment = curtailmentRate <= OPTIMIZATION_CONFIG.MAX_CURTAILMENT_RATE * 1.05;  // 5% tolerance

                // Overall feasibility: Hard constraints must pass
                // Curtailment is only a hard constraint if respectCurtailment option is enabled
                const respectCurtailment = window.optimizerOptions?.respectCurtailment !== false;  // Default true for safety
                const isFeasible = checks.co2 && checks.energyBalance && checks.reserveMargin &&
                    (respectCurtailment ? checks.curtailment : true);

                return {
                    isFeasible,
                    checks,
                    reasons: {
                        co2: checks.co2 ? null : `CO2 ${(annualCO2 / 1e9).toFixed(1)} million MT exceeds target ${(targetCO2 / 1e9).toFixed(1)} million MT`,
                        energyBalance: checks.energyBalance ? null : `Unmet energy: ${unmetEnergy.toFixed(2)} GWh`,
                        reserveMargin: checks.reserveMargin ? null : `Reserve margin ${(reserveMargin * 100).toFixed(1)}% below ${(OPTIMIZATION_CONFIG.RESERVE_MARGIN_TARGET * 100).toFixed(0)}% target`,
                        curtailment: checks.curtailment ? null : `High curtailment: ${(curtailmentRate * 100).toFixed(1)}%`
                    }
                };
            }

            // ===== MARGINAL LCOE CALCULATION =====

            /**
             * Calculate marginal LCOE with system value adjustments
             * This guides the optimization by prioritizing technologies based on cost and system value
             */
            function calculateMarginalLCOEWithSystemValue(currentSolution, targetCO2, iteration = 0) {
                const baseLCOE = {};

                // Calculate base LCOE for each technology
                for (const tech of OPTIMIZATION_CONFIG.TECHNOLOGIES) {
                    if (tech === 'dac') {
                        // DAC has different cost structure ($/ton captured, not $/MWh)
                        // Estimate LCOE based on CO2 reduction value
                        const dacCapex = COST_DATA.capex.dac;  // $/ton/year capacity
                        const dacFixedOM = COST_DATA.fixed_om.dac;  // $/ton/year
                        const dacVariableOM = COST_DATA.variable_om.dac;  // $/ton captured
                        const lifetime = COST_DATA.lifetime.dac;
                        const CRF = (0.07 * Math.pow(1.07, lifetime)) / (Math.pow(1.07, lifetime) - 1);

                        // Cost per ton CO2 captured
                        const costPerTonCO2 = dacCapex * CRF + dacFixedOM + dacVariableOM;

                        // Convert to equivalent LCOE assuming carbon value
                        baseLCOE[tech] = costPerTonCO2 / 0.395;  // 395 kg CO2/MWh for NG â†’ $/MWh equivalent
                        continue;
                    }

                    // Use marginal CAPEX (cost of next GW) for supply-curve technologies
                    const currentDeploymentGW = (currentSolution[tech] || 0) +
                        ((optimizationContext && optimizationContext.baselineCapacity) ? (optimizationContext.baselineCapacity[tech] || 0) : 0);
                    const capex = getMarginalCapex(tech, currentDeploymentGW);
                    const fixedOM = COST_DATA.fixed_om[tech];
                    const variableOM = COST_DATA.variable_om[tech];
                    const lifetime = COST_DATA.lifetime[tech];
                    const capacityFactor = COST_DATA.capacity_factor[tech];

                    if (!lifetime || !capacityFactor) continue;

                    const CRF = (0.07 * Math.pow(1.07, lifetime)) / (Math.pow(1.07, lifetime) - 1);

                    // For storage, use $/kWh capacity cost
                    if (tech.includes('battery') || tech === 'longduration') {
                        const duration = tech === 'longduration' ? 24 : parseInt(tech.match(/\d+/)[0]);
                        // Cost per kW of power capacity
                        const costPerKW = capex * duration;  // $/kWh * hours = $/kW
                        const annualDischarges = 250;  // Assume 250 cycles/year
                        const annualGenerationPerKW = annualDischarges * duration;  // kWh/kW-year

                        baseLCOE[tech] = (
                            (costPerKW * CRF + fixedOM) / annualGenerationPerKW +
                            variableOM / 1000
                        );
                    } else {
                        // Standard generation technologies
                        const annualGeneration = 8760 * capacityFactor;  // MWh/MW-year

                        baseLCOE[tech] = (
                            (capex * 1000 * CRF + fixedOM * 1000) / annualGeneration +
                            variableOM / 1000
                        );
                    }
                }

                // Adjust for system value (captures flexibility & timing)
                const adjustedLCOE = { ...baseLCOE };

                // Penalty for high curtailment sources
                const currentCurtailment = getCurrentCurtailmentRate(currentSolution);
                if (currentCurtailment > 0.10) {  // >10% curtailment
                    adjustedLCOE.solar *= (1 + currentCurtailment);
                    adjustedLCOE.wind *= (1 + currentCurtailment * 0.5);
                    adjustedLCOE.offshoreWind *= (1 + currentCurtailment * 0.3);
                }

                // Bonus for dispatchable/flexible capacity if reserve margin is low
                // Bonus for dispatchable/flexible capacity if reserve margin is low
                const reserveMargin = calculateReserveMargin(currentSolution, optimizationContext.demand, optimizationContext.baselineCapacity, optimizationContext.baselineStorage);
                if (reserveMargin < OPTIMIZATION_CONFIG.RESERVE_MARGIN_TARGET) {
                    // CRITICAL PRIORITY: If margin is unsafe (e.g. < 15%), we MUST build flexible capacity
                    // Heavily discount LCOE to force selection
                    // NOTE: Biomass is NOT considered flexible for reserve margin purposes
                    const flexibleTechs = ['battery4hr', 'battery8hr', 'longduration', 'hydrogen', 'rng'];
                    flexibleTechs.forEach(tech => {
                        if (adjustedLCOE[tech]) {
                            adjustedLCOE[tech] *= 0.1; // 90% discount to force selection
                        }
                    });
                    // Also slightly discount firm baseload as it helps too (though less efficiently for peaking)
                    adjustedLCOE.geothermal *= 0.5;
                    adjustedLCOE.nuclear *= 0.5;
                }

                // Bonus for emissions reduction if far from target
                const currentCO2 = estimateCurrentCO2(currentSolution);
                const co2Gap = currentCO2 - targetCO2;
                if (co2Gap > 0) {
                    // Prioritize zero-carbon sources
                    const zeroCarbon = ['solar', 'wind', 'offshoreWind', 'nuclear', 'geothermal'];
                    zeroCarbon.forEach(tech => {
                        if (adjustedLCOE[tech]) {
                            adjustedLCOE[tech] *= 0.9;  // 10% discount
                        }
                    });

                    // Extra bonus for DAC only if VERY far from target and near tech limits
                    // (prevents DAC from being suggested for mild targets)
                    if (co2Gap > targetCO2 * 1.5) {
                        adjustedLCOE.dac *= 0.7;  // 30% discount for DAC
                    }
                }

                return adjustedLCOE;
            }

            // ===== CANDIDATE GENERATION =====

            /**
             * Generate candidate solutions based on marginal LCOE and heuristics
             */
            function generateCandidates(currentSolution, marginalLCOE, iteration, targetCO2) {
                const candidates = [];

                // Refined step sizes for better convergence (scaled for 1000 iterations)
                // We go much finer in later iterations to allow Solar/Wind to fill small gaps
                // UPDATED: Use smaller initial steps (2.0 instead of 5.0) to avoid overshooting targets
                const baseStep = iteration < 200 ? 2.0 :
                    iteration < 400 ? 1.0 :
                        iteration < 600 ? 0.5 :
                            iteration < 800 ? 0.2 : 0.1;

                const techs = OPTIMIZATION_CONFIG.TECHNOLOGIES;

                // Helper to get tech-specific step size
                // Normalize economic impact of steps: 
                // 0.05 GW Solar (~$5M/yr) vs 0.05 t/hr DAC (~$0.2k/yr) -> DAC would always win tiny gaps
                // We scale DAC step up so its minimum chunk is economically significant (~1 t/hr)
                function getTechStep(tech) {
                    if (tech === 'dac') return baseStep * 20.0;
                    if (tech.includes('battery') || tech === 'longduration') return baseStep * 2.0;
                    return baseStep;
                }

                // 1. SYSTEMATIC NEIGHBORHOOD SEARCH
                for (const tech of techs) {
                    if (marginalLCOE[tech] === Infinity) continue;

                    // Respect usage constraints
                    if (tech === 'dac' && window.optimizerOptions && !window.optimizerOptions.allowDAC) continue;

                    // CRITICAL FIX: Don't allow DAC for "easy" targets that can be achieved with conventional clean tech
                    // DAC should only be used when we're truly constrained (very aggressive target or hitting curtailment limits)
                    // Rule: Only allow DAC if target is <60% of baseline (very aggressive) OR we're hitting high curtailment (>15%)
                    if (tech === 'dac') {
                        const baselineCO2 = estimateBaselineFossilCO2();
                        const targetDifficulty = targetCO2 / baselineCO2;  // 1.0 = no reduction, 0.0 = zero emissions
                        const currentCurtailment = getCurrentCurtailmentRate(currentSolution);

                        // Allow DAC only if:
                        // 1. Target is very aggressive (<60% of baseline, i.e., >40% reduction), OR
                        // 2. We're hitting curtailment limits (>15%)
                        const isAggressiveTarget = targetDifficulty < 0.60;
                        const isHittingCurtailmentLimit = currentCurtailment > 0.15;

                        if (!isAggressiveTarget && !isHittingCurtailmentLimit) {
                            continue;  // Skip DAC
                        }
                    }

                    const effectiveStep = getTechStep(tech);

                    // Option A: Add capacity
                    const cAdd = { ...currentSolution };
                    cAdd[tech] = (cAdd[tech] || 0) + effectiveStep;
                    candidates.push(enforceCapacityBounds(cAdd));

                    // Option B: Remove capacity (only if it exists)
                    if ((currentSolution[tech] || 0) > 0.001) {
                        const cRem = { ...currentSolution };
                        // If capacity is smaller than effectiveStep, remove ALL of it (fix for "orphaned" small capacities from perturbations)
                        // Otherwise, remove by step size
                        if ((cRem[tech] || 0) < effectiveStep) {
                            cRem[tech] = 0;
                        } else {
                            cRem[tech] = Math.max(0, (cRem[tech] || 0) - effectiveStep);
                        }
                        candidates.push(enforceCapacityBounds(cRem));
                    }
                }

                // 2. TARGET-SPECIFIC HEURISTICS
                const currentCO2 = estimateCurrentCO2(currentSolution);

                // If we're significantly BELOW the CO2 target, try to reduce expensive capacity to lower cost
                // while allowing CO2 to increase towards the target
                if (targetCO2 && currentCO2 < targetCO2 * 0.95) {
                    // Calculate how much CO2 "room" we have
                    const co2Gap = targetCO2 - currentCO2;
                    const co2GapPercent = (co2Gap / targetCO2) * 100;

                    // CRITICAL: Only cut NON-FLEXIBLE technologies to avoid breaking reserve margin
                    // Flexible resources (batteries, RNG, hydrogen) are needed to meet 20% reserve margin
                    const flexibleTechs = ['battery4hr', 'battery8hr', 'longduration', 'rng', 'hydrogen', 'naturalGas', 'hydro'];
                    const nonFlexibleTechs = techs.filter(t => !flexibleTechs.includes(t));

                    // SMART CUTTING: Prioritize cutting clean baseload (nuclear, geothermal, biomass) over VRE (solar, wind)
                    // Baseload cuts are less likely to cause curtailment violations
                    const baseloadTechs = ['nuclear', 'geothermal', 'biomass'];
                    const vreTechs = ['solar', 'wind', 'offshoreWind'];

                    // Try cutting baseload first
                    const availableBaseload = nonFlexibleTechs
                        .filter(t => baseloadTechs.includes(t) && (currentSolution[t] || 0) > 0.5)
                        .sort((a, b) => (marginalLCOE[b] || 0) - (marginalLCOE[a] || 0));

                    // If no baseload available and we're far from target (>20%), try VRE
                    const availableVRE = (co2GapPercent > 20) ? nonFlexibleTechs
                        .filter(t => vreTechs.includes(t) && (currentSolution[t] || 0) > 1.0)
                        .sort((a, b) => (marginalLCOE[b] || 0) - (marginalLCOE[a] || 0)) : [];

                    const expensiveTechs = [...availableBaseload, ...availableVRE];

                    if (expensiveTechs.length === 0) {
                        // No non-flexible techs to cut - skip
                    } else {
                        // Cut top 2 most expensive NON-FLEXIBLE techs with conservative step size
                        for (let i = 0; i < Math.min(2, expensiveTechs.length); i++) {
                            const tCut = expensiveTechs[i];
                            const cCut = { ...currentSolution };
                            // Conservative cut size to avoid constraint violations
                            const cutMultiplier = Math.min(5, 1 + (co2GapPercent / 10));  // Reduced from max=10
                            cCut[tCut] = Math.max(0, (cCut[tCut] || 0) - getTechStep(tCut) * cutMultiplier);
                            candidates.push(enforceCapacityBounds(cCut));
                        }
                    }
                }

                // 3. MINIMAL RANDOM EXPLORATION
                const allowedTechs = techs.filter(t => t !== 'dac' || (window.optimizerOptions && window.optimizerOptions.allowDAC));
                const randomTech = allowedTechs[Math.floor(seededRandom() * allowedTechs.length)];

                if (randomTech) {
                    const cRand = { ...currentSolution };
                    const randStep = getTechStep(randomTech);
                    // Neutral bias (0.5) to avoid drift
                    cRand[randomTech] = Math.max(0, (cRand[randomTech] || 0) + (seededRandom() - 0.5) * randStep);
                    candidates.push(enforceCapacityBounds(cRand));
                }

                return candidates;
            }

            // ===== LOCAL REFINEMENT (NELDER-MEAD) =====

            /**
             * Nelder-Mead simplex optimization for local refinement
             * Fine-tunes the solution found by heuristic search
             */
            async function nelderMeadRefinement(initialSolution, targetCO2, options = {}) {
                const maxIterations = options.maxIterations || 50;
                const progressCallback = options.progressCallback || null;
                const alpha = 1.0;   // Reflection coefficient
                const gamma = 2.0;   // Expansion coefficient
                const rho = 0.5;     // Contraction coefficient
                const sigma = 0.5;   // Shrink coefficient

                // Include active technologies + promising inactive ones for exploration
                const activeTechs = OPTIMIZATION_CONFIG.TECHNOLOGIES.filter(tech =>
                    (initialSolution[tech] || 0) > 0.01
                );
                // Also include up to 3 inactive technologies (sorted by lowest LCOE) for exploration
                const inactiveTechs = OPTIMIZATION_CONFIG.TECHNOLOGIES.filter(tech =>
                    (initialSolution[tech] || 0) <= 0.01 && tech !== 'dac'
                );
                const explorationTechs = inactiveTechs.slice(0, 3);
                const allTechs = [...activeTechs, ...explorationTechs];

                if (allTechs.length === 0) {
                    return initialSolution;
                }

                console.log(`Nelder-Mead refinement starting with ${activeTechs.length} active + ${explorationTechs.length} exploratory technologies`);

                // Initialize simplex (N+1 points for N-dimensional space)
                const simplex = [];
                simplex.push({ solution: { ...initialSolution }, cost: null });

                // Create N additional points by perturbing each dimension
                for (let i = 0; i < allTechs.length; i++) {
                    const point = { ...initialSolution };
                    const tech = allTechs[i];
                    const isStorage = tech.includes('battery') || tech === 'longduration';
                    const isExploration = explorationTechs.includes(tech);

                    let perturbation;
                    if (isExploration) {
                        // For inactive techs, introduce a small positive amount to test if it helps
                        perturbation = isStorage ? 5.0 : 1.0;
                    } else {
                        perturbation = (i % 2 === 0 ? 1.0 : -1.0) * (isStorage ? 2.0 : 0.5);
                    }

                    point[tech] = Math.max(0, (point[tech] || 0) + perturbation);
                    simplex.push({ solution: enforceCapacityBounds(point), cost: null });
                }

                // Evaluate all points in simplex
                for (let i = 0; i < simplex.length; i++) {
                    const result = evaluateSolutionFull(simplex[i].solution, targetCO2);
                    simplex[i].cost = result.isFeasible ? result.systemCost : Infinity;
                    simplex[i].isFeasible = result.isFeasible;
                }

                // Main Nelder-Mead loop
                for (let iter = 0; iter < maxIterations; iter++) {
                    // Yield periodically so the UI can repaint
                    if (iter % 5 === 0) {
                        if (progressCallback) {
                            const nmProgress = 90 + (iter / maxIterations) * 9; // 90% -> 99%
                            progressCallback(nmProgress);
                        }
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }

                    // Sort by cost
                    simplex.sort((a, b) => a.cost - b.cost);

                    const best = simplex[0];
                    const worst = simplex[simplex.length - 1];
                    const secondWorst = simplex[simplex.length - 2];

                    // Check convergence (cost range < 1% of best)
                    if (best.cost < Infinity && worst.cost < Infinity) {
                        const costRange = worst.cost - best.cost;
                        if (costRange / best.cost < 0.01) {
                            console.log(`Nelder-Mead converged at iteration ${iter}`);
                            break;
                        }
                    }

                    // Calculate centroid (excluding worst point)
                    const centroid = {};
                    for (const tech of allTechs) {
                        centroid[tech] = 0;
                        for (let i = 0; i < simplex.length - 1; i++) {
                            centroid[tech] += (simplex[i].solution[tech] || 0);
                        }
                        centroid[tech] /= (simplex.length - 1);
                    }

                    // REFLECTION
                    const reflected = {};
                    for (const tech of allTechs) {
                        reflected[tech] = centroid[tech] + alpha * (centroid[tech] - (worst.solution[tech] || 0));
                    }
                    const reflectedBounded = enforceCapacityBounds(reflected);
                    const reflectedResult = evaluateSolutionFull(reflectedBounded, targetCO2);
                    const reflectedCost = reflectedResult.isFeasible ? reflectedResult.systemCost : Infinity;

                    if (reflectedCost < secondWorst.cost && reflectedCost >= best.cost) {
                        // Accept reflection
                        simplex[simplex.length - 1] = {
                            solution: reflectedBounded,
                            cost: reflectedCost,
                            isFeasible: reflectedResult.isFeasible
                        };
                        continue;
                    }

                    // EXPANSION
                    if (reflectedCost < best.cost) {
                        const expanded = {};
                        for (const tech of allTechs) {
                            expanded[tech] = centroid[tech] + gamma * (reflectedBounded[tech] - centroid[tech]);
                        }
                        const expandedBounded = enforceCapacityBounds(expanded);
                        const expandedResult = evaluateSolutionFull(expandedBounded, targetCO2);
                        const expandedCost = expandedResult.isFeasible ? expandedResult.systemCost : Infinity;

                        if (expandedCost < reflectedCost) {
                            simplex[simplex.length - 1] = {
                                solution: expandedBounded,
                                cost: expandedCost,
                                isFeasible: expandedResult.isFeasible
                            };
                        } else {
                            simplex[simplex.length - 1] = {
                                solution: reflectedBounded,
                                cost: reflectedCost,
                                isFeasible: reflectedResult.isFeasible
                            };
                        }
                        continue;
                    }

                    // CONTRACTION
                    const contracted = {};
                    for (const tech of allTechs) {
                        contracted[tech] = centroid[tech] + rho * ((worst.solution[tech] || 0) - centroid[tech]);
                    }
                    const contractedBounded = enforceCapacityBounds(contracted);
                    const contractedResult = evaluateSolutionFull(contractedBounded, targetCO2);
                    const contractedCost = contractedResult.isFeasible ? contractedResult.systemCost : Infinity;

                    if (contractedCost < worst.cost) {
                        simplex[simplex.length - 1] = {
                            solution: contractedBounded,
                            cost: contractedCost,
                            isFeasible: contractedResult.isFeasible
                        };
                        continue;
                    }

                    // SHRINK
                    for (let i = 1; i < simplex.length; i++) {
                        const shrunk = {};
                        for (const tech of allTechs) {
                            shrunk[tech] = (best.solution[tech] || 0) + sigma * ((simplex[i].solution[tech] || 0) - (best.solution[tech] || 0));
                        }
                        const shrunkBounded = enforceCapacityBounds(shrunk);
                        const shrunkResult = evaluateSolutionFull(shrunkBounded, targetCO2);
                        simplex[i] = {
                            solution: shrunkBounded,
                            cost: shrunkResult.isFeasible ? shrunkResult.systemCost : Infinity,
                            isFeasible: shrunkResult.isFeasible
                        };
                    }
                }

                // Return best solution
                simplex.sort((a, b) => a.cost - b.cost);
                const initialCostEval = evaluateSolutionFull(initialSolution, targetCO2);
                console.log(`Nelder-Mead refinement: $${(initialCostEval.systemCost / 1e9).toFixed(2)}B â†’ $${(simplex[0].cost / 1e9).toFixed(2)}B`);
                return simplex[0].solution;
            }

            // ===== MAIN OPTIMIZATION FUNCTION =====

            /**
             * Main capacity expansion optimization function
             * Finds optimal capacity additions to meet CO2 target at minimum cost
             */
            async function optimizeCapacityExpansion(targetCO2, options = {}) {
                // CRITICAL FIX: Completely disable DAC for easy targets by removing it from TECHNOLOGIES list
                // This ensures it can NEVER enter the solution through any path (generation, perturbation, etc.)
                const initialBaselineCO2 = estimateBaselineFossilCO2();
                const targetDifficulty = targetCO2 / initialBaselineCO2;
                const isEasyTarget = targetDifficulty >= 0.60;  // Target is >60% of baseline (easy)

                // Save original TECHNOLOGIES list to restore later
                const originalTechnologies = [...OPTIMIZATION_CONFIG.TECHNOLOGIES];
                let dacWasDisabled = false;

                if (isEasyTarget && !options.forceAllowDAC) {
                    // Temporarily modify TECHNOLOGIES to exclude DAC
                    OPTIMIZATION_CONFIG.TECHNOLOGIES = OPTIMIZATION_CONFIG.TECHNOLOGIES.filter(t => t !== 'dac');
                    dacWasDisabled = true;
                }

                // Store options globally for use in feasibility checks
                window.optimizerOptions = options;

                // Clear solution cache for this optimization run
                clearSolutionCache();

                // Initialize seeded PRNG for reproducible results
                const rngSeed = options.seed !== undefined ? options.seed : 42;
                initializeRNG(rngSeed);

                // Initialize solution with smart starting point (not zero)
                // Calculate what we need to meet CO2 target
                const baselineCO2 = estimateBaselineFossilCO2();
                const co2Reduction = Math.max(0, baselineCO2 - targetCO2);

                // Initialize with a reasonable starting point
                let currentSolution = {};
                for (const tech of OPTIMIZATION_CONFIG.TECHNOLOGIES) {
                    currentSolution[tech] = 0;
                }

                // Add initial capacity to help algorithm get started
                // Heuristic based on empirical observation: ~1.1 million MT CO2 reduction per GW of clean capacity
                // (from test: 80 GW total â†’ 87 million MT reduction, so 1.09 million MT/GW)
                const totalCleanCapacityNeeded = co2Reduction / 1.1e9;  // GW needed (co2Reduction is in kg, 1.1e9 kg = 1.1 million MT)

                // Split 60/40 between solar and wind (solar is cheaper but more variable)
                const initialSolar = Math.min(100, totalCleanCapacityNeeded * 0.6);
                const initialWind = Math.min(80, totalCleanCapacityNeeded * 0.4);
                const initialBattery = Math.min(50, (initialSolar + initialWind) * 0.25);  // 25% of VRE capacity

                currentSolution.solar = initialSolar;
                currentSolution.wind = initialWind;
                currentSolution.battery4hr = initialBattery;

                // Check reserve margin requirement and add flexible capacity if needed
                const peakDemand = Math.max(...optimizationContext.demand);
                const requiredFlexibleCapacity = peakDemand * 1.2;  // 20% reserve margin means 1.2x peak
                const baselineFlexibleCapacity =
                    (optimizationContext.baselineCapacity.naturalGas || 0) +
                    (optimizationContext.baselineCapacity.hydro || 0) +
                    (optimizationContext.baselineCapacity.rng || 0) +
                    (optimizationContext.baselineCapacity.hydrogen || 0) +
                    ((optimizationContext.baselineStorage?.battery4hr || 0) / 4) +
                    ((optimizationContext.baselineStorage?.battery8hr || 0) / 8) +
                    ((optimizationContext.baselineStorage?.longduration || 0) / 24);

                const flexibleCapacityGap = requiredFlexibleCapacity - baselineFlexibleCapacity;

                if (flexibleCapacityGap > 0) {
                    // Add flexible resources to meet reserve margin
                    // Priority: Battery storage (most flexible) > RNG > Hydrogen
                    const additionalBattery = Math.min(100 - currentSolution.battery4hr, flexibleCapacityGap * 4 * 0.8);  // 80% as 4hr battery
                    const additionalRNG = Math.min(20, flexibleCapacityGap * 0.15);  // 15% as RNG
                    const additionalHydrogen = Math.min(20, flexibleCapacityGap * 0.05);  // 5% as Hydrogen

                    currentSolution.battery4hr += additionalBattery;
                    currentSolution.rng = additionalRNG;
                    currentSolution.hydrogen = additionalHydrogen;
                }

                // ADAPTIVE INITIAL GUESS: If previous optimization was significantly below target, scale down
                // This prevents re-optimization from overshooting again
                // IMPORTANT: Only apply once - track with lastOptimizationWasScaled flag to prevent compounding
                const shouldApplyScaling = window.lastOptimizationCO2 &&
                    window.lastOptimizationCO2 < targetCO2 * 0.95 &&
                    !window.lastOptimizationWasScaled;  // Don't compound scaling

                if (shouldApplyScaling) {
                    const previousGap = targetCO2 - window.lastOptimizationCO2;
                    const previousGapPercent = (previousGap / targetCO2) * 100;

                    // Scale down clean energy capacity proportionally (but not too aggressively)
                    // Limit scaling to max 50% reduction to avoid going too low
                    const scaleFactor = Math.max(0.5, 1.0 - (previousGapPercent / 100));
                    currentSolution.solar *= scaleFactor;
                    currentSolution.wind *= scaleFactor;

                    // Mark that scaling was applied to prevent compounding on next re-optimization
                    window.lastOptimizationWasScaled = true;
                } else {
                    window.lastOptimizationWasScaled = false;
                }

                let bestFeasibleSolution = null;
                let bestFeasibleCost = Infinity;
                let firstFeasibleCost = null;
                let iteration = 0;
                let noImprovementCount = 0;
                let totalFeasibleFound = 0;

                // Progress tracking
                const startTime = Date.now();

                // Main optimization loop
                while (iteration < OPTIMIZATION_CONFIG.MAX_ITERATIONS) {
                    // STEP 1: Calculate marginal LCOE with system value adjustments
                    const marginalLCOE = calculateMarginalLCOEWithSystemValue(
                        currentSolution,
                        targetCO2,
                        iteration
                    );

                    // STEP 2: Generate candidate solutions
                    const candidates = generateCandidates(
                        currentSolution,
                        marginalLCOE,
                        iteration,
                        targetCO2
                    );

                    // STEP 3: Quick feasibility pre-screening
                    const viableCandidates = candidates.filter(c =>
                        quickFeasibilityCheck(c, targetCO2)
                    );

                    // STEP 4: Full evaluation of viable candidates
                    const evaluatedCandidates = [];
                    for (const candidate of viableCandidates) {
                        const result = evaluateSolutionFull(candidate, targetCO2);
                        evaluatedCandidates.push({
                            solution: candidate,
                            cost: result.systemCost,
                            co2: result.annualCO2,
                            isFeasible: result.isFeasible,
                            metrics: result.metrics,
                            feasibility: result.feasibility
                        });
                    }

                    // STEP 5: Select best feasible solution
                    const feasibleCandidates = evaluatedCandidates.filter(c => c.isFeasible);

                    if (feasibleCandidates.length > 0) {
                        totalFeasibleFound += feasibleCandidates.length;

                        // MODIFIED SELECTION CRITERION: When significantly below target, prefer solutions closer to target
                        // even if they cost slightly more. This prevents getting stuck at overly clean solutions.
                        let bestCandidate;
                        if (bestFeasibleSolution && bestFeasibleSolution.co2 < targetCO2 * 0.90) {
                            // We're significantly below target (>10% below) - use weighted objective
                            // Penalize being below target to push towards it
                            bestCandidate = feasibleCandidates.reduce((best, curr) => {
                                const co2GapBest = Math.abs(targetCO2 - best.co2) / targetCO2;
                                const co2GapCurr = Math.abs(targetCO2 - curr.co2) / targetCO2;

                                // Weighted objective: 70% cost, 30% proximity to target
                                const scoreBest = (best.cost / bestFeasibleCost) * 0.7 + co2GapBest * 0.3;
                                const scoreCurr = (curr.cost / bestFeasibleCost) * 0.7 + co2GapCurr * 0.3;

                                return scoreCurr < scoreBest ? curr : best;
                            });
                        } else {
                            // Normal operation - minimize cost
                            bestCandidate = feasibleCandidates.reduce((best, curr) =>
                                curr.cost < best.cost ? curr : best
                            );
                        }

                        const costImproved = bestCandidate.cost < bestFeasibleCost;
                        const co2Improved = bestFeasibleSolution && Math.abs(bestCandidate.co2 - targetCO2) < Math.abs(bestFeasibleSolution.co2 - targetCO2);

                        if (costImproved || co2Improved) {
                            // Determine if this is a meaningful improvement
                            let isMeaningfulImprovement = false;

                            if (costImproved && bestCandidate.cost < bestFeasibleCost * 0.9999) {
                                // Meaningful cost improvement (>0.01%)
                                isMeaningfulImprovement = true;
                            } else if (co2Improved && bestFeasibleSolution) {
                                // Check if CO2 improvement is meaningful (>1% reduction in gap)
                                const oldGap = Math.abs(bestFeasibleSolution.co2 - targetCO2);
                                const newGap = Math.abs(bestCandidate.co2 - targetCO2);
                                const gapReduction = (oldGap - newGap) / oldGap;

                                if (gapReduction > 0.01) {  // >1% reduction in CO2 gap
                                    isMeaningfulImprovement = true;
                                }
                            }

                            if (isMeaningfulImprovement) {
                                noImprovementCount = 0;
                            } else {
                                noImprovementCount++;
                            }

                            currentSolution = bestCandidate.solution;
                            bestFeasibleCost = bestCandidate.cost;
                            bestFeasibleSolution = bestCandidate;
                            if (firstFeasibleCost === null) firstFeasibleCost = bestCandidate.cost;
                        } else {
                            noImprovementCount++;
                        }
                    } else {
                        // FALBACK: If no feasible solution, move towards feasibility (minimize CO2)
                        // This prevents getting stuck in an infeasible local minimum
                        if (evaluatedCandidates.length > 0) {
                            // Find best infeasible candidate to move towards feasibility
                            // PRIORITY 1: If Reserve Margin is the issue, pick highest reserve margin
                            const currentMargin = calculateReserveMargin(currentSolution, optimizationContext.demand, optimizationContext.baselineCapacity, optimizationContext.baselineStorage);

                            let bestInfeasible;

                            if (currentMargin < OPTIMIZATION_CONFIG.RESERVE_MARGIN_TARGET) {
                                // We are failing on reliability -> Maximize Reserve Margin
                                bestInfeasible = evaluatedCandidates.reduce((best, curr) =>
                                    (curr.metrics.reserveMargin > best.metrics.reserveMargin) ? curr : best
                                );
                            } else {
                                // We are failing on CO2 -> Minimize CO2
                                bestInfeasible = evaluatedCandidates.reduce((best, curr) =>
                                    curr.co2 < best.co2 ? curr : best
                                );
                            }

                            // Update current solution to follow the gradient towards feasibility
                            currentSolution = bestInfeasible.solution;

                            // PANIC MODE: If we are failing reserve margin for 20 iters, force add dispatchable
                            if (currentMargin < OPTIMIZATION_CONFIG.RESERVE_MARGIN_TARGET && noImprovementCount > 20) {
                                // Force add flexible capacity to break deadlock
                                // Pick the technology with lowest cost per GW of reserve margin contribution
                                const flexOptions = [
                                    { tech: 'battery4hr', costPerGW: COST_DATA.capex.battery4hr * 4 * 1000, addGWh: 20 },  // 20 GWh = 5 GW power
                                    { tech: 'longduration', costPerGW: COST_DATA.capex.longduration * 24 * 1000, addGWh: 120 }, // 120 GWh = 5 GW power
                                    { tech: 'hydrogen', costPerGW: COST_DATA.capex.hydrogen * 1000, addGW: 5 },
                                    { tech: 'geothermal', costPerGW: COST_DATA.capex.geothermal * 1000, addGW: 5 }
                                ];
                                // Sort by cost per GW of reserve margin and pick cheapest that isn't at bounds
                                flexOptions.sort((a, b) => a.costPerGW - b.costPerGW);
                                for (const opt of flexOptions) {
                                    const currentVal = currentSolution[opt.tech] || 0;
                                    const maxBound = OPTIMIZATION_CONFIG.BOUNDS[opt.tech][1];
                                    const addAmount = opt.addGWh || opt.addGW || 5;
                                    if (currentVal + addAmount <= maxBound) {
                                        currentSolution[opt.tech] = currentVal + addAmount;
                                        break;
                                    }
                                }
                                noImprovementCount = 0; // Reset counter so we don't exit early
                            }
                        }

                        noImprovementCount++;
                    }

                    // STEP 6: Convergence detection and early stopping
                    // If the best cost hasn't improved by even 0.01% for 50 iterations, we've likely converged
                    // EXCEPTION: If we're significantly below target, allow MANY more iterations to find solutions closer to target
                    const isBelowTarget = bestFeasibleSolution && bestFeasibleSolution.co2 < targetCO2 * 0.90;
                    let convergenceThreshold = isBelowTarget ? 200 : 50;  // 4x threshold when below target (increased from 2x)

                    // Additional check: if we're below target but have <3 GW total non-flexible capacity left,
                    // we've hit a physical limit and should stop even if we haven't converged cost-wise
                    if (isBelowTarget && bestFeasibleSolution) {
                        const baseloadCapacityLeft = ['nuclear', 'geothermal', 'biomass']
                            .reduce((sum, tech) => sum + (bestFeasibleSolution.solution[tech] || 0), 0);
                        const nonFlexibleCapacityLeft = ['solar', 'wind', 'offshoreWind', 'nuclear', 'geothermal', 'biomass']
                            .reduce((sum, tech) => sum + (bestFeasibleSolution.solution[tech] || 0), 0);

                        if (baseloadCapacityLeft < 1.0 && nonFlexibleCapacityLeft < 8.0) {
                            convergenceThreshold = 50;  // Reduce threshold to accept solution sooner
                        }
                    }

                    if (bestFeasibleSolution && noImprovementCount > convergenceThreshold) {
                        break;
                    }

                    // STEP 6a: Adaptive exploration - perturb if stuck
                    if (noImprovementCount > 30) {
                        currentSolution = perturbSolution(currentSolution, iteration, targetCO2);
                        // CRITICAL FIX: Do NOT reset noImprovementCount here.
                        // This allows the optimizer to hit the failure threshold (50) and stop
                        // if the perturbation doesn't yield a better result quickly.
                    }

                    // STEP 7: Progress callback
                    if (options.progressCallback) {
                        options.progressCallback(
                            iteration,
                            bestFeasibleCost,
                            bestFeasibleSolution?.co2 || null,
                            {
                                baselineCO2,
                                targetCO2,
                                firstFeasibleCost,
                                noImprovementCount,
                                convergenceThreshold,
                                phase: bestFeasibleSolution ? 'optimizing' : 'searching'
                            }
                        );
                    }

                    iteration++;

                    // Yield control periodically to prevent browser freeze and allow UI updates
                    // Yield every iteration to ensure the user sees 1, 2, 3... count
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                const elapsedTime = (Date.now() - startTime) / 1000;
                console.log(`Optimization complete in ${elapsedTime.toFixed(1)}s (${iteration} iterations)`);

                // STEP 8: Return results
                if (!bestFeasibleSolution) {
                    console.error('No feasible solution found after', iteration, 'iterations');
                    console.error('Total feasible candidates found:', totalFeasibleFound);
                    console.error('Target CO2:', (targetCO2 / 1e9).toFixed(2), 'million MT');
                    console.error('Baseline CO2:', (baselineCO2 / 1e9).toFixed(2), 'million MT');

                    return {
                        success: false,
                        message: "Could not find solution meeting CO2 target. Try: (1) Relax target, (2) Enable DAC, (3) Check if target is achievable.",
                        targetCO2: targetCO2,
                        iterations: iteration
                    };
                }

                // STEP 8a: Local refinement with Nelder-Mead
                // Signal Phase 3 to progress UI
                if (options.progressCallback) {
                    options.progressCallback(iteration, bestFeasibleCost, bestFeasibleSolution?.co2 || null, {
                        baselineCO2, targetCO2, noImprovementCount: 0,
                        convergenceThreshold: 1, phase: 'refining'
                    });
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                const refinedSolution = await nelderMeadRefinement(
                    bestFeasibleSolution.solution,
                    targetCO2,
                    {
                        maxIterations: 150,
                        progressCallback: options.progressCallback ? (nmProgress) => {
                            // Update progress bar during Nelder-Mead (90% -> 99%)
                            const progressBar = document.getElementById('progress-bar');
                            const progressPercent = document.getElementById('progress-percent');
                            if (progressBar) progressBar.style.width = `${Math.round(nmProgress)}%`;
                            if (progressPercent) progressPercent.textContent = `${Math.round(nmProgress)}%`;
                        } : null
                    }
                );

                // Final evaluation to get complete results
                const finalEvaluation = evaluateSolutionFull(refinedSolution, targetCO2);

                // Store optimization results globally for comparison
                window.lastOptimizationCO2 = finalEvaluation.annualCO2;
                window.lastOptimizationCurtailment = finalEvaluation.metrics.curtailmentRate;
                window.lastOptimizationCost = finalEvaluation.systemCost;
                // Note: window.lastOptimizationWasScaled is already set earlier in the function (true if scaled, stays false/undefined otherwise)

                // Restore TECHNOLOGIES list if we modified it
                if (dacWasDisabled) {
                    OPTIMIZATION_CONFIG.TECHNOLOGIES = originalTechnologies;
                }

                return {
                    success: true,
                    solution: refinedSolution,
                    cost: finalEvaluation.systemCost,
                    co2: finalEvaluation.annualCO2,
                    targetCO2: targetCO2,  // Include target for display
                    metrics: finalEvaluation.metrics,
                    feasibility: finalEvaluation.feasibility,
                    iterations: iteration,
                    elapsedTime: elapsedTime
                };
            }


            // ===== MULTI-START OPTIMIZATION WRAPPER =====
            /**
             * Runs the optimizer multiple times with different seeds and returns the best result.
             * This explores different regions of the solution space to avoid local minima.
             * @param {number} targetCO2 - Target CO2 in kg/year
             * @param {object} options - Same options as optimizeCapacityExpansion, plus:
             *   - numStarts: number of optimization runs (default 3)
             */
            async function multiStartOptimization(targetCO2, options = {}) {
                const numStarts = options.numStarts || 3;
                const seeds = [42, 137, 2024]; // deterministic seed set
                let bestResult = null;

                const originalProgressCallback = options.progressCallback;

                for (let run = 0; run < numStarts; run++) {
                    // Wrap progress callback to show run number and scale progress
                    const runProgressCallback = originalProgressCallback ? (iteration, bestCost, currentCO2, context) => {
                        // Add run info to context
                        const augmentedContext = {
                            ...context,
                            multiStartRun: run + 1,
                            multiStartTotal: numStarts
                        };
                        originalProgressCallback(iteration, bestCost, currentCO2, augmentedContext);
                    } : null;

                    const runOptions = {
                        ...options,
                        seed: seeds[run],
                        progressCallback: runProgressCallback
                    };

                    console.log(`\n--- Multi-start run ${run + 1}/${numStarts} (seed=${seeds[run]}) ---`);
                    const result = await optimizeCapacityExpansion(targetCO2, runOptions);

                    if (result.success) {
                        if (!bestResult || result.cost < bestResult.cost) {
                            bestResult = result;
                            console.log(`  New best: $${(result.cost / 1e9).toFixed(2)}B (run ${run + 1})`);
                        } else {
                            console.log(`  Result: $${(result.cost / 1e9).toFixed(2)}B (not better than $${(bestResult.cost / 1e9).toFixed(2)}B)`);
                        }
                    } else {
                        console.log(`  Run ${run + 1} failed to find feasible solution`);
                    }
                }

                if (bestResult) {
                    // Update globals with the best result
                    const finalEval = evaluateSolutionFull(bestResult.solution, targetCO2);
                    window.lastOptimizationCO2 = finalEval.annualCO2;
                    window.lastOptimizationCurtailment = finalEval.metrics.curtailmentRate;
                    window.lastOptimizationCost = finalEval.systemCost;

                    if (originalProgressCallback) {
                        originalProgressCallback('DONE', bestResult.cost, bestResult.co2, null);
                    }
                    return bestResult;
                }

                // All runs failed
                return {
                    success: false,
                    message: "No feasible solution found across all optimization runs. Try: (1) Relax target, (2) Enable DAC, (3) Check if target is achievable.",
                    targetCO2: targetCO2,
                    iterations: 0
                };
            }


            // ============================================
            // COST EDITOR LOGIC
            // ============================================
            function setupCostEditor() {
                const editor = document.getElementById('cost-editor-container');
                const toggleBtn = document.getElementById('toggle-costs-btn');
                const resetBtn = document.getElementById('reset-costs-btn');
                const tableBody = document.getElementById('cost-table-body');
                const discInput = document.getElementById('cost-discount-rate');

                if (!editor || !toggleBtn || !resetBtn || !tableBody || !discInput) return;

                toggleBtn.addEventListener('click', () => {
                    editor.classList.toggle('hidden');
                    if (!editor.classList.contains('hidden')) {
                        renderCostInputs();
                        initializeSupplyCurves();
                        initializeCapacityBounds();
                    }
                });

                resetBtn.addEventListener('click', () => {
                    if (confirm('Reset all cost assumptions to default?')) {
                        COST_DATA = JSON.parse(JSON.stringify(DEFAULT_COST_DATA));
                        renderCostInputs();
                        console.log('Cost assumptions reset to defaults');
                    }
                });

                discInput.addEventListener('change', (e) => {
                    const val = parseFloat(e.target.value);
                    if (!isNaN(val) && val >= 0 && val <= 1) {
                        COST_DATA.discount_rate = val;
                        console.log('Updated discount rate:', val);
                    }
                });

                function renderCostInputs() {
                    tableBody.innerHTML = '';
                    discInput.value = COST_DATA.discount_rate;

                    // Comprehensive list of relevant technologies
                    const techs = [
                        'solar', 'wind', 'offshoreWind',
                        'nuclear', 'geothermal',
                        'biomass', 'rng', 'hydrogen',
                        'battery4hr', 'battery8hr', 'longduration',
                        'dac',
                        'naturalGas', 'coal', 'hydro',
                        'naturalGasCCGT', 'naturalGasCT'
                    ];

                    techs.forEach(tech => {
                        const row = document.createElement('tr');
                        row.className = 'hover:bg-gray-50';

                        // Name cell
                        const nameCell = document.createElement('td');
                        nameCell.className = 'px-3 py-2 font-medium text-gray-900 border-b border-gray-100';
                        nameCell.textContent = formatTechName(tech);
                        row.appendChild(nameCell);

                        // CAPEX
                        row.appendChild(createInputCell(tech, 'capex'));
                        // Fixed O&M
                        row.appendChild(createInputCell(tech, 'fixed_om'));
                        // Variable O&M (special handling for NG objects)
                        row.appendChild(createInputCell(tech, 'variable_om'));
                        // Lifetime
                        row.appendChild(createInputCell(tech, 'lifetime'));

                        tableBody.appendChild(row);
                    });
                }

                function createInputCell(tech, category) {
                    const cell = document.createElement('td');
                    cell.className = 'px-2 py-1 border-b border-gray-100';

                    // Check if value exists
                    let val = COST_DATA[category]?.[tech];

                    if (category === 'variable_om' && (tech === 'naturalGasCCGT' || tech === 'naturalGasCT')) {
                        // Handle object {start, end}
                        if (val && typeof val === 'object') {
                            val = `${val.start}-${val.end}`;
                        }
                    }

                    if (val === undefined) {
                        cell.textContent = '-';
                        cell.className += ' text-gray-400 text-center';
                        return cell;
                    }

                    const input = document.createElement('input');
                    input.type = 'text'; // use text to allow for ranges like "35-80"
                    input.value = val;
                    input.className = 'w-full text-xs border border-gray-300 rounded px-1 py-0.5 focus:ring-1 focus:ring-blue-500';

                    input.addEventListener('change', (e) => {
                        let newVal = e.target.value;

                        if (category === 'variable_om' && (tech === 'naturalGasCCGT' || tech === 'naturalGasCT')) {
                            // Parse range "35-80"
                            if (newVal.includes('-')) {
                                const parts = newVal.split('-').map(s => parseFloat(s.trim()));
                                if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                                    COST_DATA[category][tech] = { start: parts[0], end: parts[1] };
                                    console.log(`Updated ${tech} ${category}:`, COST_DATA[category][tech]);
                                    input.classList.remove('border-red-500');
                                } else {
                                    input.classList.add('border-red-500');
                                }
                            } else {
                                // Single value fallback (start=end)
                                const num = parseFloat(newVal);
                                if (!isNaN(num)) {
                                    COST_DATA[category][tech] = { start: num, end: num };
                                    console.log(`Updated ${tech} ${category}:`, COST_DATA[category][tech]);
                                    input.classList.remove('border-red-500');
                                } else {
                                    input.classList.add('border-red-500');
                                }
                            }
                        } else {
                            // Standard number
                            const num = parseFloat(newVal);
                            if (!isNaN(num)) {
                                COST_DATA[category][tech] = num;
                                console.log(`Updated ${tech} ${category}:`, num);
                                input.classList.remove('border-red-500');
                            } else {
                                input.classList.add('border-red-500');
                            }
                        }
                    });

                    cell.appendChild(input);
                    return cell;
                }

                function formatTechName(tech) {
                    const map = {
                        'solar': 'Solar PV',
                        'wind': 'Onshore Wind',
                        'offshoreWind': 'Offshore Wind',
                        'battery4hr': 'Battery (4hr)',
                        'battery8hr': 'Battery (8hr)',
                        'longduration': 'Long Duration Storage',
                        'naturalGas': 'Natural Gas (Capacity)',
                        'naturalGasCCGT': 'Natural Gas CCGT',
                        'naturalGasCT': 'Natural Gas CT',
                        'coal': 'Coal',
                        'hydro': 'Hydro',
                        'nuclear': 'Nuclear',
                        'geothermal': 'Geothermal',
                        'biomass': 'Biomass',
                        'rng': 'RNG',
                        'hydrogen': 'Hydrogen',
                        'dac': 'Direct Air Capture'
                    };
                    return map[tech] || tech;
                }

                // Initialize supply curve inputs
                function initializeSupplyCurves() {
                    // Geothermal supply curve (3 multipliers)
                    const geoMult1 = document.getElementById('geo-mult-1');
                    const geoMult2 = document.getElementById('geo-mult-2');
                    const geoMult3 = document.getElementById('geo-mult-3');

                    if (geoMult1 && geoMult2 && geoMult3 && SUPPLY_CURVES.geothermal) {
                        geoMult1.value = SUPPLY_CURVES.geothermal[0].multiplier;
                        geoMult2.value = SUPPLY_CURVES.geothermal[1].multiplier;
                        geoMult3.value = SUPPLY_CURVES.geothermal[2].multiplier;

                        geoMult1.addEventListener('change', (e) => {
                            const val = parseFloat(e.target.value);
                            if (!isNaN(val) && val >= 0.5 && val <= 3.0) {
                                SUPPLY_CURVES.geothermal[0].multiplier = val;
                                console.log('Updated geothermal 0-2 GW multiplier:', val);
                                e.target.classList.remove('border-red-500');
                            } else {
                                e.target.classList.add('border-red-500');
                            }
                        });

                        geoMult2.addEventListener('change', (e) => {
                            const val = parseFloat(e.target.value);
                            if (!isNaN(val) && val >= 0.5 && val <= 3.0) {
                                SUPPLY_CURVES.geothermal[1].multiplier = val;
                                console.log('Updated geothermal 2-4 GW multiplier:', val);
                                e.target.classList.remove('border-red-500');
                            } else {
                                e.target.classList.add('border-red-500');
                            }
                        });

                        geoMult3.addEventListener('change', (e) => {
                            const val = parseFloat(e.target.value);
                            if (!isNaN(val) && val >= 0.5 && val <= 3.0) {
                                SUPPLY_CURVES.geothermal[2].multiplier = val;
                                console.log('Updated geothermal 4-5 GW multiplier:', val);
                                e.target.classList.remove('border-red-500');
                            } else {
                                e.target.classList.add('border-red-500');
                            }
                        });
                    }

                    // Biomass supply curve (2 multipliers)
                    const bioMult1 = document.getElementById('bio-mult-1');
                    const bioMult2 = document.getElementById('bio-mult-2');

                    if (bioMult1 && bioMult2 && SUPPLY_CURVES.biomass) {
                        bioMult1.value = SUPPLY_CURVES.biomass[0].multiplier;
                        bioMult2.value = SUPPLY_CURVES.biomass[1].multiplier;

                        bioMult1.addEventListener('change', (e) => {
                            const val = parseFloat(e.target.value);
                            if (!isNaN(val) && val >= 0.5 && val <= 3.0) {
                                SUPPLY_CURVES.biomass[0].multiplier = val;
                                console.log('Updated biomass 0-1.5 GW multiplier:', val);
                                e.target.classList.remove('border-red-500');
                            } else {
                                e.target.classList.add('border-red-500');
                            }
                        });

                        bioMult2.addEventListener('change', (e) => {
                            const val = parseFloat(e.target.value);
                            if (!isNaN(val) && val >= 0.5 && val <= 3.0) {
                                SUPPLY_CURVES.biomass[1].multiplier = val;
                                console.log('Updated biomass 1.5-3 GW multiplier:', val);
                                e.target.classList.remove('border-red-500');
                            } else {
                                e.target.classList.add('border-red-500');
                            }
                        });
                    }
                }

                // Initialize capacity bounds inputs
                function initializeCapacityBounds() {
                    const boundTechs = [
                        'solar', 'wind', 'offshoreWind', 'nuclear',
                        'geothermal', 'biomass', 'rng', 'hydrogen',
                        'battery4hr', 'battery8hr', 'longduration', 'dac'
                    ];

                    boundTechs.forEach(tech => {
                        const input = document.getElementById(`bound-${tech}`);
                        if (input && OPTIMIZATION_CONFIG.BOUNDS[tech]) {
                            // BOUNDS is [min, max] array - we want the max value
                            input.value = OPTIMIZATION_CONFIG.BOUNDS[tech][1];

                            input.addEventListener('change', (e) => {
                                const val = parseFloat(e.target.value);
                                if (!isNaN(val) && val >= 0) {
                                    OPTIMIZATION_CONFIG.BOUNDS[tech][1] = val;
                                    console.log(`Updated ${tech} max bound:`, val);
                                    e.target.classList.remove('border-red-500');
                                } else {
                                    e.target.classList.add('border-red-500');
                                }
                            });
                        }
                    });
                }
            }

            // Initialize editor
            setupCostEditor();

            // --- MAIN INITIALIZATION FUNCTION ---
            async function initialize() {
                // Load California seasonal profiles from JSON
                try {
                    const response = await fetch('../grid-operator/seasonal_profiles.json');
                    const profilesData = await response.json();
                    CALIFORNIA_PROFILES = profilesData.california.profiles;
                    console.log('Loaded California profiles from JSON:', Object.keys(CALIFORNIA_PROFILES));
                } catch (error) {
                    console.error('Error loading California profiles from JSON:', error);
                    console.log('Falling back to scaling method for California');
                }

                try {
                    await signInAnonymously(auth);
                    console.log("Firebase authentication successful.");
                } catch (error) {
                    console.error("Firebase authentication failed:", error);
                    visitorCountEl.textContent = "Auth Failed";
                    return;
                }

                const counterRef = doc(db, `artifacts/${appId}/public/data/counters/visitor_counter`);
                try {
                    const newCount = await runTransaction(db, async (transaction) => {
                        const counterDoc = await transaction.get(counterRef);
                        if (!counterDoc.exists()) {
                            transaction.set(counterRef, { count: 1 });
                            return 1;
                        }
                        const newCount = counterDoc.data().count + 1;
                        transaction.update(counterRef, { count: newCount });
                        return newCount;
                    });
                    visitorCountEl.textContent = newCount.toLocaleString();
                } catch (e) {
                    console.error("Firestore transaction failed: ", e);
                    visitorCountEl.textContent = "DB Error";
                }

                createGridMixSliders();
                createGenerationMixSliders();
                populateCountryDropdown();
                initializeWithMonthlyProfiles(); // Initialize with monthly profiles instead of seasonal presets
                setupInputSyncing();

                setTimeout(startTutorial, 500);
            }

            await initialize();

            // ============================================
            // OPTIMIZE TAB UI EVENT HANDLERS
            // ============================================

            // Update baseline CO2 display after initialization
            // Use the customBaselineTotalAnnualCO2 which is set during system initialization
            function updateBaselineCO2Display() {
                const baselineCO2Display = document.getElementById('baseline-co2');
                if (baselineCO2Display && customBaselineTotalAnnualCO2 > 0) {
                    baselineCO2Display.textContent = (customBaselineTotalAnnualCO2 / 1e9).toFixed(2);
                    console.log('Baseline CO2 display updated:', (customBaselineTotalAnnualCO2 / 1e9).toFixed(2), 'million MT');
                }
            }

            setTimeout(updateBaselineCO2Display, 2000);  // Increased delay to ensure initialization completes

            // ===== TAB SWITCHING =====
            const tabManual = document.getElementById('tab-manual');
            const tabOptimize = document.getElementById('tab-optimize');
            const manualContent = document.getElementById('manual-mode-content');
            const optimizeContent = document.getElementById('optimize-mode-content');

            tabManual.addEventListener('click', () => {
                tabManual.classList.add('tab-active');
                tabOptimize.classList.remove('tab-active');
                manualContent.classList.remove('hidden');
                optimizeContent.classList.add('hidden');
            });

            tabOptimize.addEventListener('click', () => {
                tabOptimize.classList.add('tab-active');
                tabManual.classList.remove('tab-active');
                optimizeContent.classList.remove('hidden');
                manualContent.classList.add('hidden');
            });

            // ===== RESET SCALING FLAG WHEN TARGET CHANGES =====
            const co2TargetInput = document.getElementById('co2-target-input');
            co2TargetInput.addEventListener('change', function () {
                // Reset scaling flag when user manually changes the target
                // This allows adaptive scaling to work again for the new target
                if (window.lastOptimizationWasScaled !== undefined) {
                    console.log('CO2 target changed - resetting adaptive scaling flag');
                    window.lastOptimizationWasScaled = false;
                }
            });

            // ===== OPTIMIZATION TRIGGER =====
            const runOptimizationBtn = document.getElementById('run-optimization-btn');
            runOptimizationBtn.addEventListener('click', async function () {
                const targetCO2Input = parseFloat(document.getElementById('co2-target-input').value) * 1e9; // Convert million MT to kg (1 million MT = 1e9 kg)
                const allowDAC = document.getElementById('allow-dac').checked;
                const respectCurtailment = document.getElementById('respect-curtailment').checked;

                // Validate input
                if (isNaN(targetCO2Input) || targetCO2Input <= 0) {
                    alert('Please enter a valid CO2 target');
                    return;
                }

                // Disable button during optimization
                this.disabled = true;
                this.textContent = 'Optimizing...';
                this.classList.add('opacity-50', 'cursor-not-allowed');

                // Show progress section
                document.getElementById('optimization-progress').classList.remove('hidden');
                document.getElementById('optimization-results-container').innerHTML = '';

                // Reset progress
                document.getElementById('progress-bar').style.width = '0%';
                document.getElementById('progress-bar').className = 'bg-gradient-to-r from-blue-500 via-green-500 to-emerald-400 h-3 rounded-full transition-all duration-300';
                document.getElementById('progress-phase-label').textContent = 'Phase: Finding Feasible Solution';
                document.getElementById('progress-percent').textContent = '0%';
                document.getElementById('co2-gap-display').textContent = '--';
                document.getElementById('best-cost').textContent = '--';
                document.getElementById('current-co2').textContent = '--';

                // Build optimization context with all necessary data
                const currentValues = {};
                for (const key in sliders) {
                    currentValues[key] = parseFloat(sliders[key].value);
                }

                // Reconstruct CF profiles for optimization
                const selectedCountry = countrySelect.value;
                const baseProfiles = {
                    solar: countryProfiles[selectedCountry]?.solar || countryProfiles['default'].solar,
                    wind: countryProfiles[selectedCountry]?.wind || countryProfiles['default'].wind,
                    offshoreWind: countryProfiles[selectedCountry]?.offshoreWind || countryProfiles['default'].offshoreWind
                };

                const profilesForOptimization = {
                    solar: [],
                    wind: [],
                    offshoreWind: []
                };

                // Get monthly profiles for baseline VRE scaling
                const monthlyProfilesForOpt = getMonthlyProfiles(selectedCountry);

                // CRITICAL FIX: Check if user has edited CF profiles (same logic as manual mode)
                if (currentCFProfileName === "User Defined" &&
                    currentSolarCFProfile.length === 288 &&
                    currentWindCFProfile.length === 288 &&
                    currentOffshoreWindCFProfile.length === 288) {
                    // Use the saved user-defined profiles directly
                    profilesForOptimization.solar = [...currentSolarCFProfile];
                    profilesForOptimization.wind = [...currentWindCFProfile];
                    profilesForOptimization.offshoreWind = [...currentOffshoreWindCFProfile];
                } else {
                    // Build profiles from monthly profiles (California uses direct CAISO-extracted profiles, others use base + multipliers)
                    for (let m = 0; m < 12; m++) {
                        profilesForOptimization.solar.push(...monthlyProfilesForOpt.solar[m]);
                        profilesForOptimization.wind.push(...monthlyProfilesForOpt.wind[m]);
                        profilesForOptimization.offshoreWind.push(...monthlyProfilesForOpt.offshoreWind[m]);
                    }
                }

                // Get baseline storage
                const baselineStorageForOpt = {
                    battery4hr: currentBaselineStorage.battery4hr || 0,
                    battery8hr: currentBaselineStorage.battery8hr || 0,
                    longduration: currentBaselineStorage.longduration || 0
                };

                // Build potential generation object for 12 months with monthly CF scaling
                const potentialGenForOpt = {};
                if (typeof BASELINE_POTENTIAL_GENERATION !== 'undefined') {
                    // Get base CF peaks for ratio scaling
                    const baseCFPeaksForOpt = {
                        solar: Math.max(...baseProfiles.solar),           // ~0.9
                        wind: Math.max(...baseProfiles.wind),             // ~0.65
                        offshoreWind: Math.max(...baseProfiles.offshoreWind)  // ~0.62
                    };

                    for (const tech in BASELINE_POTENTIAL_GENERATION) {
                        potentialGenForOpt[tech] = [];
                        // Apply monthly capacity factor scaling to VRE baseline generation
                        for (let m = 0; m < 12; m++) {
                            const baselineProfile24h = BASELINE_POTENTIAL_GENERATION[tech] || Array(24).fill(0);

                            // Scale VRE technologies by ratio: (monthly peak CF) / (base peak CF)
                            // This avoids double-applying CF since baselineProfile24h already has base CF applied
                            if (tech === 'solar' && monthlyProfilesForOpt.solar) {
                                const monthPeakCF = Math.max(...monthlyProfilesForOpt.solar[m]);
                                const scalingRatio = monthPeakCF / baseCFPeaksForOpt.solar;
                                potentialGenForOpt[tech].push(...baselineProfile24h.map(val => val * scalingRatio));
                            } else if (tech === 'wind' && monthlyProfilesForOpt.wind) {
                                const monthPeakCF = Math.max(...monthlyProfilesForOpt.wind[m]);
                                const scalingRatio = monthPeakCF / baseCFPeaksForOpt.wind;
                                potentialGenForOpt[tech].push(...baselineProfile24h.map(val => val * scalingRatio));
                            } else if (tech === 'offshoreWind' && monthlyProfilesForOpt.offshoreWind) {
                                const monthPeakCF = Math.max(...monthlyProfilesForOpt.offshoreWind[m]);
                                const scalingRatio = monthPeakCF / baseCFPeaksForOpt.offshoreWind;
                                potentialGenForOpt[tech].push(...baselineProfile24h.map(val => val * scalingRatio));
                            } else {
                                // Non-VRE technologies: keep as-is
                                potentialGenForOpt[tech].push(...baselineProfile24h);
                            }
                        }
                    }
                }

                // Set global optimization context for use by optimization functions
                // Use currentCountryInstalledCapacity for baseline (has actual installed capacity data)

                optimizationContext = {
                    baselineCapacity: currentCountryInstalledCapacity || {},
                    baselineStorage: baselineStorageForOpt,
                    demand: [...currentDemand],
                    solarProfile: profilesForOptimization.solar,
                    windProfile: profilesForOptimization.wind,
                    offshoreWindProfile: profilesForOptimization.offshoreWind,
                    potentialGen: potentialGenForOpt,
                    hydroCF: currentHydroCF || 0.45,
                    countryName: selectedCountry,
                    incentives: {
                        solar: currentValues.solarIncentive || 0,
                        wind: currentValues.windIncentive || 0,
                        offshoreWind: currentValues.offshoreWindIncentive || 0,
                        geothermal: currentValues.geothermalIncentive || 0,
                        nuclear: currentValues.nuclearIncentive || 0,
                        biomass: currentValues.biomassIncentive || 0,
                        rng: currentValues.rngIncentive || 0,
                        hydrogen: currentValues.hydrogenIncentive || 0,
                        storage: currentValues.storageIncentive || 0,
                        dac: currentValues.dacIncentive || 0,
                        carbonTax: currentValues.carbonTax || 0,
                        exportPrice: currentValues.exportPrice || -20
                    }
                };

                if (optimizationContext.demand.length !== 288) {
                    alert('Error: Invalid demand profile length. Expected 288 hours, got ' + optimizationContext.demand.length);
                    this.disabled = false;
                    this.textContent = 'Find Optimal Solution';
                    this.classList.remove('opacity-50', 'cursor-not-allowed');
                    return;
                }

                if (optimizationContext.solarProfile.length !== 288) {
                    alert('Error: Invalid solar profile length. Expected 288 hours, got ' + optimizationContext.solarProfile.length);
                    this.disabled = false;
                    this.textContent = 'Find Optimal Solution';
                    this.classList.remove('opacity-50', 'cursor-not-allowed');
                    return;
                }

                try {
                    const result = await multiStartOptimization(targetCO2Input, {
                        allowDAC,
                        respectCurtailment,
                        progressCallback: updateProgressUI,
                        context: optimizationContext,
                        numStarts: 3
                    });

                    if (result.success) {
                        displayOptimizationResults(result);
                    } else {
                        alert(result.message);
                        document.getElementById('optimization-progress').classList.add('hidden');
                    }
                } catch (error) {
                    console.error('Optimization error:', error);
                    alert('Optimization failed: ' + error.message);
                    document.getElementById('optimization-progress').classList.add('hidden');
                } finally {
                    // Re-enable button
                    this.disabled = false;
                    this.textContent = 'Find Optimal Solution';
                    this.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            });

            // ===== PROGRESS UI UPDATE =====
            // Helper to format CO2 display consistently
            function formatCO2Display(co2Value) {
                if (co2Value > 1e9) {
                    return (co2Value / 1e9).toFixed(2) + ' M';
                } else if (co2Value > 1e6) {
                    return (co2Value / 1e6).toFixed(2) + ' k';
                } else {
                    return (co2Value / 1e3).toFixed(2) + ' T';
                }
            }

            function updateProgressUI(iteration, bestCost, currentCO2, context) {
                const progressBar = document.getElementById('progress-bar');
                const phaseLabel = document.getElementById('progress-phase-label');
                const progressPercent = document.getElementById('progress-percent');
                const gapDisplay = document.getElementById('co2-gap-display');
                const gradientClass = 'bg-gradient-to-r from-blue-500 via-green-500 to-emerald-400 h-3 rounded-full transition-all duration-300';

                // Handle DONE signal
                if (iteration === 'DONE') {
                    progressBar.style.width = '100%';
                    progressBar.className = gradientClass;
                    phaseLabel.textContent = 'Complete';
                    progressPercent.textContent = '100%';
                    gapDisplay.textContent = 'Done';
                    if (bestCost && bestCost < Infinity) {
                        document.getElementById('best-cost').textContent = (bestCost / 1e9).toFixed(2);
                    }
                    if (currentCO2) {
                        document.getElementById('current-co2').textContent = formatCO2Display(currentCO2);
                    }
                    return;
                }

                // Calculate progress based on phase
                let progress = 0;
                let phaseName = 'Initializing...';

                if (!context || !context.phase) {
                    progress = Math.min(100, (iteration / OPTIMIZATION_CONFIG.MAX_ITERATIONS) * 100);
                    phaseName = 'Optimizing...';
                } else if (context.phase === 'searching') {
                    // Phase 1 (0% -> 15%): CO2 gap closure
                    phaseName = 'Finding Feasible Solution';
                    if (currentCO2 && context.baselineCO2 && context.targetCO2) {
                        const initialGap = Math.abs(context.baselineCO2 - context.targetCO2);
                        const currentGap = Math.abs(currentCO2 - context.targetCO2);
                        if (initialGap > 0) {
                            progress = Math.max(0, Math.min(15, (1 - currentGap / initialGap) * 15));
                        }
                    }
                } else if (context.phase === 'optimizing') {
                    // Phase 2 (15% -> 90%): Cost improvement + convergence
                    phaseName = 'Optimizing Cost';
                    let costProgress = 0;
                    if (context.firstFeasibleCost && bestCost < context.firstFeasibleCost) {
                        const costImprovement = (context.firstFeasibleCost - bestCost) / context.firstFeasibleCost;
                        costProgress = 1 - Math.exp(-costImprovement * 15);
                    }
                    const convergenceFraction = context.convergenceThreshold > 0
                        ? Math.min(1, context.noImprovementCount / context.convergenceThreshold)
                        : 0;
                    progress = 15 + costProgress * 65 + convergenceFraction * 10;
                } else if (context.phase === 'refining') {
                    // Phase 3 (90% -> 99%): Nelder-Mead
                    phaseName = 'Refining Solution';
                    progress = 90;
                }

                // Scale progress for multi-start runs
                if (context && context.multiStartRun && context.multiStartTotal > 1) {
                    const runFraction = 1 / context.multiStartTotal;
                    const runOffset = (context.multiStartRun - 1) * runFraction;
                    progress = (runOffset + (progress / 100) * runFraction) * 100;
                    phaseName = `Run ${context.multiStartRun}/${context.multiStartTotal}: ${phaseName}`;
                }

                // Update progress bar (gradient color stays constant, width changes)
                const clampedProgress = Math.min(99, Math.max(0, progress));
                progressBar.style.width = `${clampedProgress}%`;
                progressBar.className = gradientClass;

                // Update labels
                phaseLabel.textContent = `Phase: ${phaseName}`;
                progressPercent.textContent = `${Math.round(clampedProgress)}%`;

                // Update CO2 gap display
                if (context && context.targetCO2 && currentCO2) {
                    const gap = Math.abs(currentCO2 - context.targetCO2);
                    gapDisplay.textContent = `${(gap / 1e9).toFixed(2)} MT`;
                } else {
                    gapDisplay.textContent = '--';
                }

                // Update best cost
                if (bestCost && bestCost < Infinity) {
                    document.getElementById('best-cost').textContent = (bestCost / 1e9).toFixed(2);
                }

                // Update CO2 level
                if (currentCO2) {
                    document.getElementById('current-co2').textContent = formatCO2Display(currentCO2);
                } else {
                    document.getElementById('current-co2').textContent = '--';
                }
            }

            // ===== CALCULATE INCREMENTAL COSTS =====
            function calculateIncrementalCosts(solution) {
                let incrementalCAPEX = 0;
                let incrementalFixedOM = 0;
                const d = COST_DATA.discount_rate;

                for (const tech of OPTIMIZATION_CONFIG.TECHNOLOGIES) {
                    const newCapacityGW = solution[tech] || 0;
                    if (newCapacityGW <= 0) continue;

                    const newCapacityKW = newCapacityGW * 1000000;
                    const lifetime = COST_DATA.lifetime[tech] || 30;
                    const crf = (d * Math.pow(1 + d, lifetime)) / (Math.pow(1 + d, lifetime) - 1);

                    if (tech.includes('battery') || tech === 'longduration') {
                        // Storage: cost is per kWh of energy
                        const duration = tech === 'longduration' ? 24 : parseInt(tech.match(/\d+/)[0]);
                        const energyKWh = newCapacityGW * 1000000 * duration;
                        incrementalCAPEX += COST_DATA.capex[tech] * energyKWh * crf;
                        incrementalFixedOM += COST_DATA.fixed_om[tech] * newCapacityKW;
                    } else {
                        // Generation: cost is per kW of capacity
                        // For supply-curve technologies, use blended CAPEX at total deployment level
                        const baselineCapacityGW = (optimizationContext && optimizationContext.baselineCapacity)
                            ? (optimizationContext.baselineCapacity[tech] || 0) : 0;
                        const totalCapacityGW = baselineCapacityGW + newCapacityGW;
                        const effectiveCapex = getBlendedCapex(tech, totalCapacityGW);

                        incrementalCAPEX += effectiveCapex * newCapacityKW * crf;
                        incrementalFixedOM += COST_DATA.fixed_om[tech] * newCapacityKW;
                    }
                }

                return {
                    capex: incrementalCAPEX,
                    fixedOM: incrementalFixedOM,
                    total: incrementalCAPEX + incrementalFixedOM
                };
            }

            // ===== CALCULATE BASELINE COST AND CO2 =====
            function getBaselineMetrics() {
                if (!optimizationContext) return null;

                // Evaluate baseline (zero new capacity)
                const zeroSolution = {};
                for (const tech of OPTIMIZATION_CONFIG.TECHNOLOGIES) {
                    zeroSolution[tech] = 0;
                }

                try {
                    const baselineEval = evaluateSolutionFull(zeroSolution, 999e9); // High CO2 target to be feasible
                    return {
                        cost: baselineEval.systemCost,
                        co2: baselineEval.annualCO2
                    };
                } catch (error) {
                    console.warn('Could not calculate baseline metrics:', error);
                    return null;
                }
            }

            // ===== RESULTS DISPLAY =====
            function displayOptimizationResults(result) {
                // Ensure progress bar shows 100%
                updateProgressUI('DONE', result.cost, result.co2);

                // --- CALCULATE MAX HOURLY SUPPLY FOR FOSSIL FUELS ---
                let maxOptimizedGas = 0;
                let maxOptimizedCoal = 0;
                let maxBaselineGas = 0;
                let maxBaselineCoal = 0;

                if (optimizationContext) {
                    try {
                        // 1. Optimized Result Simulation
                        const optimizedCapacityInputs = {
                            capacity: result.solution,
                            incentives: optimizationContext.incentives
                        };

                        const optimizedSim = getSimulationResult(
                            optimizedCapacityInputs,
                            optimizationContext.solarProfile,
                            optimizationContext.windProfile,
                            optimizationContext.offshoreWindProfile,
                            optimizationContext.potentialGen,
                            optimizationContext.baselineStorage,
                            optimizationContext.hydroCF,
                            optimizationContext.countryName
                        );

                        maxOptimizedGas = Math.max(
                            ...(optimizedSim.generation?.naturalGas || [0]).map((v, i) => v + (optimizedSim.generation?.naturalGasCCGT?.[i] || 0) + (optimizedSim.generation?.naturalGasCT?.[i] || 0))
                        );
                        maxOptimizedCoal = Math.max(...(optimizedSim.generation?.coal || [0]));

                        // 2. Baseline Simulation
                        const zeroSolution = {};
                        for (const tech of OPTIMIZATION_CONFIG.TECHNOLOGIES) zeroSolution[tech] = 0;

                        const baselineCapacityInputs = {
                            capacity: zeroSolution,
                            incentives: optimizationContext.incentives
                        };

                        const baselineSim = getSimulationResult(
                            baselineCapacityInputs,
                            optimizationContext.solarProfile,
                            optimizationContext.windProfile,
                            optimizationContext.offshoreWindProfile,
                            optimizationContext.potentialGen,
                            optimizationContext.baselineStorage,
                            optimizationContext.hydroCF,
                            optimizationContext.countryName
                        );

                        maxBaselineGas = Math.max(
                            ...(baselineSim.generation?.naturalGas || [0]).map((v, i) => v + (baselineSim.generation?.naturalGasCCGT?.[i] || 0) + (baselineSim.generation?.naturalGasCT?.[i] || 0))
                        );
                        maxBaselineCoal = Math.max(...(baselineSim.generation?.coal || [0]));

                    } catch (e) {
                        console.warn('Could not calc max supply profiles', e);
                    }
                }

                // --- DETECT STRANDED ASSETS & OFFER RE-OPTIMIZATION ---
                const installedGas = (optimizationContext.baselineCapacity.naturalGas || 0) + (optimizationContext.baselineCapacity.naturalGasCCGT || 0) + (optimizationContext.baselineCapacity.naturalGasCT || 0);
                const installedCoal = optimizationContext.baselineCapacity.coal || 0;

                // Threshold: If we are using less than 80% of installed capacity at PEAK, suggest retirement
                const canRetireGas = maxOptimizedGas < installedGas * 0.8;
                const canRetireCoal = maxOptimizedCoal < installedCoal * 0.8;

                let retirementHTML = '';
                if (canRetireGas || canRetireCoal) {
                    retirementHTML = `
                     <div class="mb-6 p-4 bg-orange-50 rounded border border-orange-200">
                        <h4 class="font-semibold text-md mb-2 text-orange-900">ðŸ“‰ Opportunity to Retire Fossil Capacity</h4>
                        <p class="text-sm text-gray-700 mb-3">
                            The optimization found that we need significantly less fossil fuel capacity than currently installed. 
                            Retiring these plants will reduce Fixed O&M costs but might require more flexible renewable capacity to meet reliability constraints.
                        </p>
                        <div class="grid grid-cols-2 gap-4 text-sm mb-3">
                            ${canRetireGas ? `
                                <div>
                                    <p class="font-medium">Natural Gas Capacity:</p>
                                    <p class="text-gray-500">Installed: <b>${installedGas.toFixed(2)} GW</b></p>
                                    <p class="text-gray-500">Peak Usage: <b>${maxOptimizedGas.toFixed(2)} GW</b></p>
                                    <div class="mt-1 flex items-center">
                                         <label class="mr-2 text-xs">New Capacity (GW):</label>
                                         <input type="number" id="rerun-gas-cap" value="${(Math.ceil(maxOptimizedGas * 1.1)).toFixed(1)}" class="w-20 px-1 py-0.5 text-sm border rounded">
                                    </div>
                                </div>
                            ` : ''}
                            ${canRetireCoal ? `
                                <div>
                                    <p class="font-medium">Coal Capacity:</p>
                                    <p class="text-gray-500">Installed: <b>${installedCoal.toFixed(2)} GW</b></p>
                                    <p class="text-gray-500">Peak Usage: <b>${maxOptimizedCoal.toFixed(2)} GW</b></p>
                                    <div class="mt-1 flex items-center">
                                         <label class="mr-2 text-xs">New Capacity (GW):</label>
                                         <input type="number" id="rerun-coal-cap" value="${(Math.ceil(maxOptimizedCoal * 1.1)).toFixed(1)}" class="w-20 px-1 py-0.5 text-sm border rounded">
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                        <button id="reduce-fossil-btn" class="w-full py-2 bg-orange-600 hover:bg-orange-700 text-white font-medium rounded text-sm transition-colors shadow-sm">
                            Simulate with Reduced Fossil & Re-Optimize
                        </button>
                     </div>
                     `;
                }


                const curtailmentRate = result.metrics.curtailmentRate * 100;
                const reserveMargin = result.metrics.reserveMargin * 100;

                // Calculate incremental costs
                const incrementalCosts = calculateIncrementalCosts(result.solution);

                // Calculate baseline metrics for comparison
                const baseline = getBaselineMetrics();
                const costIncrease = baseline ? result.cost - baseline.cost : null;
                const co2Reduction = baseline ? baseline.co2 - result.co2 : null;
                const carbonTaxSavings = co2Reduction ? (co2Reduction / 1000) * (optimizationContext?.incentives?.carbonTax || 0) : null; // carbonTax is $/ton, co2Reduction is kg

                // Calculate Flexible Capacity Stats for Display
                const peakDemand = Math.max(...optimizationContext.demand);
                // Fix: Use result.metrics.reserveMargin (raw fraction, e.g. 0.2) instead of reserveMargin (percentage, e.g. 20)
                const flexibleCapacityGW = (result.metrics.reserveMargin + 1.0) * peakDemand;
                const flexShare = (flexibleCapacityGW / peakDemand) * 100;

                const resultHTML = `
                    <div class="optimization-results p-6 bg-green-50 rounded-lg border-2 border-green-200">
                        <h3 class="font-bold text-2xl mb-4 text-green-800">âœ“ Optimization Complete</h3>

                        ${retirementHTML}

                        <div class="grid grid-cols-2 gap-4 mb-6">
                            <div class="metric-card">
                                <p class="text-sm font-medium text-gray-600">Total System Cost</p>
                                <p class="text-3xl font-bold text-blue-600">
                                    $${(result.cost / 1e9).toFixed(2)}B/year
                                </p>
                            </div>

                            <div class="metric-card">
                                <p class="text-sm font-medium text-gray-600">Annual CO2 Emissions</p>
                                <p class="text-3xl font-bold text-green-600">
                                    ${(result.co2 / 1e9).toFixed(2)} million MT
                                </p>
                            </div>

                            <div class="metric-card">
                                <p class="text-sm font-medium text-gray-600" title="Flexible Capacity relative to Peak Demand">Reserve Margin (Flexible)</p>
                                <p class="text-2xl font-bold ${reserveMargin >= 0.15 ? 'text-green-600' : 'text-yellow-600'}">
                                    ${reserveMargin.toFixed(1)}%
                                </p>
                            </div>

                            <div class="metric-card">
                                <p class="text-sm font-medium text-gray-600">Flexible Capacity</p>
                                <p class="text-2xl font-bold text-blue-800">
                                    ${flexibleCapacityGW.toFixed(1)} GW
                                    <span class="text-sm font-normal text-gray-500 block">(${flexShare.toFixed(0)}% of Peak)</span>
                                </p>
                            </div>
                        </div>

                        <div class="mb-6">
                            <h4 class="font-semibold text-lg mb-3 text-gray-800">Recommended Capacity Additions:</h4>
                            <div class="grid grid-cols-2 gap-2">
                                ${formatCapacityAdditions(result.solution)}
                            </div>
                        </div>

                        <div class="mb-6 p-4 bg-blue-50 rounded border border-blue-200">
                            <h4 class="font-semibold text-md mb-2 text-blue-900">ðŸ’° Cost Breakdown</h4>
                            <div class="text-sm text-gray-700 space-y-2">
                                <div class="grid grid-cols-2 gap-4 mb-2">
                                    <div>
                                        <p class="font-semibold">Total System Cost:</p>
                                        <p class="text-2xl font-bold text-blue-600">$${(result.cost / 1e9).toFixed(2)}B/year</p>
                                    </div>
                                    ${baseline ? `
                                    <div>
                                        <p class="font-semibold">Baseline System Cost:</p>
                                        <p class="text-2xl font-bold text-gray-600">$${(baseline.cost / 1e9).toFixed(2)}B/year</p>
                                    </div>
                                    ` : ''}
                                </div>
                                ${costIncrease !== null ? `
                                <div class="p-3 bg-white rounded border border-blue-300">
                                    <p class="font-semibold text-blue-900">ðŸ’¡ Cost Impact:</p>
                                    <p class="text-lg">${costIncrease >= 0 ? '+' : ''}$${(costIncrease / 1e9).toFixed(2)}B/year (${((costIncrease / baseline.cost) * 100).toFixed(1)}% ${costIncrease >= 0 ? 'increase' : 'decrease'})</p>
                                </div>
                                ` : ''}
                                <div class="p-3 bg-white rounded border border-green-300">
                                    <p class="font-semibold text-green-900">ðŸ“Š Incremental NEW Capacity Costs:</p>
                                    <ul class="list-disc ml-5 space-y-1 mt-1">
                                        <li>Annualized CAPEX (7% discount): $${(incrementalCosts.capex / 1e9).toFixed(2)}B/year</li>
                                        <li>Fixed O&M: $${(incrementalCosts.fixedOM / 1e9).toFixed(2)}B/year</li>
                                        <li><strong>Total Incremental Cost: $${(incrementalCosts.total / 1e9).toFixed(2)}B/year</strong></li>
                                    </ul>
                                </div>
                                ${co2Reduction !== null && co2Reduction > 0 ? `
                                <div class="p-3 bg-green-100 rounded border border-green-400">
                                    <p class="font-semibold text-green-900">ðŸŒ± CO2 Reduction Benefits:</p>
                                    <ul class="list-disc ml-5 space-y-1 mt-1">
                                        <li>CO2 Reduction: ${(co2Reduction / 1e9).toFixed(2)} million MT/year</li>
                                        <li>Baseline: ${(baseline.co2 / 1e9).toFixed(2)} million MT â†’ Result: ${(result.co2 / 1e9).toFixed(2)} million MT</li>
                                        ${carbonTaxSavings && carbonTaxSavings > 0 ? `<li><strong>Carbon Tax Savings: $${(carbonTaxSavings / 1e9).toFixed(2)}B/year</strong> (at $${optimizationContext.incentives.carbonTax}/ton)</li>` : ''}
                                        ${costIncrease !== null && carbonTaxSavings ? `<li><strong>Net Cost After Carbon Savings: $${((costIncrease - carbonTaxSavings) / 1e9).toFixed(2)}B/year</strong></li>` : ''}
                                        ${co2Reduction > 0 && costIncrease > 0 ? `<li><strong>Abatement Cost: $${(costIncrease / (co2Reduction / 1e3)).toFixed(0)}/MT CO2</strong></li>` : ''}
                                    </ul>
                                </div>
                                ` : ''}
                            </div>
                        </div>

                        <div class="flex gap-3">
                            <button id="apply-solution-btn"
                                    class="btn btn-success flex-1">
                                Apply This Solution to Sliders
                            </button>
                            <button id="export-solution-btn"
                                    class="btn btn-secondary">
                                Export to CSV
                            </button>
                        </div>
                    </div>
                `;

                document.getElementById('optimization-results-container').innerHTML = resultHTML;

                // Wire up action buttons
                if (document.getElementById('reduce-fossil-btn')) {
                    document.getElementById('reduce-fossil-btn').addEventListener('click', () => {
                        const newGas = document.getElementById('rerun-gas-cap') ? parseFloat(document.getElementById('rerun-gas-cap').value) : null;
                        const newCoal = document.getElementById('rerun-coal-cap') ? parseFloat(document.getElementById('rerun-coal-cap').value) : null;

                        // Show custom modal instead of browser confirm
                        showConfirmationModal(() => {
                            // Update context
                            if (newGas !== null) {
                                // Simple heuristic: reduce all gas types proportionally or just set one type
                                // Let's set generic 'naturalGas' capacity to this value and zero out others to simplify
                                optimizationContext.baselineCapacity.naturalGas = newGas;
                                optimizationContext.baselineCapacity.naturalGasCCGT = 0;
                                optimizationContext.baselineCapacity.naturalGasCT = 0;
                            }
                            if (newCoal !== null) {
                                optimizationContext.baselineCapacity.coal = newCoal;
                            }

                            // Re-run
                            document.getElementById('run-optimization-btn').click();
                        });
                    });
                }

                document.getElementById('apply-solution-btn').addEventListener('click', () => {
                    applyOptimalSolution(result.solution);
                });

                document.getElementById('export-solution-btn').addEventListener('click', () => {
                    exportSolutionToCSV(result);
                });
            }

            // ===== FORMAT CAPACITY ADDITIONS =====
            function formatCapacityAdditions(solution) {
                const items = [];

                const labels = {
                    solar: 'Solar',
                    wind: 'Onshore Wind',
                    offshoreWind: 'Offshore Wind',
                    nuclear: 'Nuclear',
                    geothermal: 'Geothermal',
                    biomass: 'Biomass',
                    rng: 'RNG (Biogas)',
                    hydrogen: 'Hydrogen',
                    battery4hr: '4-hr Battery',
                    battery8hr: '8-hr Battery',
                    longduration: 'Long-Duration Storage',
                    dac: 'Direct Air Capture'
                };

                for (const [tech, capacity] of Object.entries(solution)) {
                    if (capacity > 0.1) {  // Only show meaningful additions
                        const unit = tech === 'dac' ? 't/hr' :
                            (tech.includes('battery') || tech === 'longduration') ? 'GWh' : 'GW';
                        items.push(`
                            <div class="capacity-item">
                                <span class="font-medium text-gray-700">${labels[tech] || tech}:</span>
                                <span class="font-bold text-blue-700">+${capacity.toFixed(1)} ${unit}</span>
                            </div>
                        `);
                    }
                }

                return items.length > 0 ? items.join('') : '<p class="text-gray-500 italic">No capacity additions recommended</p>';
            }

            // ===== APPLY SOLUTION TO SLIDERS =====
            function applyOptimalSolution(solution) {
                // Switch to manual tab
                tabManual.click();

                // IMPORTANT: Sliders expect NEW capacity additions only (not total)
                // Manual mode adds baseline automatically through potentialGen
                // solution contains NEW capacity additions from optimization (which is what we want!)

                // Store the expected results for comparison
                window.expectedOptimizationResults = {
                    solution: { ...solution },
                    timestamp: Date.now()
                };

                // NOTE: High-precision mode disabled - user confirmed it's not the issue
                // The simulation differences are caused by something else, not slider rounding

                // First, reset ALL sliders to 0 (to clear any previous values)
                for (const key in sliders) {
                    // Only reset capacity sliders, not incentive sliders
                    if (!key.includes('Incentive') && key !== 'carbonTax' && key !== 'exportPrice') {
                        const slider = sliders[key];
                        if (slider && OPTIMIZATION_CONFIG.TECHNOLOGIES.includes(key)) {
                            slider.value = 0;
                        }
                    }
                }

                // Store optimization result for comparison
                window.lastOptimizationResult = {
                    solution: { ...solution },
                    co2: window.lastOptimizationCO2,
                    curtailment: window.lastOptimizationCurtailment,
                    cost: window.lastOptimizationCost
                };

                // Update sliders with NEW capacity only (rounded to 2 decimal places for usability)
                for (const [tech, newCapacity] of Object.entries(solution)) {
                    const slider = sliders[tech];
                    if (slider) {
                        const roundedValue = Math.round((newCapacity || 0) * 100) / 100;  // Round to 2 decimal places
                        slider.value = roundedValue;
                        slider.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                }

                // Trigger simulation update directly (debouncedRunSimulation is scoped inside setupInputSyncing)
                runSimulation();

                // Scroll to top
                window.scrollTo({ top: 0, behavior: 'smooth' });

                // Show notification
                showNotification('âœ“ Optimal solution applied to sliders');
            }

            // ===== EXPORT TO CSV =====
            function exportSolutionToCSV(result) {
                const rows = [
                    ['Technology', 'Capacity Addition', 'Unit'],
                    ['Solar', result.solution.solar || 0, 'GW'],
                    ['Onshore Wind', result.solution.wind || 0, 'GW'],
                    ['Offshore Wind', result.solution.offshoreWind || 0, 'GW'],
                    ['Nuclear', result.solution.nuclear || 0, 'GW'],
                    ['Geothermal', result.solution.geothermal || 0, 'GW'],
                    ['4-hr Battery', result.solution.battery4hr || 0, 'GWh'],
                    ['8-hr Battery', result.solution.battery8hr || 0, 'GWh'],
                    ['Long-Duration', result.solution.longduration || 0, 'GWh'],
                    ['DAC', result.solution.dac || 0, 'tons/hr'],
                    [],
                    ['Metric', 'Value', 'Unit'],
                    ['Total System Cost', (result.cost / 1e9).toFixed(2), 'Billion $/year'],
                    ['Annual CO2 Emissions', (result.co2 / 1e9).toFixed(2), 'Million MT'],
                    ['Reserve Margin', (result.metrics.reserveMargin * 100).toFixed(1), '%'],
                    ['Curtailment Rate', (result.metrics.curtailmentRate * 100).toFixed(1), '%']
                ];

                const csvContent = rows.map(row => row.join(',')).join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `optimization_results_${Date.now()}.csv`;
                a.click();

                URL.revokeObjectURL(url);

                showNotification('Results exported to CSV!');
            }

            // ===== SHOW CONFIRMATION MODAL =====
            function showConfirmationModal(onConfirm, message = 'This will modify the baseline capacity assumptions and re-run the optimization. Proceed?') {
                const modal = document.getElementById('confirmation-modal');
                const messageElement = document.getElementById('confirmation-modal-message');
                const okButton = document.getElementById('confirmation-modal-ok');
                const cancelButton = document.getElementById('confirmation-modal-cancel');

                // Set message
                messageElement.textContent = message;

                // Show modal
                modal.classList.remove('hidden');

                // Handle OK button
                const handleOk = () => {
                    modal.classList.add('hidden');
                    okButton.removeEventListener('click', handleOk);
                    cancelButton.removeEventListener('click', handleCancel);
                    if (onConfirm) onConfirm();
                };

                // Handle Cancel button
                const handleCancel = () => {
                    modal.classList.add('hidden');
                    okButton.removeEventListener('click', handleOk);
                    cancelButton.removeEventListener('click', handleCancel);
                };

                // Add event listeners
                okButton.addEventListener('click', handleOk);
                cancelButton.addEventListener('click', handleCancel);

                // Close on backdrop click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        handleCancel();
                    }
                });

                // Close on Escape key
                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        handleCancel();
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                document.addEventListener('keydown', handleEscape);
            }

            // ===== SHOW NOTIFICATION =====
            function showNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            }

            // ===== EXPOSE TEST FUNCTION TO WINDOW (for console debugging) =====
            window.testOptimization = async function (targetCO2MT = 30) {
                console.log('\n========== TESTING OPTIMIZATION ==========');
                console.log(`Target CO2: ${targetCO2MT} million MT`);

                if (!optimizationContext) {
                    console.error('ERROR: Optimization context not initialized. Please switch to Optimize tab first to initialize context.');
                    return;
                }

                const targetCO2 = targetCO2MT * 1e6; // Convert to kg

                try {
                    console.log('Starting optimization...');
                    const result = await optimizeCapacityExpansion(targetCO2, {
                        allowDAC: true,
                        respectCurtailment: true,
                        progressCallback: (iter, cost, co2) => {
                            if (iter % 50 === 0) {
                                console.log(`Iteration ${iter}: Cost = $${(cost / 1e9).toFixed(2)}B, CO2 = ${(co2 / 1e9).toFixed(2)} million MT`);
                            }
                        }
                    });

                    console.log('\n========== OPTIMIZATION RESULTS ==========');
                    if (result.success) {
                        console.log('âœ“ SUCCESS');
                        console.log('Total System Cost:', `$${(result.cost / 1e9).toFixed(2)}B/year`);
                        console.log('Annual CO2:', `${(result.co2 / 1e9).toFixed(2)} million MT`);
                        console.log('Reserve Margin:', `${(result.metrics.reserveMargin * 100).toFixed(1)}%`);
                        console.log('Curtailment Rate:', `${(result.metrics.curtailmentRate * 100).toFixed(1)}%`);
                        console.log('\nCapacity Additions:');
                        for (const [tech, capacity] of Object.entries(result.solution)) {
                            if (capacity > 0.1) {
                                const unit = tech.includes('battery') || tech === 'longduration' ? 'GWh' :
                                    tech === 'dac' ? 'tons/hr' : 'GW';
                                console.log(`  ${tech}: +${capacity.toFixed(2)} ${unit}`);
                            }
                        }
                    } else {
                        console.log('âœ— FAILED');
                        console.log('Message:', result.message);
                    }

                    return result;
                } catch (error) {
                    console.error('ERROR:', error);
                    console.error('Stack:', error.stack);
                    throw error;
                }
            };

            console.log('âœ“ Test function loaded. Run testOptimization(30) in console to test with 30 MT CO2 target.');

        });
    </script>

    <!-- Magnifying glass for capacity factor editing (positioned at body level for correct fixed positioning) -->
    <div id="cf-magnifier" class="hidden"
        style="position: fixed; pointer-events: none; z-index: 9999; width: 200px; height: 200px; border: 3px solid #4B5563; border-radius: 50%; overflow: hidden; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); background: white;">
        <canvas id="cf-magnifier-canvas" width="200" height="200"></canvas>
    </div>
</body>

</html>
